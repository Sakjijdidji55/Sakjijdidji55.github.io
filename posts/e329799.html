<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C++后端服务器实现笔记 | 迷路的小朋友</title><meta name="author" content="欣冻"><meta name="copyright" content="欣冻"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C++后端服务器实现笔记 仓库 项目结构 123456789101112131415161718192021222324252627282930313233343536├── .github&#x2F;             # GitHub配置目录│   └── workflows&#x2F;       # GitHub Actions工作流├── .gitignore           # Git忽略配置├">
<meta property="og:type" content="article">
<meta property="og:title" content="C++后端服务器实现笔记">
<meta property="og:url" content="https://sakjijdidji55.github.io/posts/e329799.html">
<meta property="og:site_name" content="迷路的小朋友">
<meta property="og:description" content="C++后端服务器实现笔记 仓库 项目结构 123456789101112131415161718192021222324252627282930313233343536├── .github&#x2F;             # GitHub配置目录│   └── workflows&#x2F;       # GitHub Actions工作流├── .gitignore           # Git忽略配置├">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.imgs.ovh/2025/12/03/CsbqBg.md.png">
<meta property="article:published_time" content="2025-12-01T08:00:00.000Z">
<meta property="article:modified_time" content="2025-12-12T03:10:27.988Z">
<meta property="article:author" content="欣冻">
<meta property="article:tag" content="博客, 技术, 生活, tanxin, tanxin.me, 吃好喝好, 玩好, 睡好, 迷路的小朋友,tanxin55">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.imgs.ovh/2025/12/03/CsbqBg.md.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "C++后端服务器实现笔记",
  "url": "https://sakjijdidji55.github.io/posts/e329799.html",
  "image": "https://i.imgs.ovh/2025/12/03/CsbqBg.md.png",
  "datePublished": "2025-12-01T08:00:00.000Z",
  "dateModified": "2025-12-12T03:10:27.988Z",
  "author": [
    {
      "@type": "Person",
      "name": "欣冻",
      "url": "https://sakjijdidji55.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/logo.ico"><link rel="canonical" href="https://sakjijdidji55.github.io/posts/e329799.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++后端服务器实现笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="迷路的小朋友" type="application/atom+xml">
</head><body><div id="web_bg" style="background-image: url(https://i.imgs.ovh/2025/07/03/qLFy9.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/my-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/bangumis/index.html"><i class="fa-fw fas fa-home"></i><span> 追番</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://i.imgs.ovh/2025/12/03/CsbqBg.md.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/logo.png" alt="Logo"><span class="site-name">迷路的小朋友</span></a><a class="nav-page-title" href="/"><span class="site-name">C++后端服务器实现笔记</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/bangumis/index.html"><i class="fa-fw fas fa-home"></i><span> 追番</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">C++后端服务器实现笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-12-01T08:00:00.000Z" title="发表于 2025-12-01 16:00:00">2025-12-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-12-12T03:10:27.988Z" title="更新于 2025-12-12 11:10:27">2025-12-12</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>C++后端服务器实现笔记</h1>
<h2 id="仓库"><a target="_blank" rel="noopener" href="https://github.com/Sakjijdidji55/C-backend-server-framework">仓库</a></h2>
<h2 id="项目结构">项目结构</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">├── .github/             # GitHub配置目录</span><br><span class="line">│   └── workflows/       # GitHub Actions工作流</span><br><span class="line">├── .gitignore           # Git忽略配置</span><br><span class="line">├── 3rdparty/            # 第三方库目录</span><br><span class="line">│   ├── mysql/           # MySQL客户端库</span><br><span class="line">│   │   ├── include/     # MySQL头文件</span><br><span class="line">│   │   └── lib/         # MySQL库文件</span><br><span class="line">│   └── redis/           # Redis客户端库</span><br><span class="line">│       ├── include/     # Redis头文件</span><br><span class="line">│       └── lib/         # Redis库文件</span><br><span class="line">├── CMakeLists.txt       # CMake构建配置</span><br><span class="line">├── LICENSE              # 许可证文件</span><br><span class="line">├── README.md            # 项目说明文档</span><br><span class="line">├── include/             # 头文件目录</span><br><span class="line">│   ├── DBConnector.h    # 数据库连接器头文件</span><br><span class="line">│   ├── Handler.h        # 请求处理器头文件</span><br><span class="line">│   ├── JsonValue.h      # JSON处理头文件</span><br><span class="line">│   ├── Log.h            # 日志系统头文件</span><br><span class="line">│   ├── RDConnector.h    # Redis连接器头文件</span><br><span class="line">│   ├── Server.h         # 服务器核心头文件</span><br><span class="line">│   ├── Threadpool.h     # 线程池头文件</span><br><span class="line">│   ├── jwt.h            # JWT认证头文件</span><br><span class="line">│   └── route.h          # 路由系统头文件</span><br><span class="line">├── main.cpp             # 主程序入口</span><br><span class="line">├── model/               # 数据模型目录</span><br><span class="line">│   ├── Model.cpp        # 数据模型实现</span><br><span class="line">│   └── Model.h          # 数据模型头文件</span><br><span class="line">└── src/                 # 源代码目录</span><br><span class="line">    ├── DBConnector.cpp  # 数据库连接器实现</span><br><span class="line">    ├── JsonValue.cpp    # JSON处理实现</span><br><span class="line">    ├── Log.cpp          # 日志系统实现</span><br><span class="line">    ├── RDConnector.cpp  # Redis连接器实现</span><br><span class="line">    ├── Server.cpp       # 服务器核心实现</span><br><span class="line">    ├── Threadpool.cpp   # 线程池实现</span><br><span class="line">    ├── jwt.cpp          # JWT认证实现</span><br><span class="line">    └── route.cpp        # 路由系统实现</span><br></pre></td></tr></table></figure>
<h2 id="原理解析">原理解析</h2>
<h3 id="1-JWT认证原理">1. JWT认证原理</h3>
<p>JWT（JSON Web Token）是一种用于在网络应用间安全传输信息的开放标准（RFC 7519）。它通过紧凑且自包含的方式在各方之间以JSON对象形式安全地传输信息。这些信息可以被验证和信任，因为它们是数字签名的。</p>
<p>JWT的核心组成部分包括：</p>
<ol>
<li>Header（头部）：包含令牌类型和使用的签名算法</li>
<li>Payload（负载）：包含声明（claims），如用户信息和过期时间</li>
<li>Signature（签名）：用于验证消息是否被篡改</li>
</ol>
<p>在我们的实现中，JWT主要用于身份认证和会话管理。服务器生成JWT后，客户端在后续请求中携带此令牌，服务器通过验证令牌的有效性来确认用户身份。<br>
}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 1，Base64 编码</span><br><span class="line"></span><br><span class="line">Base64 是一种基于64个可打印字符来表示二进制数据的表示方法。它可以将二进制数据转换为文本字符串，以便在文本环境中传输和存储。</span><br><span class="line"></span><br><span class="line">Base64 编码的步骤如下：</span><br><span class="line"></span><br><span class="line">1. 将二进制数据按照每3个字节一组进行分组。</span><br><span class="line">2. 将每个字节转换为4个6位的二进制数。</span><br><span class="line">3. 将这4个6位的二进制数编码拼接成一个由4个字符组成的字符串。</span><br><span class="line">4. 如果二进制数据的长度不是3的倍数，则在最后补0，直到长度为3的倍数。然后按照上述步骤进行编码。</span><br><span class="line"></span><br><span class="line">项目内代码逻辑</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">/**</span><br><span class="line"> * @brief JWT类的base64UrlEncode方法</span><br><span class="line"> * @param data 需要进行base64Url编码的原始数据</span><br><span class="line"> * @return 返回编码后的字符串</span><br><span class="line"> *</span><br><span class="line"> * 该方法实现了base64Url编码，它是一种base64编码的变体，主要用于URL安全。</span><br><span class="line"> * 与标准base64编码相比，它将&#x27;+&#x27;替换为&#x27;-&#x27;，&#x27;/&#x27;替换为&#x27;_&#x27;，并移除了末尾的&#x27;=&#x27;填充字符。</span><br><span class="line"> */</span><br><span class="line">std::string JWT::base64UrlEncode(const std::string&amp; data) &#123;</span><br><span class="line">    // 定义base64编码表</span><br><span class="line">    static const char* base64Chars = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;</span><br><span class="line">    std::string encoded;</span><br><span class="line">    // 预分配足够的内存空间，提高性能</span><br><span class="line">    encoded.reserve(((data.size() + 2) / 3) * 4);</span><br><span class="line"></span><br><span class="line">    std::size_t i = 0;</span><br><span class="line">    // 处理完整的三字节块</span><br><span class="line">    while (i + 3 &lt;= data.size()) &#123;</span><br><span class="line">        auto b1 = static_cast&lt;unsigned char&gt;(data[i]);</span><br><span class="line">        auto b2 = static_cast&lt;unsigned char&gt;(data[i + 1]);</span><br><span class="line">        auto b3 = static_cast&lt;unsigned char&gt;(data[i + 2]);</span><br><span class="line"></span><br><span class="line">        // 将三个字节转换为四个base64字符</span><br><span class="line">        encoded.push_back(base64Chars[b1 &gt;&gt; 2]);</span><br><span class="line">        encoded.push_back(base64Chars[((b1 &amp; 0x03) &lt;&lt; 4) | (b2 &gt;&gt; 4)]);</span><br><span class="line">        encoded.push_back(base64Chars[((b2 &amp; 0x0F) &lt;&lt; 2) | (b3 &gt;&gt; 6)]);</span><br><span class="line">        encoded.push_back(base64Chars[b3 &amp; 0x3F]);</span><br><span class="line">        i += 3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 处理剩余的不完整字节块</span><br><span class="line">    if (i &lt; data.size()) &#123;</span><br><span class="line">        auto b1 = static_cast&lt;unsigned char&gt;(data[i]);</span><br><span class="line">        encoded.push_back(base64Chars[b1 &gt;&gt; 2]);</span><br><span class="line">        if (i + 1 &lt; data.size()) &#123;</span><br><span class="line">            auto b2 = static_cast&lt;unsigned char&gt;(data[i + 1]);</span><br><span class="line">            encoded.push_back(base64Chars[((b1 &amp; 0x03) &lt;&lt; 4) | (b2 &gt;&gt; 4)]);</span><br><span class="line">            encoded.push_back(base64Chars[(b2 &amp; 0x0F) &lt;&lt; 2]);</span><br><span class="line">            encoded.push_back(&#x27;=&#x27;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            encoded.push_back(base64Chars[(b1 &amp; 0x03) &lt;&lt; 4]);</span><br><span class="line">            encoded.push_back(&#x27;=&#x27;);</span><br><span class="line">            encoded.push_back(&#x27;=&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将base64编码转换为URL安全的格式</span><br><span class="line">    for (char&amp; ch : encoded) &#123;</span><br><span class="line">        if (ch == &#x27;+&#x27;) &#123;</span><br><span class="line">            ch = &#x27;-&#x27;;</span><br><span class="line">        &#125; else if (ch == &#x27;/&#x27;) &#123;</span><br><span class="line">            ch = &#x27;_&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 移除末尾的填充字符&#x27;=&#x27;</span><br><span class="line">    while (!encoded.empty() &amp;&amp; encoded.back() == &#x27;=&#x27;) &#123;</span><br><span class="line">        encoded.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return encoded;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时，需要有 Base64 解码函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Base64URL解码函数</span></span><br><span class="line"><span class="comment"> * @param data 需要解码的Base64URL字符串</span></span><br><span class="line"><span class="comment"> * @return 解码后的原始字符串</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 该函数将Base64URL编码的字符串转换为原始字符串。Base64URL是Base64的变种，</span></span><br><span class="line"><span class="comment"> * 使用&#x27;-&#x27;和&#x27;_&#x27;替代了标准的&#x27;+&#x27;和&#x27;/&#x27;，同时不使用填充字符&#x27;=&#x27;。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">std::string <span class="title">JWT::base64UrlDecode</span><span class="params">(<span class="type">const</span> std::string&amp; data)</span> </span>&#123;</span><br><span class="line">    std::string base64 = data;</span><br><span class="line">    <span class="comment">// 将Base64URL的特殊字符转换为标准Base64字符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span>&amp; ch : base64) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            ch = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;_&#x27;</span>) &#123;</span><br><span class="line">            ch = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加填充字符&#x27;=&#x27;，使字符串长度为4的倍数</span></span><br><span class="line">    <span class="keyword">while</span> (base<span class="number">64.</span><span class="built_in">size</span>() % <span class="number">4</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        base<span class="number">64.</span><span class="built_in">push_back</span>(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lambda函数：将Base64字符转换为对应的6位整数值</span></span><br><span class="line">    <span class="keyword">auto</span> decodeChar = [](<span class="type">char</span> ch) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27;A&#x27;</span> &lt;= ch &amp;&amp; ch &lt;= <span class="string">&#x27;Z&#x27;</span>) <span class="keyword">return</span> ch - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27;a&#x27;</span> &lt;= ch &amp;&amp; ch &lt;= <span class="string">&#x27;z&#x27;</span>) <span class="keyword">return</span> ch - <span class="string">&#x27;a&#x27;</span> + <span class="number">26</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span> &lt;= ch &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) <span class="keyword">return</span> ch - <span class="string">&#x27;0&#x27;</span> + <span class="number">52</span>;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;+&#x27;</span>) <span class="keyword">return</span> <span class="number">62</span>;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;/&#x27;</span>) <span class="keyword">return</span> <span class="number">63</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::string decoded;</span><br><span class="line">    <span class="comment">// 预分配内存，提高性能</span></span><br><span class="line">    decoded.<span class="built_in">reserve</span>((base<span class="number">64.</span><span class="built_in">size</span>() / <span class="number">4</span>) * <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次处理4个Base64字符</span></span><br><span class="line">    <span class="keyword">for</span> (std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; base<span class="number">64.</span><span class="built_in">size</span>(); i += <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="type">int</span> val1 = <span class="built_in">decodeChar</span>(base64[i]);</span><br><span class="line">        <span class="type">int</span> val2 = <span class="built_in">decodeChar</span>(base64[i + <span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> val3 = base64[i + <span class="number">2</span>] == <span class="string">&#x27;=&#x27;</span> ? <span class="number">-1</span> : <span class="built_in">decodeChar</span>(base64[i + <span class="number">2</span>]);</span><br><span class="line">        <span class="type">int</span> val4 = base64[i + <span class="number">3</span>] == <span class="string">&#x27;=&#x27;</span> ? <span class="number">-1</span> : <span class="built_in">decodeChar</span>(base64[i + <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将4个6位值转换为3个8位字节</span></span><br><span class="line">        decoded.<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;((val1 &lt;&lt; <span class="number">2</span>) | (val2 &gt;&gt; <span class="number">4</span>)));</span><br><span class="line">        <span class="keyword">if</span> (val3 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            decoded.<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(((val2 &amp; <span class="number">0x0F</span>) &lt;&lt; <span class="number">4</span>) | (val3 &gt;&gt; <span class="number">2</span>)));</span><br><span class="line">            <span class="keyword">if</span> (val4 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                decoded.<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(((val3 &amp; <span class="number">0x03</span>) &lt;&lt; <span class="number">6</span>) | val4));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decoded;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2，sha256-签名">2，sha256 签名</h4>
<p>SHA-256 是一种安全哈希算法，它可以生成一个256位的哈希值。哈希值是一个固定长度的字符串，用于唯一标识输入数据。SHA-256 算法具有以下特点：</p>
<ol>
<li>输入数据的微小变化会导致哈希值的巨大变化，这使得哈希值具有抗冲突性。也就是说，两个不同的输入数据几乎不可能产生相同的哈希值。</li>
<li>SHA-256 算法是不可逆的，即无法从哈希值反推出原始数据。</li>
<li>SHA-256 算法是公开的，任何人都可以使用它来生成哈希值。</li>
<li>我们可以将哈希值转成一个固定的长度（例如32个字符）的十六进制字符串，以便于存储和传输。</li>
</ol>
<p>实现原理：</p>
<ol>
<li>将需要签名的数据转换为字节数组。</li>
<li>使用 SHA-256 算法对字节数组进行哈希运算，生成一个256位的哈希值。</li>
<li>将哈希值转换为十六进制字符串。</li>
</ol>
<p>具体算法超级复杂，直接看源码，一大堆异或（其实只要不可逆，怎么算都行），翻转等等</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 计算输入字符串的SHA256哈希值</span></span><br><span class="line"><span class="comment"> * @param data 输入字符串</span></span><br><span class="line"><span class="comment"> * @return 返回计算得到的SHA256哈希值字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">std::string <span class="title">JWT::sha256</span><span class="params">(<span class="type">const</span> std::string&amp; data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化SHA256哈希值的初始常量</span></span><br><span class="line">    std::array&lt;std::<span class="type">uint32_t</span>, 8&gt; hash&#123;</span><br><span class="line">            <span class="number">0x6a09e667</span>, <span class="number">0xbb67ae85</span>, <span class="number">0x3c6ef372</span>, <span class="number">0xa54ff53a</span>,</span><br><span class="line">            <span class="number">0x510e527f</span>, <span class="number">0x9b05688c</span>, <span class="number">0x1f83d9ab</span>, <span class="number">0x5be0cd19</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将输入字符串转换为字节数组</span></span><br><span class="line">    <span class="function">std::vector&lt;std::<span class="type">uint8_t</span>&gt; <span class="title">message</span><span class="params">(data.begin(), data.end())</span></span>;</span><br><span class="line">    <span class="comment">// 记录原始数据的比特长度</span></span><br><span class="line">    <span class="type">const</span> std::<span class="type">uint64_t</span> originalBitLength = <span class="built_in">static_cast</span>&lt;std::<span class="type">uint64_t</span>&gt;(message.<span class="built_in">size</span>()) * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加填充位1</span></span><br><span class="line">    message.<span class="built_in">push_back</span>(<span class="number">0x80</span>);</span><br><span class="line">    <span class="comment">// 添加填充位0，直到消息长度满足模64等于56</span></span><br><span class="line">    <span class="keyword">while</span> ((message.<span class="built_in">size</span>() % <span class="number">64</span>) != <span class="number">56</span>) &#123;</span><br><span class="line">        message.<span class="built_in">push_back</span>(<span class="number">0x00</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加原始消息长度信息（64位大端序）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">7</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        message.<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;std::<span class="type">uint8_t</span>&gt;((originalBitLength &gt;&gt; (i * <span class="number">8</span>)) &amp; <span class="number">0xFF</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理消息的每个512位（64字节）的块</span></span><br><span class="line">    <span class="keyword">for</span> (std::<span class="type">size_t</span> offset = <span class="number">0</span>; offset &lt; message.<span class="built_in">size</span>(); offset += <span class="number">64</span>) &#123;</span><br><span class="line">        std::<span class="type">uint32_t</span> w[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将当前64字节的块分解为16个32位字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i) &#123;</span><br><span class="line">            w[i] = (<span class="built_in">static_cast</span>&lt;std::<span class="type">uint32_t</span>&gt;(message[offset + <span class="number">4</span> * i]) &lt;&lt; <span class="number">24</span>) |</span><br><span class="line">                   (<span class="built_in">static_cast</span>&lt;std::<span class="type">uint32_t</span>&gt;(message[offset + <span class="number">4</span> * i + <span class="number">1</span>]) &lt;&lt; <span class="number">16</span>) |</span><br><span class="line">                   (<span class="built_in">static_cast</span>&lt;std::<span class="type">uint32_t</span>&gt;(message[offset + <span class="number">4</span> * i + <span class="number">2</span>]) &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">                   (<span class="built_in">static_cast</span>&lt;std::<span class="type">uint32_t</span>&gt;(message[offset + <span class="number">4</span> * i + <span class="number">3</span>]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 扩展16个字为64个字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">16</span>; i &lt; <span class="number">64</span>; ++i) &#123;</span><br><span class="line">            std::<span class="type">uint32_t</span> s0 = <span class="built_in">rotor</span>(w[i - <span class="number">15</span>], <span class="number">7</span>) ^ <span class="built_in">rotor</span>(w[i - <span class="number">15</span>], <span class="number">18</span>) ^ (w[i - <span class="number">15</span>] &gt;&gt; <span class="number">3</span>);</span><br><span class="line">            std::<span class="type">uint32_t</span> s1 = <span class="built_in">rotor</span>(w[i - <span class="number">2</span>], <span class="number">17</span>) ^ <span class="built_in">rotor</span>(w[i - <span class="number">2</span>], <span class="number">19</span>) ^ (w[i - <span class="number">2</span>] &gt;&gt; <span class="number">10</span>);</span><br><span class="line">            w[i] = w[i - <span class="number">16</span>] + s0 + w[i - <span class="number">7</span>] + s1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化哈希值的工作变量</span></span><br><span class="line">        std::<span class="type">uint32_t</span> a = hash[<span class="number">0</span>];</span><br><span class="line">        std::<span class="type">uint32_t</span> b = hash[<span class="number">1</span>];</span><br><span class="line">        std::<span class="type">uint32_t</span> c = hash[<span class="number">2</span>];</span><br><span class="line">        std::<span class="type">uint32_t</span> d = hash[<span class="number">3</span>];</span><br><span class="line">        std::<span class="type">uint32_t</span> e = hash[<span class="number">4</span>];</span><br><span class="line">        std::<span class="type">uint32_t</span> f = hash[<span class="number">5</span>];</span><br><span class="line">        std::<span class="type">uint32_t</span> g = hash[<span class="number">6</span>];</span><br><span class="line">        std::<span class="type">uint32_t</span> h = hash[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主压缩函数循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; ++i) &#123;</span><br><span class="line">            std::<span class="type">uint32_t</span> s1 = <span class="built_in">rotor</span>(e, <span class="number">6</span>) ^ <span class="built_in">rotor</span>(e, <span class="number">11</span>) ^ <span class="built_in">rotor</span>(e, <span class="number">25</span>);</span><br><span class="line">            std::<span class="type">uint32_t</span> ch = (e &amp; f) ^ ((~e) &amp; g);</span><br><span class="line">            std::<span class="type">uint32_t</span> temp1 = h + s1 + ch + kSha256Constants[i] + w[i];</span><br><span class="line">            std::<span class="type">uint32_t</span> s0 = <span class="built_in">rotor</span>(a, <span class="number">2</span>) ^ <span class="built_in">rotor</span>(a, <span class="number">13</span>) ^ <span class="built_in">rotor</span>(a, <span class="number">22</span>);</span><br><span class="line">            std::<span class="type">uint32_t</span> maj = (a &amp; b) ^ (a &amp; c) ^ (b &amp; c);</span><br><span class="line">            std::<span class="type">uint32_t</span> temp2 = s0 + maj;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新工作变量</span></span><br><span class="line">            h = g;</span><br><span class="line">            g = f;</span><br><span class="line">            f = e;</span><br><span class="line">            e = d + temp1;</span><br><span class="line">            d = c;</span><br><span class="line">            c = b;</span><br><span class="line">            b = a;</span><br><span class="line">            a = temp1 + temp2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新哈希值</span></span><br><span class="line">        hash[<span class="number">0</span>] += a;</span><br><span class="line">        hash[<span class="number">1</span>] += b;</span><br><span class="line">        hash[<span class="number">2</span>] += c;</span><br><span class="line">        hash[<span class="number">3</span>] += d;</span><br><span class="line">        hash[<span class="number">4</span>] += e;</span><br><span class="line">        hash[<span class="number">5</span>] += f;</span><br><span class="line">        hash[<span class="number">6</span>] += g;</span><br><span class="line">        hash[<span class="number">7</span>] += h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将最终的哈希值转换为32字节的字符串</span></span><br><span class="line">    std::string result;</span><br><span class="line">    result.<span class="built_in">reserve</span>(<span class="number">32</span>);</span><br><span class="line">    <span class="keyword">for</span> (std::<span class="type">uint32_t</span> part : hash) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> shift = <span class="number">24</span>; shift &gt;= <span class="number">0</span>; shift -= <span class="number">8</span>) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;((part &gt;&gt; shift) &amp; <span class="number">0xFF</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用哈希函数实现签名：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HMAC-SHA256 签名算法实现</span></span><br><span class="line"><span class="comment"> * HMAC (Hash-based Message Authentication Code) 是一种基于哈希的消息认证码算法</span></span><br><span class="line"><span class="comment"> * 此函数使用SHA-256作为哈希函数实现HMAC签名</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param data 要签名的原始数据</span></span><br><span class="line"><span class="comment"> * @param key 用于签名的密钥</span></span><br><span class="line"><span class="comment"> * @return 返回HMAC-SHA256签名结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">std::string <span class="title">JWT::hmacSha256</span><span class="params">(<span class="type">const</span> std::string&amp; data, <span class="type">const</span> std::string&amp; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> std::<span class="type">size_t</span> blockSize = <span class="number">64</span>;</span><br><span class="line">    std::string actualKey = key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理密钥</span></span><br><span class="line">    <span class="keyword">if</span> (actualKey.<span class="built_in">size</span>() &gt; blockSize) &#123;</span><br><span class="line">        actualKey = <span class="built_in">sha256</span>(actualKey);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (actualKey.<span class="built_in">size</span>() &lt; blockSize) &#123;</span><br><span class="line">        actualKey.<span class="built_in">append</span>(blockSize - actualKey.<span class="built_in">size</span>(), <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建填充密钥</span></span><br><span class="line">    <span class="function">std::string <span class="title">oKeyPad</span><span class="params">(blockSize, <span class="string">&#x27;\0&#x27;</span>)</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">iKeyPad</span><span class="params">(blockSize, <span class="string">&#x27;\0&#x27;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; blockSize; ++i) &#123;</span><br><span class="line">        oKeyPad[i] = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(actualKey[i] ^ <span class="number">0x5c</span>);</span><br><span class="line">        iKeyPad[i] = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(actualKey[i] ^ <span class="number">0x36</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算内部哈希：iKeyPad + data</span></span><br><span class="line">    std::string innerData = iKeyPad + data;</span><br><span class="line">    std::string innerHash = <span class="built_in">sha256</span>(innerData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算最终哈希：oKeyPad + innerHash</span></span><br><span class="line">    std::string outerData = oKeyPad + innerHash;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sha256</span>(outerData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要给JWT设置标准头表明其类型和哈希算法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建JWT头部信息</span></span><br><span class="line"><span class="comment"> * @return 返回包含算法和类型的标准JWT头部字符串</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 该函数返回一个固定的JWT头部字符串，使用HS256算法作为签名算法，</span></span><br><span class="line"><span class="comment"> * 并指定令牌类型为JWT(JSON Web Token)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">std::string <span class="title">JWT::buildHeader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用静态常量存储标准JWT头部字符串</span></span><br><span class="line">    <span class="comment">// 内容为JSON格式，包含算法(alg)和类型(typ)字段</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> std::string header = <span class="string">R&quot;(&#123;&quot;alg&quot;:&quot;HS256&quot;,&quot;typ&quot;:&quot;JWT&quot;&#125;)&quot;</span>;</span><br><span class="line">    <span class="comment">// 返回预定义的JWT头部</span></span><br><span class="line">    <span class="keyword">return</span> header;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3，payload部分">3，payload部分</h4>
<p>payload部分是JWT的主体，用于存放用户信息，一般包括以下字段：</p>
<ul>
<li>iss (issuer)：签发人</li>
<li>sub (subject)：主题</li>
<li>aud (audience)：受众</li>
<li>exp (expiration time)：过期时间</li>
<li>nbf (not before)：生效时间</li>
<li>iat (issued at)：签发时间</li>
<li>jti (JWT ID)：编号</li>
</ul>
<p>通俗来讲，就是把字典（json）改成字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 构建JWT的payload部分（使用JsonValue优化）</span></span><br><span class="line"><span class="comment"> * 先构造JsonValue对象，再序列化为JSON字符串，避免手动拼接错误</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">std::string <span class="title">JWT::buildPayload</span><span class="params">(<span class="type">const</span> std::map&lt;std::string, std::string&gt;&amp; customClaims,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">long</span> <span class="type">long</span> issuedAt,</span></span></span><br><span class="line"><span class="params"><span class="function">                              std::optional&lt;<span class="type">long</span> <span class="type">long</span>&gt; expiresAt)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一步：构造JsonValue对象（JSON对象类型）</span></span><br><span class="line">    std::map&lt;std::string, JsonValue&gt; payloadMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加标准声明：iat（签发时间）</span></span><br><span class="line">    payloadMap.<span class="built_in">emplace</span>(<span class="string">&quot;iat&quot;</span>, <span class="built_in">JsonValue</span>(<span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(issuedAt)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加可选标准声明：exp（过期时间）</span></span><br><span class="line">    <span class="keyword">if</span> (expiresAt.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">        payloadMap.<span class="built_in">emplace</span>(<span class="string">&quot;exp&quot;</span>, <span class="built_in">JsonValue</span>(<span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(expiresAt.<span class="built_in">value</span>())));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加自定义声明（自动处理字符串转义）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [key, value] : customClaims) &#123;</span><br><span class="line">        <span class="comment">// 直接使用JsonValue的字符串构造，转义逻辑由JsonValue::escapeJsonString自动处理</span></span><br><span class="line">        payloadMap.<span class="built_in">emplace</span>(key, <span class="built_in">JsonValue</span>(value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步：使用JsonValue序列化为标准JSON字符串</span></span><br><span class="line">    <span class="function">JsonValue <span class="title">payloadValue</span><span class="params">(payloadMap)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> payloadValue.<span class="built_in">toJson</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：JsonValue是自定义的json类，用于序列化和反序列化json字符串,后面会讲到。</p>
<h4 id="4，总体流程">4，总体流程</h4>
<p>这样，生成token的整体流程如下</p>
<p>获取头部<br>
获取过期时间<br>
获取payload<br>
获取签名<br>
拼接token</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成JWT令牌</span></span><br><span class="line"><span class="comment"> * @param customClaims 自定义声明，一个键值对映射</span></span><br><span class="line"><span class="comment"> * @param ttlSeconds 令牌有效期（秒），-1表示使用默认有效期</span></span><br><span class="line"><span class="comment"> * @return 生成的JWT令牌字符串</span></span><br><span class="line"><span class="comment"> * @throws std::runtime_error 当密钥未设置时抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">std::string <span class="title">JWT::generateToken</span><span class="params">(<span class="type">const</span> std::map&lt;std::string, std::string&gt;&amp; customClaims, <span class="type">long</span> <span class="type">long</span> ttlSeconds)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查密钥是否已设置</span></span><br><span class="line">    <span class="keyword">if</span> (secret_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="comment">//        std::cout&lt;&lt;&quot;empty&quot;&lt;&lt;std::endl;</span></span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;JWT secret is not set&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建并编码JWT头部</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> header = <span class="built_in">buildHeader</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> headerEncoded = <span class="built_in">base64UrlEncode</span>(header);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前时间戳（秒）</span></span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> issuedAt = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::seconds&gt;(now.<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理令牌有效期</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> effectiveTTL = ttlSeconds;</span><br><span class="line">    <span class="keyword">if</span> (effectiveTTL &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        effectiveTTL = defaultTTL_;  <span class="comment">// 使用默认有效期</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::optional&lt;<span class="type">long</span> <span class="type">long</span>&gt; expiresAt;</span><br><span class="line">    <span class="keyword">if</span> (effectiveTTL &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        expiresAt = issuedAt + effectiveTTL;  <span class="comment">// 计算过期时间戳</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建并编码JWT载荷</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> payload = <span class="built_in">buildPayload</span>(customClaims, issuedAt, expiresAt);</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> payloadEncoded = <span class="built_in">base64UrlEncode</span>(payload);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建签名输入并生成签名</span></span><br><span class="line">    <span class="type">const</span> std::string signingInput = headerEncoded + <span class="string">&quot;.&quot;</span> + payloadEncoded;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> signature = <span class="built_in">base64UrlEncode</span>(<span class="built_in">hmacSha256</span>(signingInput, secret_));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组合头部、载荷和签名，返回完整的JWT令牌</span></span><br><span class="line">    <span class="keyword">return</span> signingInput + <span class="string">&quot;.&quot;</span> + signature;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查token是否过期</p>
<p>先按照&quot;.&quot;分割，获取payload部分，然后解析payload部分，获取过期时间，然后和当前时间比较，如果当前时间大于过期时间，则过期。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将JWT令牌字符串按照点号(.)分割成多个部分</span></span><br><span class="line"><span class="comment"> * @param token 完整的JWT令牌字符串</span></span><br><span class="line"><span class="comment"> * @return std::vector&lt;std::string&gt; 分割后的令牌部分数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">std::vector&lt;std::string&gt; <span class="title">JWT::splitToken</span><span class="params">(<span class="type">const</span> std::string&amp; token)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::string&gt; parts;  <span class="comment">// 用于存储分割后的令牌部分</span></span><br><span class="line">    std::<span class="type">size_t</span> start = <span class="number">0</span>;  <span class="comment">// 当前查找的起始位置</span></span><br><span class="line">    <span class="comment">// 遍历令牌字符串，查找点号(.)作为分割点</span></span><br><span class="line">    <span class="keyword">while</span> (start &lt;= token.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> pos = token.<span class="built_in">find</span>(<span class="string">&#x27;.&#x27;</span>, start);  <span class="comment">// 查找下一个点号的位置</span></span><br><span class="line">        <span class="comment">// 如果找不到点号，将剩余部分添加到结果中并结束循环</span></span><br><span class="line">        <span class="keyword">if</span> (pos == std::string::npos) &#123;</span><br><span class="line">            parts.<span class="built_in">emplace_back</span>(token.<span class="built_in">substr</span>(start));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加当前部分到结果中</span></span><br><span class="line">        parts.<span class="built_in">emplace_back</span>(token.<span class="built_in">substr</span>(start, pos - start));</span><br><span class="line">        start = pos + <span class="number">1</span>;  <span class="comment">// 更新查找起始位置为点号之后的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parts;  <span class="comment">// 返回分割后的令牌部分数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证JWT令牌的有效性</span></span><br><span class="line"><span class="comment"> * @param token 待验证的JWT令牌字符串</span></span><br><span class="line"><span class="comment"> * @param payloadJson 用于存储载荷JSON字符串的输出参数，可为nullptr</span></span><br><span class="line"><span class="comment"> * @return 验证成功返回true，失败返回false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">JWT::verifyToken</span><span class="params">(<span class="type">const</span> std::string&amp; token, std::string* payloadJson)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查密钥是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (secret_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分割令牌为三部分（头部、载荷、签名）</span></span><br><span class="line">    <span class="comment">// Split token into three parts (header, payload, signature)</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> parts = <span class="built_in">splitToken</span>(token);</span><br><span class="line">    <span class="comment">// 检查令牌是否由三部分组成</span></span><br><span class="line">    <span class="keyword">if</span> (parts.<span class="built_in">size</span>() != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造待签名的字符串（头部+载荷）</span></span><br><span class="line">    <span class="type">const</span> std::string signingInput = parts[<span class="number">0</span>] + <span class="string">&quot;.&quot;</span> + parts[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 计算期望的签名</span></span><br><span class="line">    <span class="type">const</span> std::string expectedSignature = <span class="built_in">base64UrlEncode</span>(<span class="built_in">hmacSha256</span>(signingInput, secret_));</span><br><span class="line">    <span class="comment">// 验证签名是否匹配</span></span><br><span class="line">    <span class="keyword">if</span> (expectedSignature != parts[<span class="number">2</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解码载荷部分</span></span><br><span class="line">    <span class="type">const</span> std::string payload = <span class="built_in">base64UrlDecode</span>(parts[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查过期时间(exp)声明</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> expClaim = <span class="built_in">extractNumericClaim</span>(payload, <span class="string">&quot;exp&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (expClaim.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">        <span class="comment">// 获取当前时间戳</span></span><br><span class="line">        <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">        <span class="keyword">auto</span> current = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::seconds&gt;(now.<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br><span class="line">        <span class="comment">// 检查是否过期</span></span><br><span class="line">        <span class="keyword">if</span> (current &gt; expClaim.<span class="built_in">value</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果提供了payloadJson参数，则将载荷JSON字符串存入</span></span><br><span class="line">    <span class="keyword">if</span> (payloadJson != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        *payloadJson = payload;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析 Claim</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 解析JSON对象字符串为键值对映射（使用JsonValue优化）</span></span><br><span class="line"><span class="comment"> * 利用JsonValue的完整解析能力，自动处理转义字符、嵌套检查、语法验证</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">std::map&lt;std::string, std::string&gt; <span class="title">JWT::parseJsonObject</span><span class="params">(<span class="type">const</span> std::string&amp; json)</span> </span>&#123;</span><br><span class="line">    std::map&lt;std::string, std::string&gt; result;</span><br><span class="line">    JsonValue jsonValue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        jsonValue.<span class="built_in">fromJson</span>(json);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;JSON parse failed: &quot;</span> + std::<span class="built_in">string</span>(e.<span class="built_in">what</span>()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步：检查解析结果是否为JSON对象类型</span></span><br><span class="line">    <span class="keyword">if</span> (jsonValue.<span class="built_in">getType</span>() != JsonValue::OBJECT) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Invalid JSON: not an object&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三步：提取对象中的所有键值对，转换为string-string映射</span></span><br><span class="line">    <span class="keyword">auto</span> jsonObject = jsonValue.<span class="built_in">asObject</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [key, value] : jsonObject) &#123;</span><br><span class="line">        <span class="comment">// 提取值并确保为string类型（非string类型会自动转为对应字符串形式）</span></span><br><span class="line">        <span class="keyword">switch</span> (value.<span class="built_in">getType</span>()) &#123;</span><br><span class="line">            <span class="keyword">case</span> JsonValue::STRING:</span><br><span class="line">                result.<span class="built_in">emplace</span>(key, value.<span class="built_in">asString</span>());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> JsonValue::NUMBER:</span><br><span class="line">                <span class="comment">// 数字类型转为string（保持原始数值格式）</span></span><br><span class="line">                result.<span class="built_in">emplace</span>(key, value.<span class="built_in">toJson</span>());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> JsonValue::BOOLEAN:</span><br><span class="line">                <span class="comment">// 布尔类型转为&quot;true&quot;/&quot;false&quot;字符串</span></span><br><span class="line">                result.<span class="built_in">emplace</span>(key, value.<span class="built_in">toJson</span>());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> JsonValue::NULL_TYPE:</span><br><span class="line">                <span class="comment">// null类型转为&quot;null&quot;字符串</span></span><br><span class="line">                result.<span class="built_in">emplace</span>(key, <span class="string">&quot;null&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// 不支持对象/数组作为值（如需支持可扩展）</span></span><br><span class="line">                <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Unsupported value type for key: &quot;</span> + key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 解析JWT令牌中的声明（claims）部分</span></span><br><span class="line"><span class="comment"> * @param token 要解析的JWT令牌字符串</span></span><br><span class="line"><span class="comment"> * @return 返回一个包含字符串映射的std::optional对象，如果解析失败则返回std::nullopt</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">std::optional&lt;std::map&lt;std::string, std::string&gt;&gt; JWT::<span class="built_in">parseClaims</span>(<span class="type">const</span> std::string&amp; token) <span class="type">const</span> &#123;</span><br><span class="line">    std::string payload; <span class="comment">// 用于存储令牌的payload部分</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">verifyToken</span>(token, &amp;payload)) &#123; <span class="comment">// 验证令牌有效性，如果验证失败</span></span><br><span class="line">        <span class="keyword">return</span> std::<span class="literal">nullopt</span>; <span class="comment">// 返回空值表示解析失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">parseJsonObject</span>(payload); <span class="comment">// 尝试解析payload为JSON对象</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp;) &#123; <span class="comment">// 捕获解析过程中可能出现的异常</span></span><br><span class="line">        <span class="keyword">return</span> std::<span class="literal">nullopt</span>; <span class="comment">// 如果解析失败，返回空值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时我在其中顺便实现密码哈希</p>
<p>密码哈希流程</p>
<ul>
<li>生成盐值（salt）</li>
<li>将盐值与密码进行哈希运算</li>
<li>转成16进制字符串</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 生成加密安全的盐值</span></span><br><span class="line"><span class="comment"> * 生成 16 字节（128 位）加密安全随机数，编码为 32 字符十六进制字符串</span></span><br><span class="line"><span class="comment"> * 满足密码学安全要求，跨平台兼容，生成的盐值可直接存储/传输</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">std::string <span class="title">JWT::generate_salt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> salt_length = <span class="number">16</span>; <span class="comment">// 16 字节 = 128 位，足够密码学安全</span></span><br><span class="line">    <span class="function">std::string <span class="title">salt_bytes</span><span class="params">(salt_length, <span class="number">0x00</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 初始化加密安全随机数生成器</span></span><br><span class="line">        std::random_device rd;</span><br><span class="line">        <span class="comment">// 双重种子：random_device + 当前时间戳，增强随机性（应对 rd 伪随机的情况）</span></span><br><span class="line">        <span class="type">uint64_t</span> seed = <span class="built_in">rd</span>() ^ <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(std::chrono::high_resolution_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>());</span><br><span class="line">        <span class="function">std::mt19937_64 <span class="title">gen</span><span class="params">(seed)</span></span>; <span class="comment">// 64 位 Mersenne Twister 生成器，适合加密场景</span></span><br><span class="line">        <span class="function">std::uniform_int_distribution&lt;<span class="type">uint8_t</span>&gt; <span class="title">dist</span><span class="params">(<span class="number">0x00</span>, <span class="number">0xFF</span>)</span></span>; <span class="comment">// 生成 0-255 的均匀分布随机字节</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 生成 16 字节随机数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; byte : salt_bytes) &#123;</span><br><span class="line">            byte = <span class="built_in">dist</span>(gen);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 转为十六进制字符串（可打印、易存储）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bytes_to_hex</span>(salt_bytes);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to generate salt: &quot;</span> + std::<span class="built_in">string</span>(e.<span class="built_in">what</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 补充：十六进制字符串转字节数组（解析盐值和哈希时需要）</span></span><br><span class="line"><span class="function">std::string <span class="title">JWT::hex_to_bytes</span><span class="params">(<span class="type">const</span> std::string&amp; hex)</span> </span>&#123;</span><br><span class="line">    std::string bytes;</span><br><span class="line">    <span class="keyword">if</span> (hex.<span class="built_in">size</span>() % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> bytes; <span class="comment">// 无效的十六进制字符串（长度为奇数）</span></span><br><span class="line">    &#125;</span><br><span class="line">    bytes.<span class="built_in">reserve</span>(hex.<span class="built_in">size</span>() / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; hex.<span class="built_in">size</span>(); i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 解析每两个字符为一个字节（16进制）</span></span><br><span class="line">        std::string byte_str = hex.<span class="built_in">substr</span>(i, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">auto</span> byte = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(std::<span class="built_in">stoul</span>(byte_str, <span class="literal">nullptr</span>, <span class="number">16</span>));</span><br><span class="line">        bytes.<span class="built_in">push_back</span>(byte);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量时间比较（防时序攻击）：无论内容是否相同，比较时间一致</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">JWT::constant_time_compare</span><span class="params">(<span class="type">const</span> std::string &amp; a, <span class="type">const</span> std::string &amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">size</span>() != b.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;长度不同&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 长度不同直接返回false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> diff = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="comment">// 异或：若字节不同则结果非0，累积到diff中</span></span><br><span class="line">        diff |= (a[i] ^ b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> diff == <span class="number">0</span>; <span class="comment">// 只有所有字节都相同，diff才为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 安全的密码加密：使用PBKDF2-HMAC-SHA256</span></span><br><span class="line"><span class="comment">     * @param password 明文密码</span></span><br><span class="line"><span class="comment">     * @return 存储格式：salt(hex):iterations:hash(hex)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function">std::string <span class="title">JWT::encrypt_password</span><span class="params">(<span class="type">const</span> std::string&amp; password)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> iterations = <span class="number">100000</span>; <span class="comment">// 迭代次数（可根据性能调整）</span></span><br><span class="line">    std::string salt = <span class="built_in">generate_salt</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// PBKDF2核心：多次迭代HMAC-SHA256</span></span><br><span class="line">    <span class="function">std::string <span class="title">dk</span><span class="params">(<span class="number">32</span>, <span class="number">0x00</span>)</span></span>; <span class="comment">// 输出32字节哈希</span></span><br><span class="line">    std::string U, <span class="built_in">T</span>(<span class="number">32</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt;= <span class="number">1</span>; ++i) &#123; <span class="comment">// 只需要1个块（32字节）</span></span><br><span class="line">        <span class="comment">// 盐值 + 4字节大端序号（i=1）</span></span><br><span class="line">        std::string salt_i = salt;</span><br><span class="line">        salt_i.<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;((i &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>));</span><br><span class="line">        salt_i.<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;((i &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>));</span><br><span class="line">        salt_i.<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;((i &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>));</span><br><span class="line">        salt_i.<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(i &amp; <span class="number">0xFF</span>));</span><br><span class="line"></span><br><span class="line">        U = <span class="built_in">hmacSha256</span>(password, salt_i);</span><br><span class="line">        T = U;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">1</span>; j &lt; iterations; ++j) &#123;</span><br><span class="line">            U = <span class="built_in">hmacSha256</span>(password, U);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> k = <span class="number">0</span>; k &lt; <span class="number">32</span>; ++k) &#123;</span><br><span class="line">                T[k] ^= U[k]; <span class="comment">// 异或累积</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dk = T;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes_to_hex</span>(salt) + <span class="string">&quot;:&quot;</span> + std::<span class="built_in">to_string</span>(iterations) + <span class="string">&quot;:&quot;</span> + <span class="built_in">bytes_to_hex</span>(dk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>验证密码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 密码验证</span></span><br><span class="line"><span class="comment"> * @param password 明文密码</span></span><br><span class="line"><span class="comment"> * @param stored_hash 加密后存储的字符串（格式：salt_hex:iterations:hash_hex）</span></span><br><span class="line"><span class="comment"> * @return 是否验证通过</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">JWT::verify_password</span><span class="params">(<span class="type">const</span> std::string&amp; password, <span class="type">const</span> std::string&amp; stored_hash)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 解析存储的哈希字符串（格式：salt_hex:iterations:hash_hex）</span></span><br><span class="line">    <span class="type">size_t</span> colon1 = stored_hash.<span class="built_in">find</span>(<span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">    <span class="type">size_t</span> colon2 = stored_hash.<span class="built_in">find</span>(<span class="string">&#x27;:&#x27;</span>, colon1 + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (colon1 == std::string::npos || colon2 == std::string::npos) &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;格式错误&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 格式错误</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取盐值（十六进制）、迭代次数、存储的哈希（十六进制）</span></span><br><span class="line">    std::string salt_hex = stored_hash.<span class="built_in">substr</span>(<span class="number">0</span>, colon1);</span><br><span class="line">    std::string iterations_str = stored_hash.<span class="built_in">substr</span>(colon1 + <span class="number">1</span>, colon2 - colon1 - <span class="number">1</span>);</span><br><span class="line">    std::string stored_hash_hex = stored_hash.<span class="built_in">substr</span>(colon2 + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 转换盐值和存储的哈希为字节数组</span></span><br><span class="line">    std::string salt = <span class="built_in">hex_to_bytes</span>(salt_hex);</span><br><span class="line">    std::string expected_hash = <span class="built_in">hex_to_bytes</span>(stored_hash_hex);</span><br><span class="line">    <span class="keyword">if</span> (salt.<span class="built_in">empty</span>() || expected_hash.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;无效的十六进制&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 解析失败（无效的十六进制）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 解析迭代次数（确保为正整数）</span></span><br><span class="line">    <span class="type">size_t</span> iterations;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        iterations = std::<span class="built_in">stoul</span>(iterations_str);</span><br><span class="line">        <span class="keyword">if</span> (iterations == <span class="number">0</span>) &#123;</span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;迭代次数不能为0&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 迭代次数不能为0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;转换失败（非数字）&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 转换失败（非数字）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 用相同的盐值和迭代次数重新计算哈希</span></span><br><span class="line">    <span class="function">std::string <span class="title">computed_hash</span><span class="params">(<span class="number">32</span>, <span class="number">0x00</span>)</span></span>; <span class="comment">// 输出32字节（SHA-256长度）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复用PBKDF2-HMAC-SHA256逻辑（与加密时一致）</span></span><br><span class="line">    std::string U, <span class="built_in">T</span>(<span class="number">32</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt;= <span class="number">1</span>; ++i) &#123; <span class="comment">// 1个块（32字节）</span></span><br><span class="line">        std::string salt_i = salt;</span><br><span class="line">        <span class="comment">// 添加4字节大端序号（与加密时一致，i=1）</span></span><br><span class="line">        salt_i.<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;((i &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>));</span><br><span class="line">        salt_i.<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;((i &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>));</span><br><span class="line">        salt_i.<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;((i &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>));</span><br><span class="line">        salt_i.<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(i &amp; <span class="number">0xFF</span>));</span><br><span class="line"></span><br><span class="line">        U = <span class="built_in">hmacSha256</span>(password, salt_i);</span><br><span class="line">        T = U;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">1</span>; j &lt; iterations; ++j) &#123;</span><br><span class="line">            U = <span class="built_in">hmacSha256</span>(password, U);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> k = <span class="number">0</span>; k &lt; <span class="number">32</span>; ++k) &#123;</span><br><span class="line">                T[k] ^= U[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        computed_hash = T;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 常量时间比较计算出的哈希与存储的哈希</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">constant_time_compare</span>(computed_hash, expected_hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2，JsonValue-类">2，JsonValue 类</h3>
<p>在网络得到信息，大部分是json格式，需要解析json，使用JsonValue类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by HP on 2025/11/5.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CBSF_JSONVALUE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CBSF_JSONVALUE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief JSON值类型类，支持嵌套结构的JSON数据</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 该类提供了完整的JSON值表示，支持以下类型：</span></span><br><span class="line"><span class="comment"> * - NULL_TYPE: null值</span></span><br><span class="line"><span class="comment"> * - STRING: 字符串值</span></span><br><span class="line"><span class="comment"> * - NUMBER: 数字值（整数或浮点数）</span></span><br><span class="line"><span class="comment"> * - BOOLEAN: 布尔值</span></span><br><span class="line"><span class="comment"> * - OBJECT: 对象（键值对映射）</span></span><br><span class="line"><span class="comment"> * - ARRAY: 数组</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @brief JSON value type class that supports nested structured JSON data</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * This class provides complete JSON value representation, supporting the following types:</span></span><br><span class="line"><span class="comment"> * - NULL_TYPE: null value</span></span><br><span class="line"><span class="comment"> * - STRING: string value</span></span><br><span class="line"><span class="comment"> * - NUMBER: numeric value (integer or floating point)</span></span><br><span class="line"><span class="comment"> * - BOOLEAN: boolean value</span></span><br><span class="line"><span class="comment"> * - OBJECT: object (key-value pair mapping)</span></span><br><span class="line"><span class="comment"> * - ARRAY: array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JsonValue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief JSON值类型枚举</span></span><br><span class="line"><span class="comment">     * @brief JSON value type enumeration</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Type</span> &#123;</span><br><span class="line">        NULL_TYPE,  <span class="comment">///&lt; null类型 (null type)</span></span><br><span class="line">        STRING,     <span class="comment">///&lt; 字符串类型 (string type)</span></span><br><span class="line">        NUMBER,     <span class="comment">///&lt; 数字类型 (numeric type)</span></span><br><span class="line">        BOOLEAN,    <span class="comment">///&lt; 布尔类型 (boolean type)</span></span><br><span class="line">        OBJECT,     <span class="comment">///&lt; 对象类型 (object type)</span></span><br><span class="line">        ARRAY       <span class="comment">///&lt; 数组类型 (array type)</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 默认构造函数，创建null值</span></span><br><span class="line"><span class="comment">     * @brief Default constructor, creates a null value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">JsonValue</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 从字符串构造JsonValue</span></span><br><span class="line"><span class="comment">     * @param value 字符串值</span></span><br><span class="line"><span class="comment">     * @brief Construct JsonValue from string</span></span><br><span class="line"><span class="comment">     * @param value String value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">JsonValue</span><span class="params">(std::string  value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 从C风格字符串构造JsonValue</span></span><br><span class="line"><span class="comment">     * @param value C风格字符串</span></span><br><span class="line"><span class="comment">     * @brief Construct JsonValue from C-style string</span></span><br><span class="line"><span class="comment">     * @param value C-style string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">JsonValue</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 从整数构造JsonValue</span></span><br><span class="line"><span class="comment">     * @param value 整数值</span></span><br><span class="line"><span class="comment">     * @brief Construct JsonValue from integer</span></span><br><span class="line"><span class="comment">     * @param value Integer value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">JsonValue</span><span class="params">(<span class="type">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 从浮点数构造JsonValue</span></span><br><span class="line"><span class="comment">     * @param value 浮点数值</span></span><br><span class="line"><span class="comment">     * @brief Construct JsonValue from floating-point number</span></span><br><span class="line"><span class="comment">     * @param value Floating-point value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">JsonValue</span><span class="params">(<span class="type">double</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 从布尔值构造JsonValue</span></span><br><span class="line"><span class="comment">     * @param value 布尔值</span></span><br><span class="line"><span class="comment">     * @brief Construct JsonValue from boolean</span></span><br><span class="line"><span class="comment">     * @param value Boolean value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">JsonValue</span><span class="params">(<span class="type">bool</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 从对象映射构造JsonValue</span></span><br><span class="line"><span class="comment">     * @param value 对象映射</span></span><br><span class="line"><span class="comment">     * @brief Construct JsonValue from object map</span></span><br><span class="line"><span class="comment">     * @param value Object map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">JsonValue</span><span class="params">(<span class="type">const</span> std::map&lt;std::string, JsonValue&gt;&amp; value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 从JsonValue数组构造JsonValue</span></span><br><span class="line"><span class="comment">     * @param value JsonValue数组</span></span><br><span class="line"><span class="comment">     * @brief Construct JsonValue from JsonValue array</span></span><br><span class="line"><span class="comment">     * @param value JsonValue array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">JsonValue</span><span class="params">(<span class="type">const</span> std::vector&lt;JsonValue&gt;&amp; value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 从map数组构造JsonValue</span></span><br><span class="line"><span class="comment">     * @param value map数组</span></span><br><span class="line"><span class="comment">     * @brief Construct JsonValue from map array</span></span><br><span class="line"><span class="comment">     * @param value Map array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">JsonValue</span><span class="params">(<span class="type">const</span> std::vector&lt;std::map&lt;std::string, std::string&gt;&gt;&amp; value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 从字符串数组构造JsonValue</span></span><br><span class="line"><span class="comment">     * @param value 字符串数组</span></span><br><span class="line"><span class="comment">     * @brief Construct JsonValue from string array</span></span><br><span class="line"><span class="comment">     * @param value String array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">JsonValue</span><span class="params">(<span class="type">const</span> std::vector&lt;std::string&gt;&amp; value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取值的类型</span></span><br><span class="line"><span class="comment">     * @return 值的类型</span></span><br><span class="line"><span class="comment">     * @brief Get the type of the value</span></span><br><span class="line"><span class="comment">     * @return The type of the value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    [[nodiscard]] <span class="function">Type <span class="title">getType</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> type_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取字符串值</span></span><br><span class="line"><span class="comment">     * @return 字符串值，如果类型不是STRING则返回空字符串</span></span><br><span class="line"><span class="comment">     * @brief Get string value</span></span><br><span class="line"><span class="comment">     * @return String value, returns empty string if type is not STRING</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    [[nodiscard]] <span class="function">std::string <span class="title">asString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取数字值</span></span><br><span class="line"><span class="comment">     * @return 数字值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    [[nodiscard]] <span class="function"><span class="type">double</span> <span class="title">asNumber</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取布尔值</span></span><br><span class="line"><span class="comment">     * @return 布尔值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    [[nodiscard]] <span class="function"><span class="type">bool</span> <span class="title">asBoolean</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取对象值</span></span><br><span class="line"><span class="comment">     * @return 对象映射</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    [[nodiscard]] <span class="function">std::map&lt;std::string, JsonValue&gt; <span class="title">asObject</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取数组值</span></span><br><span class="line"><span class="comment">     * @return JsonValue数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    [[nodiscard]] <span class="function">std::vector&lt;JsonValue&gt; <span class="title">asArray</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 转换为JSON字符串</span></span><br><span class="line"><span class="comment">     * @return JSON格式的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    [[nodiscard]] <span class="function">std::string <span class="title">toJson</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * @brief 从JSON字符串解析并填充对象属性</span></span><br><span class="line"><span class="comment">    * @param jsonStr 输入的JSON格式字符串，用于解析并填充对象的属性</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fromJson</span><span class="params">(<span class="type">const</span> std::string&amp; jsonStr)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 静态方法：创建对象</span></span><br><span class="line"><span class="comment">     * @param obj 对象映射</span></span><br><span class="line"><span class="comment">     * @return JsonValue对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">static</span> JsonValue <span class="title">object</span><span class="params">(<span class="type">const</span> std::map&lt;std::string, JsonValue&gt;&amp; obj)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 静态方法：创建数组</span></span><br><span class="line"><span class="comment">     * @param arr JsonValue数组</span></span><br><span class="line"><span class="comment">     * @return JsonValue对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">static</span> JsonValue <span class="title">array</span><span class="params">(<span class="type">const</span> std::vector&lt;JsonValue&gt;&amp; arr)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助函数：解析字符串（处理转义字符）</span></span><br><span class="line">    <span class="function"><span class="type">static</span> std::string <span class="title">parseString</span><span class="params">(<span class="type">const</span> std::string&amp; jsonStr, <span class="type">size_t</span>&amp; pos)</span> </span>&#123;</span><br><span class="line">        pos++; <span class="comment">// 跳过开头的 &quot;</span></span><br><span class="line">        std::string result;</span><br><span class="line">        <span class="keyword">while</span> (pos &lt; jsonStr.<span class="built_in">size</span>() &amp;&amp; jsonStr[pos] != <span class="string">&#x27;&quot;&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (jsonStr[pos] == <span class="string">&#x27;\\&#x27;</span>) &#123; <span class="comment">// 处理转义字符</span></span><br><span class="line">                pos++;</span><br><span class="line">                <span class="keyword">if</span> (pos &gt;= jsonStr.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Invalid JSON string: unexpected end after escape&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">switch</span> (jsonStr[pos]) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;&quot;&#x27;</span>: result += <span class="string">&#x27;&quot;&#x27;</span>; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;\\&#x27;</span>: result += <span class="string">&#x27;\\&#x27;</span>; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: result += <span class="string">&#x27;/&#x27;</span>; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>: result += <span class="string">&#x27;\b&#x27;</span>; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>: result += <span class="string">&#x27;\f&#x27;</span>; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>: result += <span class="string">&#x27;\n&#x27;</span>; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>: result += <span class="string">&#x27;\r&#x27;</span>; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>: result += <span class="string">&#x27;\t&#x27;</span>; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>: <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Invalid escape character in JSON string&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result += jsonStr[pos];</span><br><span class="line">            &#125;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pos &gt;= jsonStr.<span class="built_in">size</span>() || jsonStr[pos] != <span class="string">&#x27;&quot;&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Invalid JSON string: missing closing quote&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pos++; <span class="comment">// 跳过结尾的 &quot;</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Type type_;                                    <span class="comment">///&lt; 值的类型</span></span><br><span class="line">    std::string stringValue_;                     <span class="comment">///&lt; 字符串值</span></span><br><span class="line">    <span class="type">double</span> numberValue_;                          <span class="comment">///&lt; 数字值</span></span><br><span class="line">    <span class="type">bool</span> boolValue_;                              <span class="comment">///&lt; 布尔值</span></span><br><span class="line">    std::map&lt;std::string, JsonValue&gt; objectValue_; <span class="comment">///&lt; 对象值</span></span><br><span class="line">    std::vector&lt;JsonValue&gt; arrayValue_;           <span class="comment">///&lt; 数组值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 转义JSON字符串中的特殊字符</span></span><br><span class="line"><span class="comment">     * @param str 原始字符串</span></span><br><span class="line"><span class="comment">     * @return 转义后的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    [[nodiscard]] <span class="function"><span class="type">static</span> std::string <span class="title">escapeJsonString</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span> </span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">skipWhitespace</span><span class="params">(<span class="type">const</span> std::string&amp; jsonStr, <span class="type">size_t</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (pos &lt; jsonStr.<span class="built_in">size</span>() &amp;&amp; std::<span class="built_in">isspace</span>(<span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt;(jsonStr[pos]))) &#123;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助函数：解析数字</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">parseNumber</span><span class="params">(<span class="type">const</span> std::string&amp; jsonStr, <span class="type">size_t</span>&amp; pos)</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> start = pos;</span><br><span class="line">        <span class="comment">// 处理负号</span></span><br><span class="line">        <span class="keyword">if</span> (jsonStr[pos] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理整数部分</span></span><br><span class="line">        <span class="keyword">while</span> (pos &lt; jsonStr.<span class="built_in">size</span>() &amp;&amp; std::<span class="built_in">isdigit</span>(<span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt;(jsonStr[pos]))) &#123;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理小数部分</span></span><br><span class="line">        <span class="keyword">if</span> (pos &lt; jsonStr.<span class="built_in">size</span>() &amp;&amp; jsonStr[pos] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            pos++;</span><br><span class="line">            <span class="keyword">while</span> (pos &lt; jsonStr.<span class="built_in">size</span>() &amp;&amp; std::<span class="built_in">isdigit</span>(<span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt;(jsonStr[pos]))) &#123;</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理指数部分</span></span><br><span class="line">        <span class="keyword">if</span> (pos &lt; jsonStr.<span class="built_in">size</span>() &amp;&amp; (jsonStr[pos] == <span class="string">&#x27;e&#x27;</span> || jsonStr[pos] == <span class="string">&#x27;E&#x27;</span>)) &#123;</span><br><span class="line">            pos++;</span><br><span class="line">            <span class="keyword">if</span> (pos &lt; jsonStr.<span class="built_in">size</span>() &amp;&amp; (jsonStr[pos] == <span class="string">&#x27;+&#x27;</span> || jsonStr[pos] == <span class="string">&#x27;-&#x27;</span>)) &#123;</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (pos &lt; jsonStr.<span class="built_in">size</span>() &amp;&amp; std::<span class="built_in">isdigit</span>(<span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt;(jsonStr[pos]))) &#123;</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 转换为double</span></span><br><span class="line">        std::string numStr = jsonStr.<span class="built_in">substr</span>(start, pos - start);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">stod</span>(numStr);</span><br><span class="line">        &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Invalid JSON number: &quot;</span> + numStr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助函数：解析布尔值</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">parseBoolean</span><span class="params">(<span class="type">const</span> std::string&amp; jsonStr, <span class="type">size_t</span>&amp; pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (jsonStr.<span class="built_in">substr</span>(pos, <span class="number">4</span>) == <span class="string">&quot;true&quot;</span>) &#123;</span><br><span class="line">            pos += <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (jsonStr.<span class="built_in">substr</span>(pos, <span class="number">5</span>) == <span class="string">&quot;false&quot;</span>) &#123;</span><br><span class="line">            pos += <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Invalid JSON boolean value&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助函数：解析null</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">parseNull</span><span class="params">(<span class="type">const</span> std::string&amp; jsonStr, <span class="type">size_t</span>&amp; pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (jsonStr.<span class="built_in">substr</span>(pos, <span class="number">4</span>) != <span class="string">&quot;null&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Invalid JSON null value&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pos += <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助函数：解析对象（键值对集合）</span></span><br><span class="line">    <span class="function"><span class="type">static</span> std::map&lt;std::string, JsonValue&gt; <span class="title">parseObject</span><span class="params">(<span class="type">const</span> std::string&amp; jsonStr, <span class="type">size_t</span>&amp; pos)</span> </span>&#123;</span><br><span class="line">        pos++; <span class="comment">// 跳过开头的 &#123;</span></span><br><span class="line">        std::map&lt;std::string, JsonValue&gt; obj;</span><br><span class="line">        pos = <span class="built_in">skipWhitespace</span>(jsonStr, pos);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (pos &lt; jsonStr.<span class="built_in">size</span>() &amp;&amp; jsonStr[pos] != <span class="string">&#x27;&#125;&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 解析键（必须是字符串）</span></span><br><span class="line">            <span class="keyword">if</span> (jsonStr[pos] != <span class="string">&#x27;&quot;&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Invalid JSON object: key must be a string&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            std::string key = <span class="built_in">parseString</span>(jsonStr, pos);</span><br><span class="line">            pos = <span class="built_in">skipWhitespace</span>(jsonStr, pos);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 解析冒号</span></span><br><span class="line">            <span class="keyword">if</span> (pos &gt;= jsonStr.<span class="built_in">size</span>() || jsonStr[pos] != <span class="string">&#x27;:&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Invalid JSON object: missing colon after key&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            pos++;</span><br><span class="line">            pos = <span class="built_in">skipWhitespace</span>(jsonStr, pos);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 解析值（递归）</span></span><br><span class="line">            JsonValue value = <span class="built_in">parseValue</span>(jsonStr, pos);</span><br><span class="line">            obj[key] = value;</span><br><span class="line">            pos = <span class="built_in">skipWhitespace</span>(jsonStr, pos);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理逗号或结束符</span></span><br><span class="line">            <span class="keyword">if</span> (pos &lt; jsonStr.<span class="built_in">size</span>() &amp;&amp; jsonStr[pos] == <span class="string">&#x27;,&#x27;</span>) &#123;</span><br><span class="line">                pos++;</span><br><span class="line">                pos = <span class="built_in">skipWhitespace</span>(jsonStr, pos);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (jsonStr[pos] != <span class="string">&#x27;&#125;&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Invalid JSON object: unexpected character&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pos &gt;= jsonStr.<span class="built_in">size</span>() || jsonStr[pos] != <span class="string">&#x27;&#125;&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Invalid JSON object: missing closing brace&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pos++; <span class="comment">// 跳过结尾的 &#125;</span></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助函数：解析数组（值列表）</span></span><br><span class="line">    <span class="function"><span class="type">static</span> std::vector&lt;JsonValue&gt; <span class="title">parseArray</span><span class="params">(<span class="type">const</span> std::string&amp; jsonStr, <span class="type">size_t</span>&amp; pos)</span> </span>&#123;</span><br><span class="line">        pos++; <span class="comment">// 跳过开头的 [</span></span><br><span class="line">        std::vector&lt;JsonValue&gt; arr;</span><br><span class="line">        pos = <span class="built_in">skipWhitespace</span>(jsonStr, pos);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (pos &lt; jsonStr.<span class="built_in">size</span>() &amp;&amp; jsonStr[pos] != <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 解析元素（递归）</span></span><br><span class="line">            JsonValue elem = <span class="built_in">parseValue</span>(jsonStr, pos);</span><br><span class="line">            arr.<span class="built_in">push_back</span>(elem);</span><br><span class="line">            pos = <span class="built_in">skipWhitespace</span>(jsonStr, pos);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理逗号或结束符</span></span><br><span class="line">            <span class="keyword">if</span> (pos &lt; jsonStr.<span class="built_in">size</span>() &amp;&amp; jsonStr[pos] == <span class="string">&#x27;,&#x27;</span>) &#123;</span><br><span class="line">                pos++;</span><br><span class="line">                pos = <span class="built_in">skipWhitespace</span>(jsonStr, pos);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (jsonStr[pos] != <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Invalid JSON array: unexpected character&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pos &gt;= jsonStr.<span class="built_in">size</span>() || jsonStr[pos] != <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Invalid JSON array: missing closing bracket&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pos++; <span class="comment">// 跳过结尾的 ]</span></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归解析JSON值</span></span><br><span class="line">    <span class="function"><span class="type">static</span> JsonValue <span class="title">parseValue</span><span class="params">(<span class="type">const</span> std::string&amp; jsonStr, <span class="type">size_t</span>&amp; pos)</span> </span>&#123;</span><br><span class="line">        pos = <span class="built_in">skipWhitespace</span>(jsonStr, pos);</span><br><span class="line">        <span class="keyword">if</span> (pos &gt;= jsonStr.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Empty JSON string&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> c = jsonStr[pos];</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&#123;&#x27;</span>: <span class="keyword">return</span> <span class="built_in">JsonValue</span>(<span class="built_in">parseObject</span>(jsonStr, pos));</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span>: <span class="keyword">return</span> <span class="built_in">JsonValue</span>(<span class="built_in">parseArray</span>(jsonStr, pos));</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&quot;&#x27;</span>: <span class="keyword">return</span> <span class="built_in">JsonValue</span>(<span class="built_in">parseString</span>(jsonStr, pos));</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>: <span class="keyword">return</span> <span class="built_in">JsonValue</span>(<span class="built_in">parseBoolean</span>(jsonStr, pos));</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>: <span class="built_in">parseNull</span>(jsonStr, pos); <span class="keyword">return</span> <span class="built_in">JsonValue</span>(); <span class="comment">// null类型</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;3&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;4&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;5&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;6&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;7&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;8&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">JsonValue</span>(<span class="built_in">parseNumber</span>(jsonStr, pos));</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Invalid JSON value: unexpected character &#x27;&quot;</span> + std::<span class="built_in">string</span>(<span class="number">1</span>, c) + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 便捷函数：将嵌套map转换为JSON字符串</span></span><br><span class="line"><span class="comment"> * @param obj 包含JsonValue的map</span></span><br><span class="line"><span class="comment"> * @return JSON格式的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">std::string <span class="title">toJson</span><span class="params">(<span class="type">const</span> std::map&lt;std::string, JsonValue&gt;&amp; obj)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 便捷函数：将vector&lt;map&gt;转换为JSON数组字符串</span></span><br><span class="line"><span class="comment"> * @param vec map数组</span></span><br><span class="line"><span class="comment"> * @return JSON数组格式的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">std::string <span class="title">toJsonArray</span><span class="params">(<span class="type">const</span> std::vector&lt;std::map&lt;std::string, std::string&gt;&gt;&amp; vec)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//CBSF_JSONVALUE_H</span></span></span><br></pre></td></tr></table></figure>
<p>这个类的递归含量比较高，关键方法是 toJson和fromJson</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">JsonValue::toJson</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (type_) &#123;</span><br><span class="line">        <span class="keyword">case</span> NULL_TYPE:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;null&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> STRING:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;\&quot;&quot;</span> + <span class="built_in">escapeJsonString</span>(stringValue_) + <span class="string">&quot;\&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> NUMBER:</span><br><span class="line">            <span class="comment">// 如果是整数，不显示小数点</span></span><br><span class="line">            <span class="keyword">if</span> (numberValue_ == <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(numberValue_)) &#123;</span><br><span class="line">                <span class="keyword">return</span> std::<span class="built_in">to_string</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(numberValue_));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">to_string</span>(numberValue_);</span><br><span class="line">        <span class="keyword">case</span> BOOLEAN:</span><br><span class="line">            <span class="keyword">return</span> boolValue_ ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJECT: &#123;</span><br><span class="line">            std::string json = <span class="string">&quot;&#123;&quot;</span>;</span><br><span class="line">            <span class="type">bool</span> first = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : objectValue_) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!first) json += <span class="string">&quot;,&quot;</span>;</span><br><span class="line">                json += <span class="string">&quot;\&quot;&quot;</span> + <span class="built_in">escapeJsonString</span>(pair.first) + <span class="string">&quot;\&quot;:&quot;</span> + pair.second.<span class="built_in">toJson</span>();</span><br><span class="line">                first = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            json += <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> json;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> ARRAY: &#123;</span><br><span class="line">            std::string json = <span class="string">&quot;[&quot;</span>;</span><br><span class="line">            <span class="type">bool</span> first = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item : arrayValue_) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!first) json += <span class="string">&quot;,&quot;</span>;</span><br><span class="line">                json += item.<span class="built_in">toJson</span>();</span><br><span class="line">                first = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            json += <span class="string">&quot;]&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> json;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;null&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现fromJson方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">JsonValue::fromJson</span><span class="params">(<span class="type">const</span> std::string&amp; jsonStr)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 递归解析整个JSON字符串，得到一个完整的JsonValue</span></span><br><span class="line">        JsonValue parsed = <span class="built_in">parseValue</span>(jsonStr, pos);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查解析是否完全（避免JSON字符串后有多余字符）</span></span><br><span class="line">        pos = <span class="built_in">skipWhitespace</span>(jsonStr, pos);</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; jsonStr.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Unexpected characters after JSON value&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将解析结果赋值给当前对象</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;type_ = parsed.type_;</span><br><span class="line">        <span class="keyword">this</span>-&gt;stringValue_ = std::<span class="built_in">move</span>(parsed.stringValue_);</span><br><span class="line">        <span class="keyword">this</span>-&gt;numberValue_ = parsed.numberValue_;</span><br><span class="line">        <span class="keyword">this</span>-&gt;boolValue_ = parsed.boolValue_;</span><br><span class="line">        <span class="keyword">this</span>-&gt;objectValue_ = std::<span class="built_in">move</span>(parsed.objectValue_);</span><br><span class="line">        <span class="keyword">this</span>-&gt;arrayValue_ = std::<span class="built_in">move</span>(parsed.arrayValue_);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        <span class="comment">// 解析失败时，重置为null类型</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;type_ = NULL_TYPE;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;JSON parse error: &quot;</span> + std::<span class="built_in">string</span>(e.<span class="built_in">what</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3，高并发线程池">3，高并发线程池</h3>
<p>对于可能出现的高并发场景，需要使用线程池来管理线程，避免频繁创建和销毁线程带来的性能开销。线程池的实现需要考虑线程的创建、销毁、任务分配、任务执行、任务队列等细节。</p>
<p>在 C++17 以上，可以更加灵活地处理线程池，这也为实现基础服务器实现可能</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by HP on 2025/11/5.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CBSF_THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CBSF_THREADPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池类，用于管理多线程执行任务</span></span><br><span class="line"><span class="comment">// Thread pool class, used to manage multi-thread task execution</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 最大任务数</span></span><br><span class="line">    <span class="comment">// Maximum number of tasks</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> maxTasks_ = <span class="number">10000</span>;</span><br><span class="line">    <span class="comment">// 线程列表</span></span><br><span class="line">    <span class="comment">// Thread list</span></span><br><span class="line">    std::vector&lt;std::thread&gt; threads_;</span><br><span class="line">    <span class="comment">// 任务队列</span></span><br><span class="line">    <span class="comment">// Task queue</span></span><br><span class="line">    std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; tasks_;</span><br><span class="line">    <span class="comment">// 互斥锁</span></span><br><span class="line">    <span class="comment">// Mutex lock</span></span><br><span class="line">    std::mutex mtx_;</span><br><span class="line">    <span class="comment">// 条件变量</span></span><br><span class="line">    <span class="comment">// Condition variable</span></span><br><span class="line">    std::condition_variable cv_;</span><br><span class="line">    <span class="comment">// 运行标志</span></span><br><span class="line">    <span class="comment">// Running flag</span></span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; running_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，初始化线程池</span></span><br><span class="line">    <span class="comment">// Constructor, initialize thread pool</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ThreadPool</span><span class="params">(<span class="type">size_t</span> numThreads)</span> </span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数，释放线程池资源</span></span><br><span class="line">    <span class="comment">// Destructor, release thread pool resources</span></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>() ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加任务到线程池</span></span><br><span class="line">    <span class="comment">// Add task to thread pool</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 添加任务到任务队列中</span></span><br><span class="line"><span class="comment">     * @tparam F 函数类型</span></span><br><span class="line"><span class="comment">     * @tparam Args 可变参数类型</span></span><br><span class="line"><span class="comment">     * @param f 要添加的函数</span></span><br><span class="line"><span class="comment">     * @param args 函数参数</span></span><br><span class="line"><span class="comment">     * @return 添加成功返回true，队列已满返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="type">bool</span> <span class="title">addTask</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!running_) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tasks_.<span class="built_in">size</span>() &gt;= <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(maxTasks_)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tasks_.<span class="built_in">emplace</span>(std::<span class="built_in">bind</span>(</span><br><span class="line">                std::forward&lt;F&gt;(f),</span><br><span class="line">                std::forward&lt;Args&gt;(args)...</span><br><span class="line">        ));</span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        cv_.<span class="built_in">notify_one</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//CBSF_THREADPOOL_H</span></span></span><br></pre></td></tr></table></figure>
<p>实际上，就是在任务来的时候，将任务加入队列，并唤醒一个线程来处理任务，线程处理完任务后，继续等待新的任务。这个时候需要加锁，防止多个线程同时操作任务队列。全局用一个锁，保护任务队列同时防止死锁。</p>
<p>当然构造和析构也是要写的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/Threadpool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  线程池构造函数，初始化指定数量的工作线程</span></span><br><span class="line"><span class="comment"> *  Thread pool constructor, initializes specified number of worker threads</span></span><br><span class="line"><span class="comment"> * @param numThreads  线程池中工作线程的数量</span></span><br><span class="line"><span class="comment"> * @param numThreads  Number of worker threads in the thread pool</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ThreadPool::<span class="built_in">ThreadPool</span>(<span class="type">size_t</span> numThreads): <span class="built_in">running_</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建指定数量的工作线程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; numThreads; ++i) &#123;</span><br><span class="line">        <span class="comment">// 使用emplace_back直接在threads_容器中构造线程</span></span><br><span class="line">        threads_.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>] &#123;</span><br><span class="line">                <span class="comment">// 线程主循环，持续运行直到线程池关闭且没有待处理任务</span></span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// 用于存储从任务队列中获取的任务</span></span><br><span class="line">                    std::function&lt;<span class="built_in">void</span>()&gt; task;</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="comment">// 使用互斥锁保护共享资源访问</span></span><br><span class="line">                      std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(<span class="keyword">this</span>-&gt;mtx_);</span><br><span class="line">                      <span class="comment">// 等待条件变量，直到线程池关闭或任务队列不为空</span></span><br><span class="line">                      <span class="keyword">this</span>-&gt;cv_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> !<span class="keyword">this</span>-&gt;running_ || !<span class="keyword">this</span>-&gt;tasks_.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">                      <span class="keyword">if</span>(!<span class="keyword">this</span>-&gt;running_ &amp;&amp; <span class="keyword">this</span>-&gt;tasks_.<span class="built_in">empty</span>())</span><br><span class="line">                          <span class="comment">// 如果线程池关闭且任务队列为空，则退出线程</span></span><br><span class="line">                          <span class="keyword">return</span>;</span><br><span class="line">                      task = std::<span class="built_in">move</span>(<span class="keyword">this</span>-&gt;tasks_.<span class="built_in">front</span>());</span><br><span class="line">                      <span class="comment">// 从任务队列中获取一个任务</span></span><br><span class="line">                      <span class="keyword">this</span>-&gt;tasks_.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="built_in">task</span>();</span><br><span class="line">                        <span class="comment">// 执行任务</span></span><br><span class="line">                    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp;) &#123;</span><br><span class="line">                        <span class="comment">// 捕获并处理标准异常</span></span><br><span class="line">                        std::cerr &lt;&lt; <span class="string">&quot;Exception in thread pool thread&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">                        <span class="comment">// 捕获并处理标准异常</span></span><br><span class="line">                        std::cerr &lt;&lt; <span class="string">&quot;Exception in thread pool thread&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ThreadPool析构函数</span></span><br><span class="line"><span class="comment"> * ThreadPool destructor</span></span><br><span class="line"><span class="comment"> * 用于清理线程池资源</span></span><br><span class="line"><span class="comment"> * Used to clean up thread pool resources</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ThreadPool::~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">    <span class="comment">// 使用互斥锁保护共享变量running_</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="comment">// 设置线程池运行状态为false，通知所有线程退出</span></span><br><span class="line">    running_ = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 唤醒所有等待的线程</span></span><br><span class="line">    cv_.<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="comment">// 解锁互斥锁</span></span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有线程</span></span><br><span class="line">    <span class="keyword">for</span>(std::thread &amp;thread : threads_)</span><br><span class="line">        <span class="comment">// 检查线程是否可被join，如果是则等待线程结束</span></span><br><span class="line">        <span class="keyword">if</span>(thread.<span class="built_in">joinable</span>())</span><br><span class="line">            thread.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4，服务器实现">4，服务器实现</h3>
<p>服务器实现，就是将客户端的请求，交给线程池处理，然后返回结果。通过上面的几个组件，服务器实现起来就很简单了。</p>
<p>服务器结构</p>
<ul>
<li>Request : 接受请求结构体</li>
<li>Response : 返回结果结构体</li>
<li>Server : 服务器类</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求结构</span></span><br><span class="line"><span class="comment">// Request structure</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Request</span> &#123;</span><br><span class="line">    std::string method;</span><br><span class="line">    std::string path;</span><br><span class="line">    std::map&lt;std::string, std::string&gt; headers;</span><br><span class="line">    std::string body;</span><br><span class="line">    std::map&lt;std::string, std::string&gt; queryParams;  <span class="comment">// 查询参数</span></span><br><span class="line">    std::map&lt;std::string, JsonValue&gt; bodyParams;   <span class="comment">// 表单参数或JSON参数</span></span><br><span class="line">    std::unique_ptr&lt;JsonValue&gt; jsonBody;            <span class="comment">// 解析后的JSON对象（如果适用）</span></span><br><span class="line"></span><br><span class="line">    [[nodiscard]] <span class="function">std::string <span class="title">query_param</span><span class="params">(<span class="type">const</span> std::string&amp; key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = queryParams.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">return</span> it != queryParams.<span class="built_in">end</span>() ? it-&gt;second : <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Method: &quot;</span> + method + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Path: &quot;</span> + path + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Query Parameters:\n&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [key, value] : queryParams) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Headers:\n&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [key, value] : headers) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Body: &quot;</span> &lt;&lt; body &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (jsonBody) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Parsed JSON Body: &quot;</span> &lt;&lt; jsonBody-&gt;<span class="built_in">toJson</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Body Parameters (key-value):\n&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [key, value] : bodyParams) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; value.<span class="built_in">toJson</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析请求体，根据Content-Type处理不同格式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">parseBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (body.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取Content-Type，不区分大小写</span></span><br><span class="line">        std::string contentType;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [key, value] : headers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(key.<span class="built_in">c_str</span>(), <span class="string">&quot;content-type&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                contentType = value;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换为小写以便比较</span></span><br><span class="line">        std::<span class="built_in">transform</span>(contentType.<span class="built_in">begin</span>(), contentType.<span class="built_in">end</span>(),</span><br><span class="line">                       contentType.<span class="built_in">begin</span>(), ::tolower);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移除可能的字符集信息，如&quot;application/x-www-form-urlencoded; charset=UTF-8&quot;</span></span><br><span class="line">        <span class="type">size_t</span> semicolonPos = contentType.<span class="built_in">find</span>(<span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (semicolonPos != std::string::npos) &#123;</span><br><span class="line">            contentType = contentType.<span class="built_in">substr</span>(<span class="number">0</span>, semicolonPos);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去除空格</span></span><br><span class="line">        contentType.<span class="built_in">erase</span>(std::<span class="built_in">remove_if</span>(contentType.<span class="built_in">begin</span>(), contentType.<span class="built_in">end</span>(), ::isspace),</span><br><span class="line">                          contentType.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据Content-Type调用相应的解析函数</span></span><br><span class="line">        <span class="keyword">if</span> (contentType == <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>) &#123;</span><br><span class="line">            <span class="built_in">parseUrlEncodedBody</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (contentType == <span class="string">&quot;application/json&quot;</span>) &#123;</span><br><span class="line">            <span class="built_in">parseJsonBody</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (contentType == <span class="string">&quot;multipart/form-data&quot;</span>) &#123;</span><br><span class="line">            <span class="comment">// 处理multipart/form-data（较复杂，需要边界）</span></span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Warning: multipart/form-data parsing not fully implemented\n&quot;</span>;</span><br><span class="line">            <span class="built_in">parseMultipartFormData</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (contentType == <span class="string">&quot;text/plain&quot;</span>) &#123;</span><br><span class="line">            <span class="comment">// 纯文本，直接存储</span></span><br><span class="line">            bodyParams[<span class="string">&quot;_raw_text&quot;</span>] = <span class="built_in">JsonValue</span>(body);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (contentType.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 没有Content-Type，尝试自动检测</span></span><br><span class="line">            <span class="built_in">autoDetectContentType</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 未知类型，作为原始文本处理</span></span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Warning: Unknown Content-Type: &quot;</span> &lt;&lt; contentType &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            bodyParams[<span class="string">&quot;_raw_data&quot;</span>] = <span class="built_in">JsonValue</span>(body);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取JSON请求体中的值</span></span><br><span class="line"><span class="comment">     * @param key JSON键</span></span><br><span class="line"><span class="comment">     * @return 如果键存在且是字符串类型，返回字符串值；否则返回空字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    [[nodiscard]] <span class="function">std::string <span class="title">json_param</span><span class="params">(<span class="type">const</span> std::string&amp; key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!jsonBody) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (jsonBody-&gt;<span class="built_in">getType</span>() == JsonValue::OBJECT) &#123;</span><br><span class="line">                <span class="keyword">auto</span> obj = jsonBody-&gt;<span class="built_in">asObject</span>();</span><br><span class="line">                <span class="keyword">auto</span> it = obj.<span class="built_in">find</span>(key);</span><br><span class="line">                <span class="keyword">if</span> (it != obj.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (it-&gt;second.<span class="built_in">getType</span>() == JsonValue::STRING) &#123;</span><br><span class="line">                        <span class="keyword">return</span> it-&gt;second.<span class="built_in">asString</span>();</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (it-&gt;second.<span class="built_in">getType</span>() == JsonValue::NUMBER) &#123;</span><br><span class="line">                        <span class="keyword">return</span> std::<span class="built_in">to_string</span>(it-&gt;second.<span class="built_in">asNumber</span>());</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (it-&gt;second.<span class="built_in">getType</span>() == JsonValue::BOOLEAN) &#123;</span><br><span class="line">                        <span class="keyword">return</span> it-&gt;second.<span class="built_in">asBoolean</span>() ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Error getting JSON parameter: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查请求体是否是JSON</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    [[nodiscard]] <span class="function"><span class="type">bool</span> <span class="title">isJson</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jsonBody != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取解析后的JSON对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    [[nodiscard]] <span class="function"><span class="type">const</span> JsonValue* <span class="title">getJsonBody</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jsonBody.<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析application/x-www-form-urlencoded格式的请求体</span></span><br><span class="line"><span class="comment">     * 格式: key1=value1&amp;key2=value2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">parseUrlEncodedBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::stringstream <span class="title">ss</span><span class="params">(body)</span></span>;</span><br><span class="line">        std::string pair;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (std::<span class="built_in">getline</span>(ss, pair, <span class="string">&#x27;&amp;&#x27;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair.<span class="built_in">empty</span>()) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">size_t</span> equalsPos = pair.<span class="built_in">find</span>(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (equalsPos != std::string::npos) &#123;</span><br><span class="line">                std::string key = pair.<span class="built_in">substr</span>(<span class="number">0</span>, equalsPos);</span><br><span class="line">                std::string value = pair.<span class="built_in">substr</span>(equalsPos + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// URL解码</span></span><br><span class="line">                key = <span class="built_in">urlDecode</span>(key);</span><br><span class="line">                value = <span class="built_in">urlDecode</span>(value);</span><br><span class="line"></span><br><span class="line">                bodyParams[key] = <span class="built_in">JsonValue</span>(value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 只有key没有value的情况</span></span><br><span class="line">                bodyParams[<span class="built_in">urlDecode</span>(pair)] = <span class="built_in">JsonValue</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析JSON格式的请求体（使用JsonValue类）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">parseJsonBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建JsonValue对象并解析JSON</span></span><br><span class="line">            jsonBody = std::<span class="built_in">make_unique</span>&lt;JsonValue&gt;();</span><br><span class="line">            jsonBody-&gt;<span class="built_in">fromJson</span>(body);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果是JSON对象，将其扁平化到bodyParams以便向后兼容</span></span><br><span class="line">            <span class="keyword">if</span> (jsonBody-&gt;<span class="built_in">getType</span>() == JsonValue::OBJECT) &#123;</span><br><span class="line">                <span class="built_in">flattenJsonToParams</span>(*jsonBody, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (jsonBody-&gt;<span class="built_in">getType</span>() == JsonValue::ARRAY) &#123;</span><br><span class="line">                <span class="comment">// 数组类型的JSON，存储到特殊键</span></span><br><span class="line">                bodyParams[<span class="string">&quot;_json_array&quot;</span>] = *jsonBody;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 其他基本类型</span></span><br><span class="line">                bodyParams[<span class="string">&quot;_json_value&quot;</span>] = *jsonBody;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Failed to parse JSON body: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            <span class="comment">// JSON解析失败，尝试作为普通文本处理</span></span><br><span class="line">            bodyParams[<span class="string">&quot;_invalid_json&quot;</span>] = <span class="built_in">JsonValue</span>(body);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将JSON对象扁平化为键值对（用于向后兼容）</span></span><br><span class="line"><span class="comment">     * @param json JsonValue对象</span></span><br><span class="line"><span class="comment">     * @param prefix 键的前缀（用于嵌套对象）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flattenJsonToParams</span><span class="params">(<span class="type">const</span> JsonValue&amp; json, <span class="type">const</span> std::string&amp; prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (json.<span class="built_in">getType</span>() == JsonValue::OBJECT) &#123;</span><br><span class="line">            <span class="keyword">auto</span> obj = json.<span class="built_in">asObject</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [key, value] : obj) &#123;</span><br><span class="line">                std::string newKey = prefix.<span class="built_in">empty</span>() ? key : prefix + <span class="string">&quot;.&quot;</span> + key;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (value.<span class="built_in">getType</span>() == JsonValue::OBJECT) &#123;</span><br><span class="line">                    <span class="comment">// 递归处理嵌套对象</span></span><br><span class="line">                    <span class="built_in">flattenJsonToParams</span>(value, newKey);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value.<span class="built_in">getType</span>() == JsonValue::ARRAY) &#123;</span><br><span class="line">                    <span class="comment">// 数组存储为JSON字符串</span></span><br><span class="line">                    bodyParams[newKey] = value;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 基本类型转换为字符串</span></span><br><span class="line">                    bodyParams[newKey] = value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将JsonValue基本类型转换为字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">static</span> std::string <span class="title">jsonToString</span><span class="params">(<span class="type">const</span> JsonValue&amp; json)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (json.<span class="built_in">getType</span>()) &#123;</span><br><span class="line">            <span class="keyword">case</span> JsonValue::STRING:</span><br><span class="line">                <span class="keyword">return</span> json.<span class="built_in">asString</span>();</span><br><span class="line">            <span class="keyword">case</span> JsonValue::NUMBER:</span><br><span class="line">                <span class="keyword">return</span> std::<span class="built_in">to_string</span>(json.<span class="built_in">asNumber</span>());</span><br><span class="line">            <span class="keyword">case</span> JsonValue::BOOLEAN:</span><br><span class="line">                <span class="keyword">return</span> json.<span class="built_in">asBoolean</span>() ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> JsonValue::NULL_TYPE:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> json.<span class="built_in">toJson</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析multipart/form-data（简化实现）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">parseMultipartFormData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 提取boundary</span></span><br><span class="line">        std::string contentTypeHeader;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [key, value] : headers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(key.<span class="built_in">c_str</span>(), <span class="string">&quot;content-type&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                contentTypeHeader = value;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::string boundary;</span><br><span class="line">        <span class="type">size_t</span> boundaryPos = contentTypeHeader.<span class="built_in">find</span>(<span class="string">&quot;boundary=&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (boundaryPos != std::string::npos) &#123;</span><br><span class="line">            boundary = contentTypeHeader.<span class="built_in">substr</span>(boundaryPos + <span class="number">9</span>);</span><br><span class="line">            <span class="comment">// 去除可能的引号</span></span><br><span class="line">            <span class="keyword">if</span> (!boundary.<span class="built_in">empty</span>() &amp;&amp; boundary[<span class="number">0</span>] == <span class="string">&#x27;&quot;&#x27;</span>) &#123;</span><br><span class="line">                boundary = boundary.<span class="built_in">substr</span>(<span class="number">1</span>, boundary.<span class="built_in">size</span>() - <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (boundary.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Error: No boundary found in multipart/form-data\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 完整的multipart解析较复杂，这里只做简单示例</span></span><br><span class="line">        std::string delimiter = <span class="string">&quot;--&quot;</span> + boundary;</span><br><span class="line">        std::string endDelimiter = delimiter + <span class="string">&quot;--&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> startPos = body.<span class="built_in">find</span>(delimiter);</span><br><span class="line">        <span class="keyword">if</span> (startPos == std::string::npos) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        startPos += delimiter.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span> (body[startPos] == <span class="string">&#x27;\r&#x27;</span>) startPos++;</span><br><span class="line">        <span class="keyword">if</span> (body[startPos] == <span class="string">&#x27;\n&#x27;</span>) startPos++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">size_t</span> nextDelimiter = body.<span class="built_in">find</span>(delimiter, startPos);</span><br><span class="line">            <span class="keyword">if</span> (nextDelimiter == std::string::npos) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            std::string part = body.<span class="built_in">substr</span>(startPos, nextDelimiter - startPos);</span><br><span class="line">            <span class="built_in">parseMultipartPart</span>(part);</span><br><span class="line"></span><br><span class="line">            startPos = nextDelimiter + delimiter.<span class="built_in">length</span>();</span><br><span class="line">            <span class="keyword">if</span> (body[startPos] == <span class="string">&#x27;\r&#x27;</span>) startPos++;</span><br><span class="line">            <span class="keyword">if</span> (body[startPos] == <span class="string">&#x27;\n&#x27;</span>) startPos++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查是否是结束边界</span></span><br><span class="line">            <span class="keyword">if</span> (body.<span class="built_in">substr</span>(startPos, <span class="number">2</span>) == <span class="string">&quot;--&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析multipart的单个part</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">parseMultipartPart</span><span class="params">(<span class="type">const</span> std::string&amp; part)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查找头部结束位置（空行）</span></span><br><span class="line">        <span class="type">size_t</span> headerEnd = part.<span class="built_in">find</span>(<span class="string">&quot;\r\n\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (headerEnd == std::string::npos) &#123;</span><br><span class="line">            headerEnd = part.<span class="built_in">find</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (headerEnd == std::string::npos) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::string headersStr = part.<span class="built_in">substr</span>(<span class="number">0</span>, headerEnd);</span><br><span class="line">        std::string content = part.<span class="built_in">substr</span>(headerEnd + <span class="number">4</span>); <span class="comment">// 跳过空行</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析Content-Disposition获取name</span></span><br><span class="line">        std::string name;</span><br><span class="line">        <span class="type">size_t</span> namePos = headersStr.<span class="built_in">find</span>(<span class="string">&quot;name=\&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (namePos != std::string::npos) &#123;</span><br><span class="line">            <span class="type">size_t</span> nameEnd = headersStr.<span class="built_in">find</span>(<span class="string">&#x27;\&quot;&#x27;</span>, namePos + <span class="number">6</span>);</span><br><span class="line">            <span class="keyword">if</span> (nameEnd != std::string::npos) &#123;</span><br><span class="line">                name = headersStr.<span class="built_in">substr</span>(namePos + <span class="number">6</span>, nameEnd - namePos - <span class="number">6</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!name.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            bodyParams[name] = <span class="built_in">JsonValue</span>(content);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自动检测Content-Type并解析</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">autoDetectContentType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (body.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试解析为JSON</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 先检查是否是JSON格式</span></span><br><span class="line">            std::string trimmed = body;</span><br><span class="line">            trimmed.<span class="built_in">erase</span>(std::<span class="built_in">remove_if</span>(trimmed.<span class="built_in">begin</span>(), trimmed.<span class="built_in">end</span>(), ::isspace),</span><br><span class="line">                          trimmed.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (trimmed.<span class="built_in">front</span>() == <span class="string">&#x27;&#123;&#x27;</span> &amp;&amp; trimmed.<span class="built_in">back</span>() == <span class="string">&#x27;&#125;&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 尝试解析为JSON</span></span><br><span class="line">                JsonValue testJson;</span><br><span class="line">                testJson.<span class="built_in">fromJson</span>(body);</span><br><span class="line">                <span class="built_in">parseJsonBody</span>();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (trimmed.<span class="built_in">front</span>() == <span class="string">&#x27;[&#x27;</span> &amp;&amp; trimmed.<span class="built_in">back</span>() == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 数组形式的JSON</span></span><br><span class="line">                jsonBody = std::<span class="built_in">make_unique</span>&lt;JsonValue&gt;();</span><br><span class="line">                jsonBody-&gt;<span class="built_in">fromJson</span>(body);</span><br><span class="line">                bodyParams[<span class="string">&quot;_json_array&quot;</span>] = <span class="built_in">JsonValue</span>(body);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp;) &#123;</span><br><span class="line">            <span class="comment">// 不是有效的JSON，继续尝试其他格式</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否是表单数据</span></span><br><span class="line">        <span class="keyword">if</span> (body.<span class="built_in">find</span>(<span class="string">&#x27;=&#x27;</span>) != std::string::npos &amp;&amp;</span><br><span class="line">            (body.<span class="built_in">find</span>(<span class="string">&#x27;&amp;&#x27;</span>) != std::string::npos || body.<span class="built_in">find</span>(<span class="string">&#x27;\n&#x27;</span>) != std::string::npos)) &#123;</span><br><span class="line">            <span class="built_in">parseUrlEncodedBody</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 默认作为纯文本</span></span><br><span class="line">        bodyParams[<span class="string">&quot;_raw_text&quot;</span>] = <span class="built_in">JsonValue</span>(body);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * URL解码（将%XX转换为字符）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">static</span> std::string <span class="title">urlDecode</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span> </span>&#123;</span><br><span class="line">        std::string result;</span><br><span class="line">        result.<span class="built_in">reserve</span>(str.<span class="built_in">length</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == <span class="string">&#x27;%&#x27;</span> &amp;&amp; i + <span class="number">2</span> &lt; str.<span class="built_in">length</span>()) &#123;</span><br><span class="line">                <span class="comment">// 尝试解码%XX格式</span></span><br><span class="line">                std::string hex = str.<span class="built_in">substr</span>(i + <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">                <span class="type">char</span> ch = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(std::<span class="built_in">strtoul</span>(hex.<span class="built_in">c_str</span>(), <span class="literal">nullptr</span>, <span class="number">16</span>));</span><br><span class="line">                result.<span class="built_in">push_back</span>(ch);</span><br><span class="line">                i += <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// +号表示空格</span></span><br><span class="line">                result.<span class="built_in">push_back</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(str[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不区分大小写的字符串比较辅助函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">strcasecmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s1, <span class="type">const</span> <span class="type">char</span>* s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (*s1 &amp;&amp; *s2 &amp;&amp; ::<span class="built_in">tolower</span>(*s1) == ::<span class="built_in">tolower</span>(*s2)) &#123;</span><br><span class="line">            ++s1;</span><br><span class="line">            ++s2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="built_in">tolower</span>(*s1) - ::<span class="built_in">tolower</span>(*s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>较多代码的原因是添加了body解析，实际上就是按照相应的格式进行解析，部分未实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 响应结构</span></span><br><span class="line"><span class="comment">// Response structure</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Response</span> &#123;</span><br><span class="line">    <span class="type">int</span> statusCode = <span class="number">200</span>;</span><br><span class="line">    std::map&lt;std::string, std::string&gt; headers;</span><br><span class="line">    std::string body;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Response</span>() &#123;</span><br><span class="line">        headers[<span class="string">&quot;Content-Type&quot;</span>] = <span class="string">&quot;application/json; charset=utf-8&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 便捷方法：设置JSON响应</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">json</span><span class="params">(<span class="type">const</span> std::string&amp; jsonStr)</span> </span>&#123;</span><br><span class="line">        body = jsonStr;</span><br><span class="line">        headers[<span class="string">&quot;Content-Type&quot;</span>] = <span class="string">&quot;application/json; charset=utf-8&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 便捷方法：设置文本响应</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">text</span><span class="params">(<span class="type">const</span> std::string&amp; textStr)</span> </span>&#123;</span><br><span class="line">        body = textStr;</span><br><span class="line">        headers[<span class="string">&quot;Content-Type&quot;</span>] = <span class="string">&quot;text/plain; charset=utf-8&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 便捷方法：设置HTML响应</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">status</span><span class="params">(<span class="type">int</span> code)</span> </span>&#123;</span><br><span class="line">        statusCode = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">success</span><span class="params">(<span class="type">const</span> std::map&lt;std::string, std::string&gt;&amp; resMap)</span> </span>&#123;</span><br><span class="line">        std::map&lt;std::string, std::string&gt; result=resMap;</span><br><span class="line">        result[<span class="string">&quot;status&quot;</span>] = <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">        result[<span class="string">&quot;message&quot;</span>] = <span class="string">&quot;Success&quot;</span>;</span><br><span class="line">        <span class="built_in">json</span>(<span class="built_in">mpToJson</span>(result));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新版：支持嵌套JSON结构的success方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">success</span><span class="params">(<span class="type">const</span> std::map&lt;std::string, JsonValue&gt;&amp; resMap)</span> </span>&#123;</span><br><span class="line">        std::map&lt;std::string, JsonValue&gt; result;</span><br><span class="line">        result[<span class="string">&quot;status&quot;</span>] = <span class="built_in">JsonValue</span>(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        result[<span class="string">&quot;message&quot;</span>] = <span class="built_in">JsonValue</span>(<span class="string">&quot;Success&quot;</span>);</span><br><span class="line">        <span class="comment">// 合并传入的数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : resMap) &#123;</span><br><span class="line">            result[pair.first] = pair.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">json</span>(<span class="built_in">toJson</span>(result));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">success</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">json</span>(<span class="string">R&quot;(&#123;&quot;status&quot;:&quot;ok&quot;, &quot;message&quot;:&quot;Success&quot;&#125;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">error</span><span class="params">(<span class="type">int</span> code, <span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">        Log::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">write</span>(<span class="string">&quot;Time &quot;</span>+<span class="built_in">getFormattedDate</span>()+<span class="string">&quot; Code &quot;</span>+std::<span class="built_in">to_string</span>(code)+<span class="string">&quot; Error: &quot;</span> + message + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        statusCode = code;</span><br><span class="line">        <span class="built_in">json</span>(<span class="string">R&quot;(&#123;&quot;status&quot;:&quot;fail&quot;, &quot;message&quot;:&quot;)&quot;</span> + message + <span class="string">&quot;\&quot;&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Respond 结构体，用于封装响应信息，包括状态码、头部信息和响应体。其中，<code>json</code>、<code>text</code>、<code>status</code>、<code>success</code> 和 <code>error</code> 方法用于设置不同的响应类型和内容。预设不同响应，对比 Request 结构体比较简单。</p>
<p>通过这两个结构体，定义出路由处理器的格式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路由处理器类型</span></span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>(<span class="type">const</span> Request&amp;, Response&amp;)&gt; Handler;</span><br></pre></td></tr></table></figure>
<p>然后就可以设计 Server 了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单的HTTP服务器类</span></span><br><span class="line"><span class="comment">// Simple HTTP server class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，初始化服务器端口</span></span><br><span class="line">    <span class="comment">// Constructor, initialize server port</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Server</span><span class="params">(<span class="type">int</span> port = <span class="number">8080</span>, <span class="type">bool</span> printParams = <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    <span class="comment">// Destructor</span></span><br><span class="line">    ~<span class="built_in">Server</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册路由 - GET方法</span></span><br><span class="line">    <span class="comment">// Register route - GET method</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">(<span class="type">const</span> std::string&amp; path, Handler handler)</span></span>;</span><br><span class="line">    <span class="comment">// 注册路由 - POST方法</span></span><br><span class="line">    <span class="comment">// Register route - POST method</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">post</span><span class="params">(<span class="type">const</span> std::string&amp; path, Handler handler)</span></span>;</span><br><span class="line">    <span class="comment">// 注册路由 - PUT方法</span></span><br><span class="line">    <span class="comment">// Register route - PUT method</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">const</span> std::string&amp; path, Handler handler)</span></span>;</span><br><span class="line">    <span class="comment">// 注册路由 - DELETE方法</span></span><br><span class="line">    <span class="comment">// Register route - DELETE method</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">const</span> std::string&amp; path, Handler handler)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动服务器</span></span><br><span class="line">    <span class="comment">// Start server</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 停止服务器</span></span><br><span class="line">    <span class="comment">// Stop server</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取服务器实例</span></span><br><span class="line">    <span class="comment">// Get server instance (singleton pattern)</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Server* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> port_;</span><br><span class="line">    <span class="type">int</span> serverSocket_;</span><br><span class="line">    <span class="type">bool</span> running_;</span><br><span class="line">    <span class="type">bool</span> LogParams;</span><br><span class="line">    std::mutex routesMutex_;</span><br><span class="line">    std::mutex logMutex_;</span><br><span class="line">    ThreadPool threadpool_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 路由表：method -&gt; (path -&gt; handler)</span></span><br><span class="line">    std::map&lt;std::string, std::map&lt;std::string, Handler&gt;&gt; routes_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态成员用于信号处理</span></span><br><span class="line">    <span class="type">static</span> Server* instance_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态信号处理函数</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">signalHandler</span><span class="params">(<span class="type">int</span> sig)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册信号处理器</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">registerSignalHandlers</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    <span class="comment">// Windows控制台关闭事件处理函数（友元函数）</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> BOOL WINAPI <span class="title">ConsoleCtrlHandler</span><span class="params">(DWORD dwCtrlType)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 内部方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleClient</span><span class="params">(<span class="type">int</span> clientSocket, <span class="type">const</span> sockaddr_in *clientAddress)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> Request <span class="title">parseRequest</span><span class="params">(<span class="type">const</span> std::string&amp; requestStr)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> std::string <span class="title">buildResponse</span><span class="params">(<span class="type">const</span> Response&amp; response)</span></span>;</span><br><span class="line">    <span class="function">Handler <span class="title">findHandler</span><span class="params">(<span class="type">const</span> std::string&amp; method, <span class="type">const</span> std::string&amp; path)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> std::map&lt;std::string, std::string&gt; <span class="title">parseQueryParams</span><span class="params">(<span class="type">const</span> std::string&amp; query)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 工具函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printRegisteredRoutes</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> std::string <span class="title">getClientIP</span><span class="params">(<span class="type">const</span> sockaddr_in *clientAddress)</span> </span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> std::string <span class="title">urlDecode</span><span class="params">(<span class="type">const</span> std::string &amp;value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> std::string <span class="title">getLanIpv4</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">listenIPv6</span><span class="params">(<span class="type">int</span> serverSocketIPv6)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> std::string <span class="title">getLanIpv6</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样设计，整个服务器的框架就出来了。<br>
通过 get, post, put, del 方法注册路由，通过 run 方法启动服务器，通过 stop 方法停止服务器。</p>
<p>我们主要看这几个方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::get</span><span class="params">(<span class="type">const</span> std::string&amp; path, Handler handler)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(routesMutex_)</span></span>;</span><br><span class="line">    routes_[<span class="string">&quot;GET&quot;</span>][path] = std::<span class="built_in">move</span>(handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::post</span><span class="params">(<span class="type">const</span> std::string&amp; path, Handler handler)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(routesMutex_)</span></span>;</span><br><span class="line">    routes_[<span class="string">&quot;POST&quot;</span>][path] = std::<span class="built_in">move</span>(handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::put</span><span class="params">(<span class="type">const</span> std::string&amp; path, Handler handler)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(routesMutex_)</span></span>;</span><br><span class="line">    routes_[<span class="string">&quot;PUT&quot;</span>][path] = std::<span class="built_in">move</span>(handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::del</span><span class="params">(<span class="type">const</span> std::string&amp; path, Handler handler)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(routesMutex_)</span></span>;</span><br><span class="line">    routes_[<span class="string">&quot;DELETE&quot;</span>][path] = std::<span class="built_in">move</span>(handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过锁保护，将路由注册到路由表中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start 和 stop</span></span><br><span class="line"></span><br><span class="line">Server::<span class="built_in">Server</span>(<span class="type">int</span> port, <span class="type">bool</span> printParams) : <span class="built_in">port_</span>(port),<span class="built_in">serverSocket_</span>(<span class="number">-1</span>), <span class="built_in">running_</span>(<span class="literal">false</span>), <span class="built_in">LogParams</span>(printParams), <span class="built_in">threadpool_</span>(std::thread::<span class="built_in">hardware_concurrency</span>() ? std::thread::<span class="built_in">hardware_concurrency</span>() : <span class="number">1</span>) &#123;</span><br><span class="line">    instance_ = <span class="keyword">this</span>;</span><br><span class="line">    <span class="built_in">registerSignalHandlers</span>(); <span class="comment">// 注册信号处理函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册信号处理函数，用于处理程序终止信号</span></span><br><span class="line"><span class="comment"> * 根据不同操作系统平台设置相应的信号处理机制</span></span><br><span class="line"><span class="comment"> * Register signal handlers for program termination signals</span></span><br><span class="line"><span class="comment"> * Configure appropriate signal handling mechanisms based on different operating systems</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::registerSignalHandlers</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    <span class="comment">// Windows上使用SetConsoleCtrlHandler处理控制台关闭事件</span></span><br><span class="line">    <span class="built_in">SetConsoleCtrlHandler</span>(ConsoleCtrlHandler, TRUE);</span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, signalHandler);</span><br><span class="line">    <span class="built_in">signal</span>(SIGTERM, signalHandler);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">// Linux/Unix上信号处理正常工作</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, signalHandler);</span><br><span class="line">    <span class="built_in">signal</span>(SIGTERM, signalHandler);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 停止服务器函数</span></span><br><span class="line"><span class="comment"> * 该函数用于安全地关闭服务器，释放相关资源</span></span><br><span class="line"><span class="comment"> * Stop server function</span></span><br><span class="line"><span class="comment"> * This function safely shuts down the server and releases related resources</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查服务器是否已经停止，如果已停止则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!running_) &#123;</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">// 已经停止，避免重复输出</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置服务器运行状态为停止</span></span><br><span class="line">    running_ = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 输出服务器停止信息</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Server stopped.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查服务器套接字是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (serverSocket_ &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 关闭服务器套接字</span></span><br><span class="line">        <span class="built_in">close</span>(serverSocket_);</span><br><span class="line">        <span class="comment">// 将套接字描述符重置为无效值</span></span><br><span class="line">        serverSocket_ = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    <span class="comment">// 如果是Windows平台，进行Windows套接字清理</span></span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个是服务器的启动和停止，通过信号处理函数来处理程序终止信号，从而安全地关闭服务器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务器运行函数</span></span><br><span class="line"><span class="comment"> * 初始化网络环境，创建socket，绑定地址，监听连接并处理客户端请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData) != <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: Failed to initialize Winsock&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建并绑定IPv4 socket</span></span><br><span class="line">    serverSocket_ = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (serverSocket_ &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: Failed to create IPv4 socket&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置socket选项</span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    <span class="built_in">setsockopt</span>(serverSocket_, SOL_SOCKET, SO_REUSEADDR, (<span class="type">const</span> <span class="type">char</span>*)&amp;opt, <span class="built_in">sizeof</span>(opt));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">setsockopt</span>(serverSocket_, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="built_in">sizeof</span>(opt));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定IPv4地址</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address&#123;&#125;;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;address, <span class="number">0</span>, <span class="built_in">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>(port_);  <span class="comment">// 使用port_成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(serverSocket_, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="built_in">sizeof</span>(address)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: Failed to bind IPv4 to port &quot;</span> &lt;&lt; port_</span><br><span class="line">                  &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">        <span class="built_in">closesocket</span>(serverSocket_);</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="built_in">close</span>(serverSocket_);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建并绑定IPv6 socket</span></span><br><span class="line">    <span class="type">int</span> serverSocketIPv6 = <span class="number">-1</span>;</span><br><span class="line">    serverSocketIPv6 = <span class="built_in">socket</span>(AF_INET6, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (serverSocketIPv6 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Warning: Failed to create IPv6 socket: &quot;</span></span><br><span class="line">                  &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 不退出，继续使用IPv4</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 设置socket选项</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">        <span class="built_in">setsockopt</span>(serverSocketIPv6, SOL_SOCKET, SO_REUSEADDR, (<span class="type">const</span> <span class="type">char</span>*)&amp;opt, <span class="built_in">sizeof</span>(opt));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="built_in">setsockopt</span>(serverSocketIPv6, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="built_in">sizeof</span>(opt));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在Windows上需要设置IPV6_V6ONLY</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">        <span class="type">int</span> ipv6Only = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">setsockopt</span>(serverSocketIPv6, IPPROTO_IPV6, IPV6_V6ONLY,</span><br><span class="line">                   (<span class="type">const</span> <span class="type">char</span>*)&amp;ipv6Only, <span class="built_in">sizeof</span>(ipv6Only));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定IPv6地址 - 使用相同的端口号</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in6</span> addr6&#123;&#125;;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;addr6, <span class="number">0</span>, <span class="built_in">sizeof</span>(addr6));</span><br><span class="line">        addr<span class="number">6.</span>sin6_family = AF_INET6;</span><br><span class="line">        addr<span class="number">6.</span>sin6_addr = in6addr_any;</span><br><span class="line">        addr<span class="number">6.</span>sin6_port = <span class="built_in">htons</span>(port_);  <span class="comment">// 使用port_成员变量，确保端口一致</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">bind</span>(serverSocketIPv6, (<span class="keyword">struct</span> sockaddr*)&amp;addr6, <span class="built_in">sizeof</span>(addr6)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Warning: Failed to bind IPv6 to port &quot;</span> &lt;&lt; port_</span><br><span class="line">                      &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">            <span class="built_in">closesocket</span>(serverSocketIPv6);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            <span class="built_in">close</span>(serverSocketIPv6);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            serverSocketIPv6 = <span class="number">-1</span>;  <span class="comment">// 标记为无效</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 开始监听</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(serverSocket_, <span class="number">10</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: Failed to listen on IPv4 socket: &quot;</span></span><br><span class="line">                  &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">        <span class="built_in">closesocket</span>(serverSocket_);</span><br><span class="line">        <span class="keyword">if</span> (serverSocketIPv6 &gt;= <span class="number">0</span>) <span class="built_in">closesocket</span>(serverSocketIPv6);</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="built_in">close</span>(serverSocket_);</span><br><span class="line">        <span class="keyword">if</span> (serverSocketIPv6 &gt;= <span class="number">0</span>) <span class="built_in">close</span>(serverSocketIPv6);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果IPv6 socket创建并绑定成功，开始监听</span></span><br><span class="line">    <span class="keyword">if</span> (serverSocketIPv6 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">listen</span>(serverSocketIPv6, <span class="number">10</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Warning: Failed to listen on IPv6 socket: &quot;</span></span><br><span class="line">                      &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">            <span class="built_in">closesocket</span>(serverSocketIPv6);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            <span class="built_in">close</span>(serverSocketIPv6);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            serverSocketIPv6 = <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;IPv6 socket listening on [::]:&quot;</span> &lt;&lt; port_ &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// 启动独立线程监听IPv6连接</span></span><br><span class="line">            std::<span class="built_in">thread</span>([<span class="keyword">this</span>, serverSocketIPv6]() &#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;<span class="built_in">listenIPv6</span>(serverSocketIPv6);</span><br><span class="line">            &#125;).<span class="built_in">detach</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    running_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印服务器信息</span></span><br><span class="line">    <span class="built_in">printRegisteredRoutes</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Server running on:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;  Localhost: http://localhost:&quot;</span> &lt;&lt; port_ &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;  LAN IPv4:  http://&quot;</span> &lt;&lt; <span class="built_in">getLanIpv4</span>() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; port_ &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;  Localhost IPv6: http://[::1]:&quot;</span> &lt;&lt; port_ &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span> (serverSocketIPv6 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;  LAN IPv6:  http://[&quot;</span>&lt;&lt; <span class="built_in">getLanIpv6</span>() &lt;&lt; <span class="string">&quot;]:&quot;</span> &lt;&lt; port_ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;===========================================&quot;</span>&lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主循环接受IPv4连接</span></span><br><span class="line">    <span class="keyword">while</span> (running_) &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> clientAddress&#123;&#125;;</span><br><span class="line">        <span class="type">socklen_t</span> clientAddrLen = <span class="built_in">sizeof</span>(clientAddress);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> clientSocket = <span class="built_in">accept</span>(serverSocket_,</span><br><span class="line">                                  (<span class="keyword">struct</span> sockaddr*)&amp;clientAddress,</span><br><span class="line">                                  &amp;clientAddrLen);</span><br><span class="line">        <span class="keyword">if</span> (clientSocket &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (running_) &#123;</span><br><span class="line">                std::cerr &lt;&lt; <span class="string">&quot;Error: Failed to accept IPv4 connection: &quot;</span></span><br><span class="line">                          &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加到线程池</span></span><br><span class="line">        threadpool_.<span class="built_in">addTask</span>(&amp;Server::handleClient, <span class="keyword">this</span>,</span><br><span class="line">                            clientSocket, &amp;clientAddress);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::listenIPv6</span><span class="params">(<span class="type">int</span> serverSocketIPv6)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (running_) &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_storage</span> clientAddr&#123;&#125;;  <span class="comment">// 使用sockaddr_storage通用结构</span></span><br><span class="line">        <span class="type">socklen_t</span> clientAddrLen = <span class="built_in">sizeof</span>(clientAddr);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> clientSocket = <span class="built_in">accept</span>(serverSocketIPv6,</span><br><span class="line">                                  (<span class="keyword">struct</span> sockaddr*)&amp;clientAddr,</span><br><span class="line">                                  &amp;clientAddrLen);</span><br><span class="line">        <span class="keyword">if</span> (clientSocket &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (running_) &#123;</span><br><span class="line">                std::cerr &lt;&lt; <span class="string">&quot;Error: Failed to accept IPv6 connection: &quot;</span></span><br><span class="line">                          &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据地址族传递正确的参数</span></span><br><span class="line">        <span class="keyword">if</span> (clientAddr.ss_family == AF_INET6) &#123;</span><br><span class="line">            threadpool_.<span class="built_in">addTask</span>(&amp;Server::handleClient, <span class="keyword">this</span>,</span><br><span class="line">                                clientSocket,</span><br><span class="line">                                (<span class="keyword">struct</span> sockaddr_in*)&amp;clientAddr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    <span class="built_in">closesocket</span>(serverSocketIPv6);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">close</span>(serverSocketIPv6);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">Server::getLanIpv4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string lanIp = <span class="string">&quot;127.0.0.1&quot;</span>; <span class="comment">// 默认本地回环（获取失败时返回）</span></span><br><span class="line">    <span class="type">int</span> sockfd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    <span class="comment">// Windows 初始化 Winsock（仅当前函数内临时使用，避免影响全局）</span></span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> lanIp;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建 UDP socket（SOCK_DGRAM），仅用于获取本地 IP，不实际发送数据</span></span><br><span class="line">    sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">return</span> lanIp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 配置公网服务器地址（Google DNS 8.8.8.8，端口 53，仅用于触发本地路由）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serverAddr&#123;&#125;;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serverAddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serverAddr));</span><br><span class="line">    serverAddr.sin_family = AF_INET;</span><br><span class="line">    serverAddr.sin_port = <span class="built_in">htons</span>(<span class="number">53</span>); <span class="comment">// DNS 端口（任意端口均可，53 是常用默认值）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 IP 地址（兼容 IPv4 字符串直接转换）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;8.8.8.8&quot;</span>, &amp;serverAddr.sin_addr) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 解析失败时，尝试通过域名解析（可选，增强兼容性）</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">hostent</span>* host = <span class="built_in">gethostbyname</span>(<span class="string">&quot;8.8.8.8&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (host == <span class="literal">nullptr</span> || host-&gt;h_addr_list[<span class="number">0</span>] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">            <span class="built_in">closesocket</span>(sockfd);</span><br><span class="line">            <span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            <span class="built_in">close</span>(sockfd);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            <span class="keyword">return</span> lanIp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;serverAddr.sin_addr, host-&gt;h_addr_list[<span class="number">0</span>], host-&gt;h_length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 连接 UDP socket（UDP 是无连接协议，但 connect 仅用于绑定目标地址，不建立实际连接）</span></span><br><span class="line">    <span class="comment">// 此操作会让系统自动选择本地合适的网卡（局域网网卡）和端口，从而获取局域网 IP</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;serverAddr, <span class="built_in">sizeof</span>(serverAddr)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 4. 获取本地绑定的地址（即局域网 IP）</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> localAddr&#123;&#125;;</span><br><span class="line">        <span class="type">socklen_t</span> localAddrLen = <span class="built_in">sizeof</span>(localAddr);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">getsockname</span>(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;localAddr, &amp;localAddrLen) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 转换网络字节序 IP 到字符串</span></span><br><span class="line">            <span class="type">char</span> ipBuf[INET_ADDRSTRLEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">inet_ntop</span>(AF_INET, &amp;localAddr.sin_addr, ipBuf, <span class="built_in">sizeof</span>(ipBuf)) != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                lanIp = ipBuf;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 清理资源</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    <span class="built_in">closesocket</span>(sockfd);</span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lanIp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">Server::getLanIpv6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string lanIpv6 = <span class="string">&quot;::1&quot;</span>;</span><br><span class="line">    <span class="type">int</span> sockfd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> lanIpv6;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    sockfd = <span class="built_in">socket</span>(AF_INET6, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">return</span> lanIpv6;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in6</span> serverAddr&#123;&#125;;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serverAddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serverAddr));</span><br><span class="line">    serverAddr.sin6_family = AF_INET6;</span><br><span class="line">    serverAddr.sin6_port = <span class="built_in">htons</span>(<span class="number">53</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 IPv6 地址（跨平台兼容版本）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">inet_pton</span>(AF_INET6, <span class="string">&quot;2001:4860:4860::8888&quot;</span>, &amp;serverAddr.sin6_addr) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">addrinfo</span> hints&#123;&#125;, *res = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="built_in">sizeof</span>(hints));</span><br><span class="line">        hints.ai_family = AF_INET6;</span><br><span class="line">        hints.ai_socktype = SOCK_DGRAM;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">getaddrinfo</span>(<span class="string">&quot;ipv6.google.com&quot;</span>, <span class="literal">nullptr</span>, &amp;hints, &amp;res);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span> || res == <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">            <span class="built_in">closesocket</span>(sockfd);</span><br><span class="line">            <span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            <span class="built_in">close</span>(sockfd);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            <span class="keyword">return</span> lanIpv6;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;serverAddr.sin6_addr,</span><br><span class="line">               &amp;((<span class="keyword">struct</span> sockaddr_in6*)res-&gt;ai_addr)-&gt;sin6_addr,</span><br><span class="line">               <span class="built_in">sizeof</span>(in6_addr));</span><br><span class="line">        <span class="built_in">freeaddrinfo</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;serverAddr, <span class="built_in">sizeof</span>(serverAddr)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in6</span> localAddr&#123;&#125;;</span><br><span class="line">        <span class="type">socklen_t</span> localAddrLen = <span class="built_in">sizeof</span>(localAddr);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">getsockname</span>(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;localAddr, &amp;localAddrLen) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">uint8_t</span>* addrBytes = localAddr.sin6_addr.s6_addr;</span><br><span class="line">            <span class="type">bool</span> isLinkLocal = (addrBytes[<span class="number">0</span>] == <span class="number">0xfe</span> &amp;&amp; (addrBytes[<span class="number">1</span>] &amp; <span class="number">0xc0</span>) == <span class="number">0x80</span>);</span><br><span class="line">            <span class="type">bool</span> isLoopback = (<span class="built_in">memcmp</span>(addrBytes, <span class="string">&quot;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01&quot;</span>, <span class="number">16</span>) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!isLinkLocal &amp;&amp; !isLoopback) &#123;</span><br><span class="line">                <span class="type">char</span> ipBuf[INET6_ADDRSTRLEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">inet_ntop</span>(AF_INET6, &amp;localAddr.sin6_addr, ipBuf, <span class="built_in">sizeof</span>(ipBuf)) != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    lanIpv6 = ipBuf;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    <span class="built_in">closesocket</span>(sockfd);</span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lanIpv6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先通过 socket 函数创建 IPv4 和 IPv6 的 socket，然后分别调用 bind 和 listen 函数进行绑定和监听。如果 IPv6 的 socket 创建和绑定成功，则启动一个独立的线程来监听 IPv6 连接。在主循环中，使用 accept 函数接受 IPv4 连接，并添加到线程池中处理。</p>
<p>后面每次接到连接，先拿到 clientSocket，是请求在网络上的标识，然后通过 clientSocket 获取到 clientAddress，这个是客户端的地址信息，包括 IP 地址和端口号。然后通过 clientSocket 和 clientAddress 创建一个 ClientSession 对象，这个对象负责处理这个连接的请求。</p>
<p>然后就是 handleClient，用于查找并处理请求。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理客户端请求的函数</span></span><br><span class="line"><span class="comment"> * @param clientSocket 客户端套接字描述符</span></span><br><span class="line"><span class="comment"> * @param clientAddress 客户端地址结构指针</span></span><br><span class="line"><span class="comment"> * Handle client request function</span></span><br><span class="line"><span class="comment"> * @param clientSocket Client socket descriptor</span></span><br><span class="line"><span class="comment"> * @param clientAddress Client address structure pointer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::handleClient</span><span class="params">(<span class="type">int</span> clientSocket, <span class="type">const</span> sockaddr_in *clientAddress)</span> </span>&#123;</span><br><span class="line">    std::<span class="type">time_t</span> now = std::<span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> timestamp = <span class="built_in">static_cast</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(now) * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建缓冲区并初始化为0，用于接收客户端数据</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">8192</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// 从客户端读取数据，读取的字节数存储在bytesRead中</span></span><br><span class="line">    <span class="type">int</span> bytesRead = <span class="built_in">recv</span>(clientSocket, buffer, <span class="built_in">sizeof</span>(buffer) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果读取字节数小于等于0，表示连接已关闭或出错</span></span><br><span class="line">    <span class="keyword">if</span> (bytesRead &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 关闭客户端套接字并返回</span></span><br><span class="line">        <span class="built_in">close</span>(clientSocket);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将接收到的数据转换为字符串</span></span><br><span class="line">    <span class="function">std::string <span class="title">requestStr</span><span class="params">(buffer, bytesRead)</span></span>;</span><br><span class="line"></span><br><span class="line">    Log::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">write</span>(<span class="built_in">getFormattedDate</span>()+<span class="string">&quot; &quot;</span>+<span class="built_in">getClientIP</span>(clientAddress)+<span class="string">&quot; &quot;</span>+requestStr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析HTTP请求</span></span><br><span class="line">    Request request = <span class="built_in">parseRequest</span>(requestStr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建响应对象</span></span><br><span class="line">    Response response;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理 OPTIONS 预检请求（CORS）</span></span><br><span class="line">    <span class="keyword">if</span> (request.method == <span class="string">&quot;OPTIONS&quot;</span>) &#123;</span><br><span class="line">        response.statusCode = <span class="number">200</span>;</span><br><span class="line">        response.body = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">// CORS 头将在 buildResponse 中添加</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 查找路由处理器</span></span><br><span class="line">        Handler handler = <span class="built_in">findHandler</span>(request.method, request.path);</span><br><span class="line">        <span class="keyword">if</span> (handler) &#123;</span><br><span class="line">            <span class="comment">// 如果找到处理器，执行处理函数</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">handler</span>(request, response);</span><br><span class="line">            &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">                <span class="comment">// 捕获异常并返回500错误</span></span><br><span class="line">                response.statusCode = <span class="number">500</span>;</span><br><span class="line">                response.<span class="built_in">error</span>(<span class="number">500</span>,<span class="string">&quot;error: &quot;</span> + std::<span class="built_in">string</span>(e.<span class="built_in">what</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果未找到处理器，返回404错误</span></span><br><span class="line">            response.statusCode = <span class="number">404</span>;</span><br><span class="line">            response.<span class="built_in">error</span>(<span class="number">404</span>, <span class="string">&quot;Resource not found&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构建响应字符串并发送给客户端</span></span><br><span class="line">    std::string responseStr = <span class="built_in">buildResponse</span>(response);</span><br><span class="line">    <span class="built_in">send</span>(clientSocket, responseStr.<span class="built_in">c_str</span>(), responseStr.<span class="built_in">length</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印访问日志（类似Apache/Nginx格式）</span></span><br><span class="line">    std::string clientIP = <span class="built_in">getClientIP</span>(clientAddress);</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(logMutex_)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; clientIP &lt;&lt; <span class="string">&quot; - - [&quot;</span> &lt;&lt; <span class="built_in">getFormattedDate</span>() &lt;&lt; <span class="string">&quot;] \&quot;&quot;</span> </span><br><span class="line">              &lt;&lt; request.method &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; request.path;</span><br><span class="line">    <span class="keyword">if</span> (!request.queryParams.<span class="built_in">empty</span>()&amp;&amp;LogParams) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;?&quot;</span>;</span><br><span class="line">        <span class="type">bool</span> first = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; param : request.queryParams) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!first) std::cout &lt;&lt; <span class="string">&quot;&amp;&quot;</span>;</span><br><span class="line">            std::cout &lt;&lt; param.first &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; param.second;</span><br><span class="line">            first = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; HTTP/1.1\&quot; &quot;</span> &lt;&lt; response.statusCode &lt;&lt; <span class="string">&quot; &quot;</span> </span><br><span class="line">              &lt;&lt; response.body.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">    std::<span class="type">time_t</span> end_time = std::<span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> end_timestamp = <span class="built_in">static_cast</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(end_time) * <span class="number">1000</span>;</span><br><span class="line">    std::cout &lt;&lt; end_timestamp - timestamp &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(clientSocket);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析HTTP请求字符串，将其解析为Request结构体</span></span><br><span class="line"><span class="comment"> * @param requestStr HTTP请求字符串</span></span><br><span class="line"><span class="comment"> * @return 解析后的Request对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Request <span class="title">Server::parseRequest</span><span class="params">(<span class="type">const</span> std::string&amp; requestStr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建Request对象和字符串流</span></span><br><span class="line">    Request request;</span><br><span class="line">    <span class="function">std::istringstream <span class="title">iss</span><span class="params">(requestStr)</span></span>;</span><br><span class="line">    std::string line;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析请求行（第一行）</span></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">getline</span>(iss, line)) &#123;</span><br><span class="line">        <span class="function">std::istringstream <span class="title">lineStream</span><span class="params">(line)</span></span>;</span><br><span class="line">        <span class="comment">// 提取方法和路径</span></span><br><span class="line">        lineStream &gt;&gt; request.method &gt;&gt; request.path;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 分离路径和查询参数</span></span><br><span class="line">        <span class="type">size_t</span> queryPos = request.path.<span class="built_in">find</span>(<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (queryPos != std::string::npos) &#123;</span><br><span class="line">            std::string query = request.path.<span class="built_in">substr</span>(queryPos + <span class="number">1</span>);</span><br><span class="line">            request.queryParams = <span class="built_in">parseQueryParams</span>(query);</span><br><span class="line">            <span class="comment">// 解析查询参数</span></span><br><span class="line">            request.path = request.path.<span class="built_in">substr</span>(<span class="number">0</span>, queryPos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新路径为不包含查询参数的部分</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析头部和body</span></span><br><span class="line">    <span class="type">bool</span> inBody = <span class="literal">false</span>;</span><br><span class="line">    std::string body;</span><br><span class="line">    <span class="keyword">while</span> (std::<span class="built_in">getline</span>(iss, line)) &#123;  <span class="comment">// 标记是否进入body部分</span></span><br><span class="line">        <span class="keyword">if</span> (line.<span class="built_in">empty</span>() || line == <span class="string">&quot;\r&quot;</span>) &#123;</span><br><span class="line">            inBody = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 空行或\r表示头部结束，body开始</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!inBody) &#123;</span><br><span class="line">            <span class="type">size_t</span> colonPos = line.<span class="built_in">find</span>(<span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (colonPos != std::string::npos) &#123;</span><br><span class="line">            <span class="comment">// 解析头部字段</span></span><br><span class="line">                std::string key = line.<span class="built_in">substr</span>(<span class="number">0</span>, colonPos);</span><br><span class="line">                std::string value = line.<span class="built_in">substr</span>(colonPos + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 提取键值对</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 去除空格和\r</span></span><br><span class="line">                key.<span class="built_in">erase</span>(<span class="number">0</span>, key.<span class="built_in">find_first_not_of</span>(<span class="string">&quot; \t\r&quot;</span>));</span><br><span class="line">                key.<span class="built_in">erase</span>(key.<span class="built_in">find_last_not_of</span>(<span class="string">&quot; \t\r&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">                value.<span class="built_in">erase</span>(<span class="number">0</span>, value.<span class="built_in">find_first_not_of</span>(<span class="string">&quot; \t\r&quot;</span>));</span><br><span class="line">                value.<span class="built_in">erase</span>(value.<span class="built_in">find_last_not_of</span>(<span class="string">&quot; \t\r&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">                </span><br><span class="line">                request.headers[key] = value;</span><br><span class="line"><span class="comment">//                std::cout&lt;&lt;&quot;key: &quot;&lt;&lt;key&lt;&lt;&quot; value: &quot;&lt;&lt;value&lt;&lt;std::endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            body += line;</span><br><span class="line">            <span class="keyword">if</span> (!iss.<span class="built_in">eof</span>()) body += <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    request.body = body;</span><br><span class="line">    request.<span class="built_in">parseBody</span>();</span><br><span class="line">    <span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建HTTP响应字符串</span></span><br><span class="line"><span class="comment"> * @param response 包含状态码、头部和响应体的Response对象</span></span><br><span class="line"><span class="comment"> * @return 构建好的HTTP响应字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">std::string <span class="title">Server::buildResponse</span><span class="params">(<span class="type">const</span> Response&amp; response)</span> </span>&#123;</span><br><span class="line"><span class="comment">//    std::cout&lt;&lt;&quot;Build Response&quot;&lt;&lt;std::endl;</span></span><br><span class="line"><span class="comment">//    std::cout&lt;&lt;response.statusCode&lt;&lt;std::endl;</span></span><br><span class="line">    std::ostringstream oss;  <span class="comment">// 使用字符串流构建响应</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加状态行，包括HTTP版本、状态码和状态描述</span></span><br><span class="line">    oss &lt;&lt; <span class="string">&quot;HTTP/1.1 &quot;</span> &lt;&lt; response.statusCode &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">switch</span> (response.statusCode) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">200</span>: oss &lt;&lt; <span class="string">&quot;OK&quot;</span>; <span class="keyword">break</span>;      <span class="comment">// 200 OK - 请求成功</span></span><br><span class="line"><span class="comment">// 200 OK - Request successful</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">201</span>: oss &lt;&lt; <span class="string">&quot;Created&quot;</span>; <span class="keyword">break</span>;  <span class="comment">// 201 Created - 资源创建成功</span></span><br><span class="line"><span class="comment">// 201 Created - Resource created successfully</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">400</span>: oss &lt;&lt; <span class="string">&quot;Bad Request&quot;</span>; <span class="keyword">break</span>;  <span class="comment">// 400 Bad Request - 客户端请求错误</span></span><br><span class="line"><span class="comment">// 400 Bad Request - Client request error</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">404</span>: oss &lt;&lt; <span class="string">&quot;Not Found&quot;</span>; <span class="keyword">break</span>;    <span class="comment">// 404 Not Found - 资源未找到</span></span><br><span class="line"><span class="comment">// 404 Not Found - Resource not found</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">500</span>: oss &lt;&lt; <span class="string">&quot;Internal Server Error&quot;</span>; <span class="keyword">break</span>;  <span class="comment">// 500 Internal Server Error - 服务器内部错误</span></span><br><span class="line"><span class="comment">// 500 Internal Server Error - Server internal error</span></span><br><span class="line">        <span class="keyword">default</span>: oss &lt;&lt; <span class="string">&quot;Unknown&quot;</span>; <span class="keyword">break</span>;   <span class="comment">// 未知状态码</span></span><br><span class="line">    &#125;</span><br><span class="line">    oss &lt;&lt; <span class="string">&quot;\r\n&quot;</span>;  <span class="comment">// HTTP协议使用\r\n作为换行符</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加 CORS 头（跨域支持）</span></span><br><span class="line">    oss &lt;&lt; <span class="string">&quot;Access-Control-Allow-Origin: *\r\n&quot;</span>;</span><br><span class="line">    oss &lt;&lt; <span class="string">&quot;Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS\r\n&quot;</span>;</span><br><span class="line">    oss &lt;&lt; <span class="string">&quot;Access-Control-Allow-Headers: Content-Type, Authorization, X-Requested-With\r\n&quot;</span>;</span><br><span class="line">    oss &lt;&lt; <span class="string">&quot;Access-Control-Max-Age: 86400\r\n&quot;</span>;  <span class="comment">// 预检请求缓存24小时</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加其他头部</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; header : response.headers) &#123;</span><br><span class="line">        oss &lt;&lt; header.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; header.second &lt;&lt; <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    oss &lt;&lt; <span class="string">&quot;Content-Length: &quot;</span> &lt;&lt; response.body.<span class="built_in">length</span>() &lt;&lt; <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">    oss &lt;&lt; <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">    oss &lt;&lt; response.body;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    std::cout&lt;&lt;oss.str()&lt;&lt;std::endl;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> oss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找并返回与给定方法和路径匹配的处理程序</span></span><br><span class="line"><span class="comment"> * @param method HTTP方法（如&quot;GET&quot;、&quot;POST&quot;等）</span></span><br><span class="line"><span class="comment"> * @param path 请求的URL路径</span></span><br><span class="line"><span class="comment"> * @return 匹配的Handler对象，如果未找到则返回nullptr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Handler <span class="title">Server::findHandler</span><span class="params">(<span class="type">const</span> std::string&amp; method, <span class="type">const</span> std::string&amp; path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查是否存在对应方法的路由映射</span></span><br><span class="line">    <span class="keyword">if</span> (routes_.<span class="built_in">find</span>(method) != routes_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>&amp; methodRoutes = routes_[method];  <span class="comment">// 获取该方法的所有路由</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 精确匹配检查</span></span><br><span class="line">        <span class="keyword">if</span> (methodRoutes.<span class="built_in">find</span>(path) != methodRoutes.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> methodRoutes.<span class="built_in">at</span>(path);  <span class="comment">// 返回精确匹配的处理程序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;  <span class="comment">// 未找到匹配的处理程序，返回空指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>流程：</p>
<ul>
<li>1，解析请求，获取请求行、头部、body</li>
<li>2，根据请求行中的方法和路径，查找对应的处理程序</li>
<li>3，调用处理程序，获取响应</li>
<li>4，构建响应字符串</li>
<li>5，发送响应</li>
</ul>
<p>至此，一个简单的C++后端服务器实现完成。其余部分欢迎小伙伴们继续完善。</p>
<h3 id="5-Redis缓存-RDConnector-实现原理">5. Redis缓存(RDConnector)实现原理</h3>
<h4 id="5-1-单例模式设计">5.1 单例模式设计</h4>
<p>RDConnector类采用了单例模式设计，确保整个应用中只有一个Redis连接实例。核心实现包括：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态单例实例指针</span></span><br><span class="line">RdConnector* RdConnector::instance_ = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取单例实例</span></span><br><span class="line"><span class="function">RdConnector *<span class="title">RdConnector::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance_;  <span class="comment">// 返回静态单例实例指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在connect方法中设置单例实例</span></span><br><span class="line"><span class="keyword">if</span> (instance_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    instance_ = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单例模式的设计确保了应用程序中只维护一个Redis连接，避免了连接资源的浪费和潜在的连接管理问题。</p>
<h4 id="5-2-Redis连接管理">5.2 Redis连接管理</h4>
<p>Redis连接的建立和管理是通过hiredis客户端库实现的。连接过程包括以下几个关键步骤：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RdConnector::connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查是否已经存在其他RdConnector实例</span></span><br><span class="line">    <span class="keyword">if</span> (instance_ != <span class="literal">nullptr</span> &amp;&amp; instance_ != <span class="keyword">this</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Only one instance of RdConnector is allowed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果已存在连接，则先断开</span></span><br><span class="line">    <span class="keyword">if</span> (context != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">redisFree</span>(context);</span><br><span class="line">        context = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将端口号字符串转换为整数</span></span><br><span class="line">    <span class="type">int</span> port = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        port = std::<span class="built_in">stoi</span>(port_);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;端口格式错误：&quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尝试连接到Redis服务器</span></span><br><span class="line">    context = <span class="built_in">redisConnect</span>(host_.<span class="built_in">c_str</span>(), port);</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="literal">nullptr</span> || context-&gt;err) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;连接失败：&quot;</span> &lt;&lt; (context ? context-&gt;errstr : <span class="string">&quot;内存分配失败&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果配置了密码，进行身份验证</span></span><br><span class="line">    <span class="keyword">if</span> (!password_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span>* reply = (redisReply*)<span class="built_in">redisCommand</span>(context, <span class="string">&quot;AUTH %s&quot;</span>, password_.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">if</span> (reply == <span class="literal">nullptr</span> || reply-&gt;type == REDIS_REPLY_ERROR) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;密码验证失败：&quot;</span> &lt;&lt; (reply ? reply-&gt;str : context-&gt;errstr) &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">redisFree</span>(context);</span><br><span class="line">            context = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="built_in">freeReplyObject</span>(reply);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">freeReplyObject</span>(reply);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果指定了非0数据库，切换到指定数据库</span></span><br><span class="line">    <span class="keyword">if</span>(db!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">auto</span>* reply = (redisReply*)<span class="built_in">redisCommand</span>(context, <span class="string">&quot;SELECT %d&quot;</span>, db);</span><br><span class="line">        <span class="keyword">if</span> (reply == <span class="literal">nullptr</span> || reply-&gt;type == REDIS_REPLY_ERROR) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;切换数据库失败：&quot;</span> &lt;&lt; (reply ? reply-&gt;str : context-&gt;errstr) &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">redisFree</span>(context);</span><br><span class="line">            context = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="built_in">freeReplyObject</span>(reply);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">freeReplyObject</span>(reply);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是第一个实例，则设置instance_指针</span></span><br><span class="line">    <span class="keyword">if</span> (instance_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        instance_ = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>连接管理的特点：</p>
<ul>
<li>连接前检查单例唯一性</li>
<li>断开已存在的连接，避免资源泄露</li>
<li>支持密码验证，增强安全性</li>
<li>支持数据库切换，实现数据隔离</li>
<li>详细的错误处理和日志输出</li>
</ul>
<h4 id="5-3-基本数据操作功能">5.3 基本数据操作功能</h4>
<p>RDConnector提供了一系列基本的数据操作方法，封装了Redis的常用命令：</p>
<h5 id="5-3-1-获取数据（GET）">5.3.1 获取数据（GET）</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">RdConnector::get</span><span class="params">(<span class="type">const</span> std::string&amp; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        std::cerr&lt;&lt;<span class="string">&quot;未连接&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span>* reply = (redisReply*)<span class="built_in">redisCommand</span>(context, <span class="string">&quot;GET %s&quot;</span>, key.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">if</span> (reply == <span class="literal">nullptr</span> || reply-&gt;type == REDIS_REPLY_ERROR) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;获取失败：&quot;</span> &lt;&lt; (reply ? reply-&gt;str : context-&gt;errstr) &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">freeReplyObject</span>(reply);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::string result;</span><br><span class="line">    <span class="keyword">if</span> (reply-&gt;type == REDIS_REPLY_STRING) &#123;</span><br><span class="line">        result = reply-&gt;str;  <span class="comment">// 键存在，返回值</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (reply-&gt;type == REDIS_REPLY_NIL) &#123;</span><br><span class="line">        result = <span class="string">&quot;&quot;</span>;  <span class="comment">// 键不存在，返回空</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;GET 命令返回异常（类型：&quot;</span> &lt;&lt; reply-&gt;type &lt;&lt; <span class="string">&quot;）&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">freeReplyObject</span>(reply);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-3-2-设置数据（SET）">2.3.2 设置数据（SET）</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RdConnector::set</span><span class="params">(<span class="type">const</span> std::string&amp; key, <span class="type">const</span> std::string&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        std::cerr&lt;&lt;<span class="string">&quot;未连接&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span>* reply = (redisReply*)<span class="built_in">redisCommand</span>(context, <span class="string">&quot;SET %s %s&quot;</span>, key.<span class="built_in">c_str</span>(), value.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">if</span> (reply == <span class="literal">nullptr</span> || reply-&gt;type == REDIS_REPLY_ERROR) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;命令执行失败：&quot;</span> &lt;&lt; (reply ? reply-&gt;str : context-&gt;errstr) &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">freeReplyObject</span>(reply);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> success = (reply-&gt;type == REDIS_REPLY_STATUS &amp;&amp; std::<span class="built_in">string</span>(reply-&gt;str) == <span class="string">&quot;OK&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;SET 命令失败：&quot;</span> &lt;&lt; (reply-&gt;str ? reply-&gt;str : <span class="string">&quot;未知错误&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">freeReplyObject</span>(reply);</span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-3-3-设置数据并指定过期时间（SETEX）">2.3.3 设置数据并指定过期时间（SETEX）</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RdConnector::set</span><span class="params">(<span class="type">const</span> std::string&amp; key, <span class="type">const</span> std::string&amp; value, <span class="type">int</span> expireSeconds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        std::cerr&lt;&lt;<span class="string">&quot;未连接&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (expireSeconds &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;过期时间必须大于0&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span>* reply = (redisReply*)<span class="built_in">redisCommand</span>(context, <span class="string">&quot;SETEX %s %d %s&quot;</span>, key.<span class="built_in">c_str</span>(), expireSeconds, value.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">if</span> (reply == <span class="literal">nullptr</span> || reply-&gt;type == REDIS_REPLY_ERROR) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;命令执行失败：&quot;</span> &lt;&lt; (reply ? reply-&gt;str : context-&gt;errstr) &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">freeReplyObject</span>(reply);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> success = (reply-&gt;type == REDIS_REPLY_STATUS &amp;&amp; std::<span class="built_in">string</span>(reply-&gt;str) == <span class="string">&quot;OK&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;SETEX 命令失败：&quot;</span> &lt;&lt; (reply-&gt;str ? reply-&gt;str : <span class="string">&quot;未知错误&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">freeReplyObject</span>(reply);</span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="5-3-4-检查键是否存在（EXISTS）">5.3.4 检查键是否存在（EXISTS）</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RdConnector::exists</span><span class="params">(<span class="type">const</span> std::string&amp; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        std::cerr&lt;&lt;<span class="string">&quot;未连接&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span>* reply = (redisReply*)<span class="built_in">redisCommand</span>(context, <span class="string">&quot;EXISTS %s&quot;</span>, key.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">if</span> (reply == <span class="literal">nullptr</span> || reply-&gt;type == REDIS_REPLY_ERROR) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;命令执行失败：&quot;</span> &lt;&lt; (reply ? reply-&gt;str : context-&gt;errstr) &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">freeReplyObject</span>(reply);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> keyExists = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (reply-&gt;type == REDIS_REPLY_INTEGER) &#123;</span><br><span class="line">        keyExists = (reply-&gt;integer == <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;EXISTS 命令返回异常（类型：&quot;</span> &lt;&lt; reply-&gt;type &lt;&lt; <span class="string">&quot;）&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">freeReplyObject</span>(reply);</span><br><span class="line">    <span class="keyword">return</span> keyExists;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="5-3-5-删除数据（DEL）">5.3.5 删除数据（DEL）</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RdConnector::del</span><span class="params">(<span class="type">const</span> std::string&amp; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;未连接Redis服务器&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    redisReply* reply = (redisReply*)<span class="built_in">redisCommand</span>(context, <span class="string">&quot;DEL %s&quot;</span>, key.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">if</span> (reply == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;DEL命令执行失败：&quot;</span> &lt;&lt; context-&gt;errstr &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> success = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (reply-&gt;type == REDIS_REPLY_ERROR) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;DEL命令失败：&quot;</span> &lt;&lt; reply-&gt;str &lt;&lt; std::endl;</span><br><span class="line">        success = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (reply-&gt;type != REDIS_REPLY_INTEGER) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;DEL命令返回异常（类型：&quot;</span> &lt;&lt; reply-&gt;type &lt;&lt; <span class="string">&quot;）&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        success = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">freeReplyObject</span>(reply);</span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-4-错误处理机制">5.4 错误处理机制</h4>
<p>RDConnector实现了完善的错误处理机制：</p>
<ol>
<li>连接错误处理：检查连接是否成功建立</li>
<li>命令执行错误处理：捕获并记录命令执行失败的情况</li>
<li>类型检查：验证Redis返回数据的类型是否符合预期</li>
<li>内存管理：确保每次操作后正确释放Redis回复对象</li>
<li>错误信息获取：通过getError()方法获取最近的错误信息</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">RdConnector::getError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;未初始化连接&quot;</span>;  <span class="comment">// 连接未初始化时的错误信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> context-&gt;errstr;  <span class="comment">// 返回Redis上下文的错误信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-5-使用示例">5.5 使用示例</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化Redis连接</span></span><br><span class="line">RdConnector* redis = <span class="keyword">new</span> <span class="built_in">RdConnector</span>();</span><br><span class="line">redis-&gt;<span class="built_in">setHost</span>(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">redis-&gt;<span class="built_in">setPort</span>(<span class="string">&quot;6379&quot;</span>);</span><br><span class="line">redis-&gt;<span class="built_in">setPassword</span>(<span class="string">&quot;redis_password&quot;</span>); <span class="comment">// 可选，如果Redis配置了密码</span></span><br><span class="line">redis-&gt;<span class="built_in">setDb</span>(<span class="number">0</span>); <span class="comment">// 可选，默认是0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (redis-&gt;<span class="built_in">connect</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Redis连接成功&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置键值对</span></span><br><span class="line">    <span class="keyword">if</span> (redis-&gt;<span class="built_in">set</span>(<span class="string">&quot;user:1:name&quot;</span>, <span class="string">&quot;张三&quot;</span>)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;设置数据成功&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置键值对并指定过期时间（5分钟）</span></span><br><span class="line">    <span class="keyword">if</span> (redis-&gt;<span class="built_in">set</span>(<span class="string">&quot;session:abc123&quot;</span>, <span class="string">&quot;user_data&quot;</span>, <span class="number">300</span>)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;设置带过期时间的数据成功&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查键是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (redis-&gt;<span class="built_in">exists</span>(<span class="string">&quot;user:1:name&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 获取键值</span></span><br><span class="line">        std::string value = redis-&gt;<span class="built_in">get</span>(<span class="string">&quot;user:1:name&quot;</span>);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;获取的值: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除键</span></span><br><span class="line">    <span class="keyword">if</span> (redis-&gt;<span class="built_in">del</span>(<span class="string">&quot;user:1:name&quot;</span>)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;删除键成功&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> redis; <span class="comment">// 释放连接对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用单例模式</span></span><br><span class="line">RdConnector* redisInstance = <span class="keyword">new</span> <span class="built_in">RdConnector</span>();</span><br><span class="line">redisInstance-&gt;<span class="built_in">setHost</span>(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">redisInstance-&gt;<span class="built_in">setPort</span>(<span class="string">&quot;6379&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (redisInstance-&gt;<span class="built_in">connect</span>()) &#123; <span class="comment">// 这会设置全局单例</span></span><br><span class="line">    <span class="comment">// 通过单例访问</span></span><br><span class="line">    RdConnector* sameInstance = RdConnector::<span class="built_in">getInstance</span>();</span><br><span class="line">    sameInstance-&gt;<span class="built_in">set</span>(<span class="string">&quot;app:version&quot;</span>, <span class="string">&quot;1.0.0&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> redisInstance; <span class="comment">// 注意：释放对象后，单例指针仍然存在，但指向的对象已被销毁</span></span><br><span class="line">    <span class="comment">// 实际应用中应避免这种情况，确保单例的生命周期管理正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-数据库连接-DBConnector-实现原理">6. 数据库连接(DBConnector)实现原理</h3>
<h3 id="6-1-单例模式设计">6.1 单例模式设计</h3>
<p>DBConnector类采用了单例模式设计，确保整个应用中只有一个数据库连接实例。这种设计模式能够有效管理数据库连接资源，避免频繁创建和销毁连接带来的性能开销。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态单例实例指针</span></span><br><span class="line">DBConnector* DBConnector::instance_ = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化单例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBConnector::initInstance</span><span class="params">(<span class="type">const</span> std::string&amp; host, <span class="type">const</span> std::string&amp; user, <span class="type">const</span> std::string&amp; password, <span class="type">const</span> std::string&amp; database, <span class="type">const</span> std::string&amp; port)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果实例不存在，则创建新实例</span></span><br><span class="line">    <span class="keyword">if</span> (instance_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        instance_ = <span class="keyword">new</span> <span class="built_in">DBConnector</span>(host, user, password, database, port);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取单例实例</span></span><br><span class="line"><span class="function">DBConnector* <span class="title">DBConnector::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance_;  <span class="comment">// 返回静态单例实例指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁单例实例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBConnector::destroyInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> instance_;  <span class="comment">// 删除实例，调用析构函数关闭连接</span></span><br><span class="line">        instance_ = <span class="literal">nullptr</span>;  <span class="comment">// 重置指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单例模式的实现确保了应用程序在任何时候都只能有一个数据库连接对象，从而避免了多线程环境下的连接资源争用问题。</p>
<h4 id="6-2-连接管理">6.2 连接管理</h4>
<p>DBConnector通过MySQL C API管理数据库连接，主要包括连接的建立、维护和关闭：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数初始化连接参数</span></span><br><span class="line">DBConnector::<span class="built_in">DBConnector</span>(<span class="type">const</span> std::string&amp; host, <span class="type">const</span> std::string&amp; user, <span class="type">const</span> std::string&amp; password, <span class="type">const</span> std::string&amp; database, <span class="type">const</span> std::string&amp; port)</span><br><span class="line">    : <span class="built_in">host_</span>(host), <span class="built_in">user_</span>(user), <span class="built_in">password_</span>(password), <span class="built_in">database_</span>(database), <span class="built_in">port_</span>(port), <span class="built_in">db_</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 初始化MySQL句柄</span></span><br><span class="line">    db_ = <span class="built_in">mysql_init</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (db_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;MySQL初始化失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数关闭连接</span></span><br><span class="line">DBConnector::~<span class="built_in">DBConnector</span>() &#123;</span><br><span class="line">    <span class="comment">// 关闭数据库连接</span></span><br><span class="line">    <span class="keyword">if</span> (db_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">mysql_close</span>(db_);</span><br><span class="line">        db_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立数据库连接</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DBConnector::connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (db_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;连接失败：MySQL未初始化&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尝试连接到MySQL服务器</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">mysql_real_connect</span>(db_, host_.<span class="built_in">c_str</span>(), user_.<span class="built_in">c_str</span>(), password_.<span class="built_in">c_str</span>(), database_.<span class="built_in">c_str</span>(), std::<span class="built_in">stoi</span>(port_), <span class="literal">nullptr</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;连接失败：&quot;</span> &lt;&lt; <span class="built_in">mysql_error</span>(db_) &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置字符集为UTF-8，确保中文正常显示</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mysql_set_character_set</span>(db_, <span class="string">&quot;utf8mb4&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;设置字符集失败：&quot;</span> &lt;&lt; <span class="built_in">mysql_error</span>(db_) &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 字符集设置失败不会影响连接，继续执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>连接管理的关键特点：</p>
<ul>
<li>构造函数初始化MySQL句柄</li>
<li>析构函数自动关闭连接，避免资源泄漏</li>
<li>connect方法处理连接建立和字符集设置</li>
<li>完善的错误处理和日志输出</li>
</ul>
<h4 id="6-3-查询与执行功能">6.3 查询与执行功能</h4>
<p>DBConnector提供了两个核心方法来操作数据库：</p>
<h5 id="6-3-1-query方法（用于SELECT查询）">6.3.1 query方法（用于SELECT查询）</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MYSQL_RES* <span class="title">DBConnector::query</span><span class="params">(<span class="type">const</span> std::string&amp; sql)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查连接是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (db_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;查询失败：未连接到数据库&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行SQL查询</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mysql_query</span>(db_, sql.<span class="built_in">c_str</span>()) != <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;查询失败：&quot;</span> &lt;&lt; <span class="built_in">mysql_error</span>(db_) &lt;&lt; std::endl;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;SQL: &quot;</span> &lt;&lt; sql &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储结果集</span></span><br><span class="line">    MYSQL_RES* result = <span class="built_in">mysql_store_result</span>(db_);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 检查是否是因为没有结果集（例如非SELECT语句）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">mysql_field_count</span>(db_) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 这是预期的，不是错误</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;获取结果集失败：&quot;</span> &lt;&lt; <span class="built_in">mysql_error</span>(db_) &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="6-3-2-execute方法（用于INSERT、UPDATE、DELETE）">6.3.2 execute方法（用于INSERT、UPDATE、DELETE）</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DBConnector::execute</span><span class="params">(<span class="type">const</span> std::string&amp; sql)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查连接是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (db_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;执行失败：未连接到数据库&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行SQL语句</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mysql_query</span>(db_, sql.<span class="built_in">c_str</span>()) != <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;执行失败：&quot;</span> &lt;&lt; <span class="built_in">mysql_error</span>(db_) &lt;&lt; std::endl;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;SQL: &quot;</span> &lt;&lt; sql &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查是否有结果集（非SELECT语句不应有结果集）</span></span><br><span class="line">    MYSQL_RES* result = <span class="built_in">mysql_store_result</span>(db_);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果返回了结果集，说明SQL可能不是预期的非查询语句</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;警告：非查询语句返回了结果集&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">mysql_free_result</span>(result);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-4-SQL注入防护">6.4 SQL注入防护</h4>
<p>DBConnector实现了SQL注入防护机制，通过escapeSqlLiteral方法对SQL字符串进行转义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">DBConnector::escapeSqlLiteral</span><span class="params">(<span class="type">const</span> std::string&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果连接不存在，返回空字符串</span></span><br><span class="line">    <span class="keyword">if</span> (db_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分配足够大的缓冲区（MySQL要求至少是原值的2倍+1）</span></span><br><span class="line">    <span class="type">size_t</span> bufferSize = value.<span class="built_in">length</span>() * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span>* buffer = <span class="keyword">new</span> <span class="type">char</span>[bufferSize];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用MySQL的转义函数处理字符串</span></span><br><span class="line">    <span class="built_in">mysql_real_escape_string</span>(db_, buffer, value.<span class="built_in">c_str</span>(), value.<span class="built_in">length</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建结果字符串</span></span><br><span class="line">    <span class="function">std::string <span class="title">escaped</span><span class="params">(buffer)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放缓冲区</span></span><br><span class="line">    <span class="keyword">delete</span>[] buffer;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> escaped;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-5-使用示例">6.5 使用示例</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化数据库连接</span></span><br><span class="line">DBConnector* db = <span class="keyword">new</span> <span class="built_in">DBConnector</span>();</span><br><span class="line">db-&gt;<span class="built_in">setHost</span>(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">db-&gt;<span class="built_in">setUser</span>(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">db-&gt;<span class="built_in">setPassword</span>(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">db-&gt;<span class="built_in">setDatabase</span>(<span class="string">&quot;mydb&quot;</span>);</span><br><span class="line">db-&gt;<span class="built_in">setPort</span>(<span class="string">&quot;3306&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (db-&gt;<span class="built_in">connect</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;数据库连接成功&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行SQL查询</span></span><br><span class="line">    <span class="keyword">auto</span> result = db-&gt;<span class="built_in">query</span>(<span class="string">&quot;SELECT * FROM users LIMIT 10&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理查询结果</span></span><br><span class="line">        <span class="type">int</span> num_fields = <span class="built_in">mysql_num_fields</span>(result);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">auto</span> row = <span class="built_in">mysql_fetch_row</span>(result)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_fields; i++) &#123;</span><br><span class="line">                std::cout &lt;&lt; (row[i] ? row[i] : <span class="string">&quot;NULL&quot;</span>) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            std::cout &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        db-&gt;<span class="built_in">freeResult</span>(result); <span class="comment">// 释放结果集</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行SQL更新</span></span><br><span class="line">    <span class="keyword">if</span> (db-&gt;<span class="built_in">execute</span>(<span class="string">&quot;UPDATE users SET status = 1 WHERE id = 1&quot;</span>)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;更新成功，影响行数: &quot;</span> &lt;&lt; db-&gt;<span class="built_in">affectedRows</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> db; <span class="comment">// 释放连接对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用单例模式</span></span><br><span class="line">DBConnector::<span class="built_in">initInstance</span>(<span class="string">&quot;localhost&quot;</span>, <span class="string">&quot;admin&quot;</span>, <span class="string">&quot;password&quot;</span>, <span class="string">&quot;mydb&quot;</span>, <span class="string">&quot;3306&quot;</span>);</span><br><span class="line">DBConnector* dbInstance = DBConnector::<span class="built_in">getInstance</span>();</span><br><span class="line"><span class="keyword">if</span> (dbInstance-&gt;<span class="built_in">connect</span>()) &#123;</span><br><span class="line">    <span class="comment">// 使用单例进行数据库操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    DBConnector::<span class="built_in">destroyInstance</span>(); <span class="comment">// 释放单例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>通过数据库连接和缓存功能的添加，服务器的功能更加完善，能够有效管理数据持久化和缓存，提升应用的性能和响应速度。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.imgs.ovh/2025/12/03/CsbqBg.md.png" alt=""></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://sakjijdidji55.github.io">欣冻</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://sakjijdidji55.github.io/posts/e329799.html">https://sakjijdidji55.github.io/posts/e329799.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://sakjijdidji55.github.io" target="_blank">迷路的小朋友</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="https://i.imgs.ovh/2025/12/03/CsbqBg.md.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/posts/4260ab42.html" title="Transformer大语言模型架构原理学习笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.imgs.ovh/2025/11/17/CfYA2b.md.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Transformer大语言模型架构原理学习笔记</div></div><div class="info-2"><div class="info-item-1">Transformer大语言模型架构原理学习笔记 1. 模型架构与优化方法  在架构里面，我们做的就是把输入的x映射到输出的y，这个映射过程就是模型架构。但是如果模型里面的参数或者是这个模型是随机的，那么这个模型就没有意义，所以我们需要优化方法来优化模型。 就笔者的理解，模型内部实际上就是一堆矩阵（线性变换），与输入x进行矩阵乘法，得到输出y。通过训练，我们希望模型内部的矩阵能够尽量使得输入x映射到输出y。 但是完全的映射是不能的，因为输入和输出都是离散的，所以我们需要一个函数来衡量模型的预测结果与真实结果之间的差距，然后通过优化方法来最小化这个函数，从而优化模型内部的矩阵。 这个函数就是所谓的损失函数，常见的损失函数有均方误差、交叉熵等。（交叉熵是分类任务常用的损失函数，均方误差是回归任务常用的损失函数） 优化方法有梯度下降、牛顿法等。 这里Transformer模型架构的学习我采用了交叉熵（原因参见下文）作为损失函数，采用梯度下降作为优化方法（这个算法成本最低，其他的都还不懂）。 2....</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/my-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">欣冻</div><div class="author-info-description">博客, 技术, 生活</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">C++后端服务器实现笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%93%E5%BA%93"><span class="toc-number">1.1.</span> <span class="toc-text">仓库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">项目结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90"><span class="toc-number">1.3.</span> <span class="toc-text">原理解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-JWT%E8%AE%A4%E8%AF%81%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.1.</span> <span class="toc-text">1. JWT认证原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%8Csha256-%E7%AD%BE%E5%90%8D"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">2，sha256 签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%8Cpayload%E9%83%A8%E5%88%86"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">3，payload部分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%8C%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">4，总体流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%8CJsonValue-%E7%B1%BB"><span class="toc-number">1.3.2.</span> <span class="toc-text">2，JsonValue 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%8C%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.3.3.</span> <span class="toc-text">3，高并发线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.4.</span> <span class="toc-text">4，服务器实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Redis%E7%BC%93%E5%AD%98-RDConnector-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.5.</span> <span class="toc-text">5. Redis缓存(RDConnector)实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">5.1 单例模式设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-Redis%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">5.2 Redis连接管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E5%8A%9F%E8%83%BD"><span class="toc-number">1.3.5.3.</span> <span class="toc-text">5.3 基本数据操作功能</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-1-%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%EF%BC%88GET%EF%BC%89"><span class="toc-number">1.3.5.3.1.</span> <span class="toc-text">5.3.1 获取数据（GET）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-2-%E8%AE%BE%E7%BD%AE%E6%95%B0%E6%8D%AE%EF%BC%88SET%EF%BC%89"><span class="toc-number">1.3.5.3.2.</span> <span class="toc-text">2.3.2 设置数据（SET）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-3-%E8%AE%BE%E7%BD%AE%E6%95%B0%E6%8D%AE%E5%B9%B6%E6%8C%87%E5%AE%9A%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%EF%BC%88SETEX%EF%BC%89"><span class="toc-number">1.3.5.3.3.</span> <span class="toc-text">2.3.3 设置数据并指定过期时间（SETEX）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-4-%E6%A3%80%E6%9F%A5%E9%94%AE%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%EF%BC%88EXISTS%EF%BC%89"><span class="toc-number">1.3.5.3.4.</span> <span class="toc-text">5.3.4 检查键是否存在（EXISTS）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-5-%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%EF%BC%88DEL%EF%BC%89"><span class="toc-number">1.3.5.3.5.</span> <span class="toc-text">5.3.5 删除数据（DEL）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.5.4.</span> <span class="toc-text">5.4 错误处理机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.3.5.5.</span> <span class="toc-text">5.5 使用示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5-DBConnector-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.6.</span> <span class="toc-text">6. 数据库连接(DBConnector)实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.3.7.</span> <span class="toc-text">6.1 单例模式设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86"><span class="toc-number">1.3.7.1.</span> <span class="toc-text">6.2 连接管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-%E6%9F%A5%E8%AF%A2%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%8A%9F%E8%83%BD"><span class="toc-number">1.3.7.2.</span> <span class="toc-text">6.3 查询与执行功能</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-3-1-query%E6%96%B9%E6%B3%95%EF%BC%88%E7%94%A8%E4%BA%8ESELECT%E6%9F%A5%E8%AF%A2%EF%BC%89"><span class="toc-number">1.3.7.2.1.</span> <span class="toc-text">6.3.1 query方法（用于SELECT查询）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-3-2-execute%E6%96%B9%E6%B3%95%EF%BC%88%E7%94%A8%E4%BA%8EINSERT%E3%80%81UPDATE%E3%80%81DELETE%EF%BC%89"><span class="toc-number">1.3.7.2.2.</span> <span class="toc-text">6.3.2 execute方法（用于INSERT、UPDATE、DELETE）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-SQL%E6%B3%A8%E5%85%A5%E9%98%B2%E6%8A%A4"><span class="toc-number">1.3.7.3.</span> <span class="toc-text">6.4 SQL注入防护</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.3.7.4.</span> <span class="toc-text">6.5 使用示例</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/e329799.html" title="C++后端服务器实现笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.imgs.ovh/2025/12/03/CsbqBg.md.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++后端服务器实现笔记"/></a><div class="content"><a class="title" href="/posts/e329799.html" title="C++后端服务器实现笔记">C++后端服务器实现笔记</a><time datetime="2025-12-01T08:00:00.000Z" title="发表于 2025-12-01 16:00:00">2025-12-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4260ab42.html" title="Transformer大语言模型架构原理学习笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.imgs.ovh/2025/11/17/CfYA2b.md.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Transformer大语言模型架构原理学习笔记"/></a><div class="content"><a class="title" href="/posts/4260ab42.html" title="Transformer大语言模型架构原理学习笔记">Transformer大语言模型架构原理学习笔记</a><time datetime="2025-11-17T12:51:00.000Z" title="发表于 2025-11-17 20:51:00">2025-11-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/6f4fa4e7.html" title="快速幂、逆元与组合数学"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.imgs.ovh/2025/10/31/7I8gnp.md.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="快速幂、逆元与组合数学"/></a><div class="content"><a class="title" href="/posts/6f4fa4e7.html" title="快速幂、逆元与组合数学">快速幂、逆元与组合数学</a><time datetime="2025-10-31T15:48:33.000Z" title="发表于 2025-10-31 23:48:33">2025-10-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2f58633e.html" title="常用数据结构"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://origin.picgo.net/2025/10/11/792a8743-6d0d-43fe-91b8-0a5a77b529f4a296a597708421a1.md.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="常用数据结构"/></a><div class="content"><a class="title" href="/posts/2f58633e.html" title="常用数据结构">常用数据结构</a><time datetime="2025-10-11T11:00:00.000Z" title="发表于 2025-10-11 19:00:00">2025-10-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/7258f8a4.html" title="THYTHM 音游"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.imgs.ovh/2025/08/01/HotT9.md.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="THYTHM 音游"/></a><div class="content"><a class="title" href="/posts/7258f8a4.html" title="THYTHM 音游">THYTHM 音游</a><time datetime="2025-08-01T04:00:00.000Z" title="发表于 2025-08-01 12:00:00">2025-08-01</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://i.imgs.ovh/2025/07/03/qLFy9.png);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By 欣冻</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.3</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://blog-twikoo.xindon.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: 'https://blog-twikoo.xindon.top/',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Twikoo' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><div class="aplayer no-destroy" data-id="13348674056" data-server="netease" data-type="playlist"   data-order="list" data-fixed="true" data-preload="auto" data-autoplay="false" data-mutex="true" ></div><script src="https://cdn.jsdelivr.net/npm/mermaid@10.2.4/dist/mermaid.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v 7.3.0" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v5.2.2" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://www.jsdelivr.com/" style="margin-inline:5px" data-title="本站使用JsDelivr为静态资源提供CDN加速" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="https://unpkg.zhimg.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.min.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('article-sort-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__slideInRight');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><script async src="/js/ali_font.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script></body></html>