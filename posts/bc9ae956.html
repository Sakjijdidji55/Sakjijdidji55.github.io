<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据结构与算法实现 | 迷路的小朋友</title><meta name="author" content="欣冻"><meta name="copyright" content="欣冻"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据结构与算法实现 1, 顺序表（SeqList） 顺序表是线性表的顺序存储结构，它是用一组地址连续的存储单元依次存储线性表中的各个元素。 特点：  随机访问： 可以在O(1)时间内通过下标直接访问任意元素 存储密度高： 数据元素之间不需要额外空间存储逻辑关系 插入和删除操作需要移动大量元素： 时间复杂度为O(n) 需要预分配内存空间： 可能存在空间浪费或溢出问题  时间复杂度分析：  按位查找（">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法实现">
<meta property="og:url" content="https://sakjijdidji55.github.io/posts/bc9ae956.html">
<meta property="og:site_name" content="迷路的小朋友">
<meta property="og:description" content="数据结构与算法实现 1, 顺序表（SeqList） 顺序表是线性表的顺序存储结构，它是用一组地址连续的存储单元依次存储线性表中的各个元素。 特点：  随机访问： 可以在O(1)时间内通过下标直接访问任意元素 存储密度高： 数据元素之间不需要额外空间存储逻辑关系 插入和删除操作需要移动大量元素： 时间复杂度为O(n) 需要预分配内存空间： 可能存在空间浪费或溢出问题  时间复杂度分析：  按位查找（">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.imgs.ovh/2025/12/20/ClnnUM.md.png">
<meta property="article:published_time" content="2025-12-28T10:00:00.000Z">
<meta property="article:modified_time" content="2026-01-07T12:11:45.616Z">
<meta property="article:author" content="欣冻">
<meta property="article:tag" content="博客, 技术, 生活, tanxin, tanxin.me, 吃好喝好, 玩好, 睡好, 迷路的小朋友,tanxin55">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.imgs.ovh/2025/12/20/ClnnUM.md.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "数据结构与算法实现",
  "url": "https://sakjijdidji55.github.io/posts/bc9ae956.html",
  "image": "https://i.imgs.ovh/2025/12/20/ClnnUM.md.png",
  "datePublished": "2025-12-28T10:00:00.000Z",
  "dateModified": "2026-01-07T12:11:45.616Z",
  "author": [
    {
      "@type": "Person",
      "name": "欣冻",
      "url": "https://sakjijdidji55.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/logo.ico"><link rel="canonical" href="https://sakjijdidji55.github.io/posts/bc9ae956.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构与算法实现',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="迷路的小朋友" type="application/atom+xml">
</head><body><div id="web_bg" style="background-image: url(https://i.imgs.ovh/2025/07/03/qLFy9.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/my-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/bangumis/index.html"><i class="fa-fw fas fa-home"></i><span> 追番</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://i.imgs.ovh/2025/12/20/ClnnUM.md.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/logo.png" alt="Logo"><span class="site-name">迷路的小朋友</span></a><a class="nav-page-title" href="/"><span class="site-name">数据结构与算法实现</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/bangumis/index.html"><i class="fa-fw fas fa-home"></i><span> 追番</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">数据结构与算法实现</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-12-28T10:00:00.000Z" title="发表于 2025-12-28 18:00:00">2025-12-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-01-07T12:11:45.616Z" title="更新于 2026-01-07 20:11:45">2026-01-07</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="数据结构与算法实现">数据结构与算法实现</h2>
<h3 id="1-顺序表（SeqList）">1, 顺序表（SeqList）</h3>
<p>顺序表是线性表的顺序存储结构，它是用一组地址连续的存储单元依次存储线性表中的各个元素。</p>
<p><strong>特点：</strong></p>
<ul>
<li><strong>随机访问：</strong> 可以在O(1)时间内通过下标直接访问任意元素</li>
<li><strong>存储密度高：</strong> 数据元素之间不需要额外空间存储逻辑关系</li>
<li><strong>插入和删除操作需要移动大量元素：</strong> 时间复杂度为O(n)</li>
<li><strong>需要预分配内存空间：</strong> 可能存在空间浪费或溢出问题</li>
</ul>
<p><strong>时间复杂度分析：</strong></p>
<ul>
<li>按位查找（getElem）：O(1)</li>
<li>按值查找（locateElem）：平均O(n)</li>
<li>插入操作（insertElem）：平均O(n)，最坏O(n)</li>
<li>删除操作（deleteElem）：平均O(n)，最坏O(n)</li>
<li>追加操作（appendElem）：O(1)</li>
</ul>
<p><strong>顺序表扩容机制：</strong><br>
通常顺序表满时，会创建一个更大的数组（如原来的1.5倍或2倍），并将原数据复制到新数组中，然后释放旧数组。这是动态数组（如C++ STL vector）的核心实现机制。</p>
<p><strong>应用场景：</strong></p>
<ul>
<li>需要频繁随机访问元素的场景</li>
<li>存储密度要求高的场景</li>
<li>元素数量变化不大或可以预估的场景</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义默认最大容量（解决MAX_SIZE未定义问题）</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_SIZE = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeqList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ElemType* elem;  <span class="comment">// 动态数组存储元素</span></span><br><span class="line">    <span class="type">int</span> length;      <span class="comment">// 当前表长</span></span><br><span class="line">    <span class="type">int</span> max_size;    <span class="comment">// 最大容量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数（默认容量/自定义容量）</span></span><br><span class="line">    <span class="built_in">SeqList</span>(<span class="type">int</span> size = MAX_SIZE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;Size must be positive&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        max_size = size;</span><br><span class="line">        elem = <span class="keyword">new</span> ElemType[max_size];  <span class="comment">// 动态分配内存</span></span><br><span class="line">        length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数（深拷贝，避免浅拷贝问题）</span></span><br><span class="line">    <span class="built_in">SeqList</span>(<span class="type">const</span> SeqList&amp; other) &#123;</span><br><span class="line">        max_size = other.max_size;</span><br><span class="line">        length = other.length;</span><br><span class="line">        elem = <span class="keyword">new</span> ElemType[max_size];</span><br><span class="line">        <span class="comment">// 逐元素拷贝</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            elem[i] = other.elem[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载（深拷贝）</span></span><br><span class="line">    SeqList&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SeqList&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) &#123;  <span class="comment">// 防止自赋值</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放当前对象的内存</span></span><br><span class="line">        <span class="keyword">delete</span>[] elem;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 深拷贝其他对象的内容</span></span><br><span class="line">        max_size = other.max_size;</span><br><span class="line">        length = other.length;</span><br><span class="line">        elem = <span class="keyword">new</span> ElemType[max_size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            elem[i] = other.elem[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// C++11 移动构造函数（提高性能）</span></span><br><span class="line">    <span class="built_in">SeqList</span>(SeqList&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        max_size = other.max_size;</span><br><span class="line">        length = other.length;</span><br><span class="line">        elem = other.elem;</span><br><span class="line">        <span class="comment">// 将原对象置为空状态，避免双重释放</span></span><br><span class="line">        other.elem = <span class="literal">nullptr</span>;</span><br><span class="line">        other.length = <span class="number">0</span>;</span><br><span class="line">        other.max_size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// C++11 移动赋值运算符（提高性能）</span></span><br><span class="line">    SeqList&amp; <span class="keyword">operator</span>=(SeqList&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] elem;  <span class="comment">// 释放当前对象的资源</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 接管other的资源</span></span><br><span class="line">            max_size = other.max_size;</span><br><span class="line">            length = other.length;</span><br><span class="line">            elem = other.elem;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将原对象置为空状态</span></span><br><span class="line">            other.elem = <span class="literal">nullptr</span>;</span><br><span class="line">            other.length = <span class="number">0</span>;</span><br><span class="line">            other.max_size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数（释放动态内存）</span></span><br><span class="line">    ~<span class="built_in">SeqList</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] elem;</span><br><span class="line">        elem = <span class="literal">nullptr</span>;  <span class="comment">// 避免野指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取表长</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getLength</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按位查找（i从1开始）</span></span><br><span class="line">    <span class="function">ElemType <span class="title">getElem</span><span class="params">(<span class="type">int</span> i)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;Index out of range (getElem)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> elem[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 按位查找的安全版本（返回引用，支持修改）</span></span><br><span class="line">    ElemType&amp; <span class="keyword">operator</span>[](<span class="type">int</span> i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;Index out of range (operator[])&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> elem[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按值查找（返回位置，找不到返回0）</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">locateElem</span><span class="params">(ElemType e)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (elem[i] == e) &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;  <span class="comment">// 位置从1开始</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 未找到</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 按值查找的更通用版本（支持自定义比较函数）</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Compare&gt;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">locateElem</span><span class="params">(ElemType e, Compare comp)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">comp</span>(elem[i], e)) &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素到第i位</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insertElem</span><span class="params">(<span class="type">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 插入位置范围：1 &lt;= i &lt;= length+1（支持表尾插入）</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; length + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;Index out of range (insertElem)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断表是否已满</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isFull</span>()) &#123;</span><br><span class="line">            <span class="comment">// 动态扩容（扩展为原来的1.5倍）</span></span><br><span class="line">            <span class="built_in">resize</span>(max_size * <span class="number">3</span> / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从后往前移动元素，腾出第i位的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = length; j &gt;= i; j--) &#123;</span><br><span class="line">            elem[j] = elem[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        elem[i - <span class="number">1</span>] = e;  <span class="comment">// 插入新元素</span></span><br><span class="line">        length++;         <span class="comment">// 表长+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 动态扩容方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">int</span> new_size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (new_size &lt;= max_size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;  <span class="comment">// 新容量不大于原容量，不扩容</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ElemType* new_elem = <span class="keyword">new</span> ElemType[new_size];</span><br><span class="line">        <span class="comment">// 复制原数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            new_elem[i] = elem[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 释放旧内存，更新指针和容量</span></span><br><span class="line">        <span class="keyword">delete</span>[] elem;</span><br><span class="line">        elem = new_elem;</span><br><span class="line">        max_size = new_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 追加元素到表尾</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">appendElem</span><span class="params">(ElemType e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isFull</span>()) &#123;</span><br><span class="line">            <span class="comment">// 动态扩容</span></span><br><span class="line">            <span class="built_in">resize</span>(max_size * <span class="number">3</span> / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        elem[length++] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除第i位元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteElem</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;Index out of range (deleteElem)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从i位置开始，后续元素前移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; length; j++) &#123;</span><br><span class="line">            elem[j - <span class="number">1</span>] = elem[j];</span><br><span class="line">        &#125;</span><br><span class="line">        length--;  <span class="comment">// 表长-1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 可以添加缩容逻辑，当元素数量远小于容量时释放多余空间</span></span><br><span class="line">        <span class="keyword">if</span> (length &lt; max_size / <span class="number">4</span> &amp;&amp; max_size &gt; MAX_SIZE) &#123;</span><br><span class="line">            <span class="built_in">resize</span>(max_size / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清空表</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        length = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 注意：这里没有释放内存，只是重置了表长</span></span><br><span class="line">        <span class="comment">// 如果需要完全释放内存并重置，可以调用delete和new</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否为空表</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否满表</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isFull</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length == max_size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取当前容量</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getCapacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> max_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历打印顺序表（方便测试）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;SeqList is empty&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;SeqList elements: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            cout &lt;&lt; elem[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 合并两个顺序表</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">const</span> SeqList&amp; other)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 预分配足够空间，避免多次扩容</span></span><br><span class="line">        <span class="type">int</span> new_length = length + other.length;</span><br><span class="line">        <span class="keyword">if</span> (new_length &gt; max_size) &#123;</span><br><span class="line">            <span class="built_in">resize</span>(<span class="built_in">max</span>(new_length, max_size * <span class="number">3</span> / <span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 直接追加other中的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; other.length; i++) &#123;</span><br><span class="line">            elem[length++] = other.elem[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-单链表（Linked-List）">2, 单链表（Linked List）</h3>
<p>单链表是一种常见的线性表链式存储结构，它通过指针将分散存储的结点连接起来，形成一个线性序列。</p>
<p><strong>单链表的特点：</strong></p>
<ul>
<li><strong>动态存储：</strong> 不需要预分配固定大小的内存，可根据需要动态增减结点</li>
<li><strong>非连续存储：</strong> 物理存储上不连续，数据元素之间通过指针链接</li>
<li><strong>插入删除效率高：</strong> 在已知位置的情况下，插入和删除操作时间复杂度为O(1)</li>
<li><strong>随机访问效率低：</strong> 访问第i个元素需要从表头开始遍历，时间复杂度为O(n)</li>
<li><strong>存储开销大：</strong> 每个元素需要额外空间存储指针</li>
</ul>
<p><strong>单链表的基本结构：</strong></p>
<ul>
<li><strong>头结点：</strong> 通常不存储数据，指向第一个数据结点，方便操作统一</li>
<li><strong>数据结点：</strong> 包含数据域和指针域（指向下一个结点）</li>
<li><strong>尾结点：</strong> 指向nullptr（C++）或NULL的最后一个结点</li>
</ul>
<p><strong>时间复杂度分析：</strong></p>
<ul>
<li>按位查找（getElem）：O(n)</li>
<li>按值查找（locateElem）：平均O(n)</li>
<li>插入操作（insertElem）：已知位置时O(1)，未知位置时O(n)</li>
<li>删除操作（deleteElem）：已知位置时O(1)，未知位置时O(n)</li>
<li>追加操作（appendElem）：O(n)</li>
</ul>
<p><strong>单链表vs顺序表对比：</strong></p>
<ul>
<li><strong>空间分配：</strong> 链表动态分配，顺序表静态或动态数组</li>
<li><strong>内存利用：</strong> 链表不连续但有额外指针开销，顺序表连续存储利用率高</li>
<li><strong>操作效率：</strong> 链表插入删除快，顺序表随机访问快</li>
</ul>
<p><strong>应用场景：</strong></p>
<ul>
<li>需要频繁插入删除操作的场景（如频繁修改的链表）</li>
<li>数据量变化较大且无法预估的场景</li>
<li>不需要频繁随机访问的场景</li>
<li>实现其他数据结构（如栈、队列、图的邻接表等）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单链表类（带头结点，非循环）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 单链表结点结构体（内部嵌套）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> &#123;</span><br><span class="line">        ElemType data;   <span class="comment">// 数据域</span></span><br><span class="line">        LNode* next;     <span class="comment">// 后继指针</span></span><br><span class="line">        <span class="comment">// 结点构造函数（默认值更安全）</span></span><br><span class="line">        <span class="built_in">LNode</span>(ElemType val = <span class="built_in">ElemType</span>(), LNode* nxt = <span class="literal">nullptr</span>)</span><br><span class="line">                : <span class="built_in">data</span>(val), <span class="built_in">next</span>(nxt) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    LNode* head;   <span class="comment">// 头结点指针（固定指向头结点，不存储数据）</span></span><br><span class="line">    <span class="type">int</span> length;    <span class="comment">// 表长（直接维护，避免遍历）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数：初始化空链表（带头结点）</span></span><br><span class="line">    <span class="built_in">LinkList</span>() &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">LNode</span>();  <span class="comment">// 创建头结点</span></span><br><span class="line">        length = <span class="number">0</span>;          <span class="comment">// 空链表长度为0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拷贝构造函数（深拷贝）</span></span><br><span class="line">    <span class="built_in">LinkList</span>(<span class="type">const</span> LinkList&amp; other) &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">LNode</span>();  <span class="comment">// 创建头结点</span></span><br><span class="line">        length = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 复制链表内容</span></span><br><span class="line">        LNode* pOther = other.head-&gt;next;</span><br><span class="line">        LNode* pCurrent = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (pOther != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pCurrent-&gt;next = <span class="keyword">new</span> <span class="built_in">LNode</span>(pOther-&gt;data);</span><br><span class="line">            pCurrent = pCurrent-&gt;next;</span><br><span class="line">            pOther = pOther-&gt;next;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 赋值运算符重载（深拷贝）</span></span><br><span class="line">    LinkList&amp; <span class="keyword">operator</span>=(<span class="type">const</span> LinkList&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) &#123;  <span class="comment">// 防止自赋值</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 清空当前链表</span></span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 复制链表内容</span></span><br><span class="line">        LNode* pOther = other.head-&gt;next;</span><br><span class="line">        LNode* pCurrent = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (pOther != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pCurrent-&gt;next = <span class="keyword">new</span> <span class="built_in">LNode</span>(pOther-&gt;data);</span><br><span class="line">            pCurrent = pCurrent-&gt;next;</span><br><span class="line">            pOther = pOther-&gt;next;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// C++11 移动构造函数</span></span><br><span class="line">    <span class="built_in">LinkList</span>(LinkList&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        head = other.head;</span><br><span class="line">        length = other.length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将原对象置为空状态</span></span><br><span class="line">        other.head = <span class="keyword">new</span> <span class="built_in">LNode</span>();</span><br><span class="line">        other.length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// C++11 移动赋值运算符</span></span><br><span class="line">    LinkList&amp; <span class="keyword">operator</span>=(LinkList&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="comment">// 释放当前链表资源</span></span><br><span class="line">            <span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">delete</span> head;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 接管other的资源</span></span><br><span class="line">            head = other.head;</span><br><span class="line">            length = other.length;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将原对象置为空状态</span></span><br><span class="line">            other.head = <span class="keyword">new</span> <span class="built_in">LNode</span>();</span><br><span class="line">            other.length = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数：销毁所有结点（包括头结点）</span></span><br><span class="line">    ~<span class="built_in">LinkList</span>() &#123;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">delete</span> head;</span><br><span class="line">        head = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 核心接口 ==========</span></span><br><span class="line">    <span class="comment">// 获取表长</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getLength</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按位查找（i从1开始），返回对应元素值</span></span><br><span class="line">    <span class="comment">// 异常：索引越界时抛出out_of_range</span></span><br><span class="line">    <span class="function">ElemType <span class="title">getElem</span><span class="params">(<span class="type">int</span> i)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;LinkList::getElem: 索引越界，合法范围[1, &quot;</span> + <span class="built_in">to_string</span>(length) + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        LNode* p = head-&gt;next;  <span class="comment">// 从第一个数据结点开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;  <span class="comment">// 遍历到第i个结点</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取指向第i个元素的指针（内部使用）</span></span><br><span class="line">    <span class="function">LNode* <span class="title">getElemNode</span><span class="params">(<span class="type">int</span> i)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        LNode* p = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按值查找，返回第一个匹配元素的位置（i从1开始），未找到返回0</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">locateElem</span><span class="params">(<span class="type">const</span> ElemType&amp; e)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        LNode* p = head-&gt;next;</span><br><span class="line">        <span class="type">int</span> pos = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;data == e) &#123;</span><br><span class="line">                <span class="keyword">return</span> pos;  <span class="comment">// 找到，返回位置</span></span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 未找到</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 按值查找的通用版本（支持自定义比较函数）</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Compare&gt;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">locateElem</span><span class="params">(<span class="type">const</span> ElemType&amp; e, Compare comp)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        LNode* p = head-&gt;next;</span><br><span class="line">        <span class="type">int</span> pos = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">comp</span>(p-&gt;data, e)) &#123;</span><br><span class="line">                <span class="keyword">return</span> pos;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素到第i位（i从1开始，支持表尾插入）</span></span><br><span class="line">    <span class="comment">// 异常：索引越界时抛出out_of_range</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insertElem</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> ElemType&amp; e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; length + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;LinkList::insertElem: 插入位置越界，合法范围[1, &quot;</span> + <span class="built_in">to_string</span>(length + <span class="number">1</span>) + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到第i-1个结点（前驱结点）</span></span><br><span class="line">        LNode* p = <span class="built_in">getElemNode</span>(i - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 创建新结点，插入到p之后</span></span><br><span class="line">        LNode* newNode = <span class="keyword">new</span> <span class="built_in">LNode</span>(e, p-&gt;next);</span><br><span class="line">        p-&gt;next = newNode;</span><br><span class="line">        length++;  <span class="comment">// 表长+1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾插法添加元素（简化接口）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">appendElem</span><span class="params">(<span class="type">const</span> ElemType&amp; e)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">insertElem</span>(length + <span class="number">1</span>, e);  <span class="comment">// 复用插入逻辑，避免重复代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 头插法添加元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">prependElem</span><span class="params">(<span class="type">const</span> ElemType&amp; e)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">insertElem</span>(<span class="number">1</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除第i位元素，返回被删除的元素值</span></span><br><span class="line">    <span class="comment">// 异常：索引越界时抛出out_of_range</span></span><br><span class="line">    <span class="function">ElemType <span class="title">deleteElem</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;LinkList::deleteElem: 删除位置越界，合法范围[1, &quot;</span> + <span class="built_in">to_string</span>(length) + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到第i-1个结点（前驱结点）</span></span><br><span class="line">        LNode* p = <span class="built_in">getElemNode</span>(i - <span class="number">1</span>);</span><br><span class="line">        LNode* temp = p-&gt;next;    <span class="comment">// 待删除结点</span></span><br><span class="line">        ElemType deletedVal = temp-&gt;data;  <span class="comment">// 保存被删除值</span></span><br><span class="line">        p-&gt;next = temp-&gt;next;     <span class="comment">// 断开链表</span></span><br><span class="line">        <span class="keyword">delete</span> temp;              <span class="comment">// 释放内存</span></span><br><span class="line">        length--;                 <span class="comment">// 表长-1</span></span><br><span class="line">        <span class="keyword">return</span> deletedVal;        <span class="comment">// 返回被删除值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断链表是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清空链表（保留头结点）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="built_in">deleteElem</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 合并两个有序链表（假设元素按升序排列）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mergeSorted</span><span class="params">(<span class="type">const</span> LinkList&amp; other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (other.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;  <span class="comment">// 另一个链表为空，无需合并</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建新链表保存合并结果</span></span><br><span class="line">        LinkList tempList;</span><br><span class="line">        LNode* p1 = head-&gt;next;</span><br><span class="line">        LNode* p2 = other.head-&gt;next;</span><br><span class="line">        LNode* p3 = tempList.head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 合并两个有序链表</span></span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">nullptr</span> &amp;&amp; p2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1-&gt;data &lt;= p2-&gt;data) &#123;</span><br><span class="line">                p3-&gt;next = <span class="keyword">new</span> <span class="built_in">LNode</span>(p1-&gt;data);</span><br><span class="line">                p1 = p1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p3-&gt;next = <span class="keyword">new</span> <span class="built_in">LNode</span>(p2-&gt;data);</span><br><span class="line">                p2 = p2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            p3 = p3-&gt;next;</span><br><span class="line">            tempList.length++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理剩余元素</span></span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p3-&gt;next = <span class="keyword">new</span> <span class="built_in">LNode</span>(p1-&gt;data);</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">            p3 = p3-&gt;next;</span><br><span class="line">            tempList.length++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p3-&gt;next = <span class="keyword">new</span> <span class="built_in">LNode</span>(p2-&gt;data);</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">            p3 = p3-&gt;next;</span><br><span class="line">            tempList.length++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将合并后的结果移到当前链表</span></span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        head-&gt;next = tempList.head-&gt;next;</span><br><span class="line">        length = tempList.length;</span><br><span class="line">        tempList.head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        tempList.length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 扩展接口 ==========</span></span><br><span class="line">    <span class="comment">// 头插法建表（数组元素逆序插入）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createListHead</span><span class="params">(<span class="type">const</span> ElemType arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;LinkList::createListHead: 数组长度不能为负数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先清空原有链表（可选，根据需求）</span></span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">insertElem</span>(<span class="number">1</span>, arr[i]);  <span class="comment">// 每次插入到第1位</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾插法建表（数组元素顺序插入）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createListTail</span><span class="params">(<span class="type">const</span> ElemType arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;LinkList::createListTail: 数组长度不能为负数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先清空原有链表（可选）</span></span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">appendElem</span>(arr[i]);  <span class="comment">// 每次插入到表尾</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 反转链表</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;  <span class="comment">// 空表或只有一个元素，无需反转</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        LNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        LNode* curr = head-&gt;next;</span><br><span class="line">        LNode* next = <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            next = curr-&gt;next;  <span class="comment">// 暂存下一个结点</span></span><br><span class="line">            curr-&gt;next = prev;  <span class="comment">// 反转指针</span></span><br><span class="line">            prev = curr;        <span class="comment">// 前指针后移</span></span><br><span class="line">            curr = next;        <span class="comment">// 当前指针后移</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        head-&gt;next = prev;  <span class="comment">// 头结点指向新的第一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印链表（调试用）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;LinkList is empty&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LNode* p = head-&gt;next;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;LinkList: &quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;nullptr (length: &quot;</span> &lt;&lt; length &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取链表第i个元素的引用（便于修改操作）</span></span><br><span class="line">    <span class="function">ElemType&amp; <span class="title">at</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;LinkList::at: 索引越界，合法范围[1, &quot;</span> + <span class="built_in">to_string</span>(length) + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        LNode* p = head-&gt;next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取最后一个元素</span></span><br><span class="line">    <span class="function">ElemType <span class="title">back</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">underflow_error</span>(<span class="string">&quot;LinkList::back: 链表为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getElem</span>(length);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取第一个元素</span></span><br><span class="line">    <span class="function">ElemType <span class="title">front</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">underflow_error</span>(<span class="string">&quot;LinkList::front: 链表为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getElem</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3-双向循环链表类（DuLinkList）">3, 双向循环链表类（DuLinkList）</h3>
<p>双向循环链表是在双向链表基础上进一步发展而来的数据结构，它既允许向前遍历，也允许向后遍历，并且首尾相连形成一个环形结构。</p>
<p><strong>双向循环链表的特点：</strong></p>
<ul>
<li><strong>双向遍历能力：</strong> 每个结点同时拥有前驱指针和后继指针，可以双向遍历</li>
<li><strong>循环连接：</strong> 尾结点的后继指向头结点，头结点的前驱指向尾结点，形成闭环</li>
<li><strong>头结点哨兵：</strong> 使用头结点作为哨兵，简化边界条件处理</li>
<li><strong>插入删除高效：</strong> 在已知位置的情况下，插入删除操作只需O(1)时间，且无需额外查找前驱</li>
<li><strong>额外空间开销：</strong> 每个结点需要额外存储一个前驱指针，空间开销较大</li>
</ul>
<p><strong>双向循环链表的基本结构：</strong></p>
<ul>
<li><strong>头结点：</strong> 不存储数据，是链表的入口点，head-&gt;prior指向尾结点，head-&gt;next指向第一个数据结点</li>
<li><strong>数据结点：</strong> 包含数据域、前驱指针和后继指针</li>
<li><strong>尾结点：</strong> 最后一个数据结点，其next指向头结点，prior指向倒数第二个结点</li>
</ul>
<p><strong>时间复杂度分析：</strong></p>
<ul>
<li>按位查找（getElem）：O(n)</li>
<li>按值查找（locateElem）：平均O(n)</li>
<li>插入操作（insertElem）：已知位置时O(1)，未知位置时O(n)</li>
<li>删除操作（deleteElem）：已知位置时O(1)，未知位置时O(n)</li>
<li>追加操作：O(1)（利用循环特性可以直接访问尾结点）</li>
<li>双向遍历：从任意位置可向前或向后遍历，O(n)</li>
</ul>
<p><strong>双向循环链表vs单链表对比：</strong></p>
<ul>
<li><strong>遍历方向：</strong> 单链表只能单向遍历，双向链表可双向遍历</li>
<li><strong>操作效率：</strong> 双向链表在某些操作（如逆向遍历、已知结点删除）上更高效</li>
<li><strong>空间开销：</strong> 双向链表需要额外存储前驱指针，空间开销更大</li>
<li><strong>复杂度：</strong> 双向链表实现逻辑稍复杂，但使用更灵活</li>
</ul>
<p><strong>应用场景：</strong></p>
<ul>
<li>需要频繁双向遍历的场景</li>
<li>需要在任意位置进行高效插入删除操作的场景</li>
<li>需要实现循环队列、双向队列等数据结构</li>
<li>文本编辑器中的撤销/重做操作</li>
<li>操作系统中的进程调度表</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双向循环链表类（带头结点，循环设计）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DuLinkList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 双向链表结点结构体</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DulNode</span> &#123;</span><br><span class="line">        ElemType data;    <span class="comment">// 数据域</span></span><br><span class="line">        DulNode* prior;   <span class="comment">// 前驱指针</span></span><br><span class="line">        DulNode* next;    <span class="comment">// 后继指针</span></span><br><span class="line">        <span class="comment">// 结点构造函数</span></span><br><span class="line">        <span class="built_in">DulNode</span>(ElemType val = <span class="built_in">ElemType</span>(), DulNode* pre = <span class="literal">nullptr</span>, DulNode* nxt = <span class="literal">nullptr</span>)</span><br><span class="line">                : <span class="built_in">data</span>(val), <span class="built_in">prior</span>(pre), <span class="built_in">next</span>(nxt) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    DulNode* head;  <span class="comment">// 头结点指针（循环链表的固定头）</span></span><br><span class="line">    <span class="type">int</span> length;     <span class="comment">// 表长</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数：初始化双向循环空链表</span></span><br><span class="line">    <span class="built_in">DuLinkList</span>() &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">DulNode</span>();        <span class="comment">// 创建头结点</span></span><br><span class="line">        head-&gt;prior = head;          <span class="comment">// 前驱指向自身（循环）</span></span><br><span class="line">        head-&gt;next = head;           <span class="comment">// 后继指向自身（循环）</span></span><br><span class="line">        length = <span class="number">0</span>;                  <span class="comment">// 空链表长度为0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拷贝构造函数（深拷贝）</span></span><br><span class="line">    <span class="built_in">DuLinkList</span>(<span class="type">const</span> DuLinkList&amp; other) &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">DulNode</span>();        <span class="comment">// 创建头结点</span></span><br><span class="line">        head-&gt;prior = head;      <span class="comment">// 初始化为空循环链表</span></span><br><span class="line">        head-&gt;next = head;</span><br><span class="line">        length = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 复制其他链表的内容</span></span><br><span class="line">        DulNode* pOther = other.head-&gt;next;</span><br><span class="line">        DulNode* pCurrent = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (pOther != other.head) &#123;</span><br><span class="line">            pCurrent-&gt;next = <span class="keyword">new</span> <span class="built_in">DulNode</span>(pOther-&gt;data, pCurrent, head);</span><br><span class="line">            pCurrent = pCurrent-&gt;next;</span><br><span class="line">            pOther = pOther-&gt;next;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新头结点的前驱指针，确保循环特性</span></span><br><span class="line">        head-&gt;prior = pCurrent;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 赋值运算符重载（深拷贝）</span></span><br><span class="line">    DuLinkList&amp; <span class="keyword">operator</span>=(<span class="type">const</span> DuLinkList&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) &#123;  <span class="comment">// 防止自赋值</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 清空当前链表</span></span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 复制其他链表的内容</span></span><br><span class="line">        DulNode* pOther = other.head-&gt;next;</span><br><span class="line">        DulNode* pCurrent = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (pOther != other.head) &#123;</span><br><span class="line">            pCurrent-&gt;next = <span class="keyword">new</span> <span class="built_in">DulNode</span>(pOther-&gt;data, pCurrent, head);</span><br><span class="line">            pCurrent = pCurrent-&gt;next;</span><br><span class="line">            pOther = pOther-&gt;next;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新头结点的前驱指针</span></span><br><span class="line">        head-&gt;prior = pCurrent;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// C++11 移动构造函数</span></span><br><span class="line">    <span class="built_in">DuLinkList</span>(DuLinkList&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        head = other.head;</span><br><span class="line">        length = other.length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将原对象置为空状态</span></span><br><span class="line">        other.head = <span class="keyword">new</span> <span class="built_in">DulNode</span>();</span><br><span class="line">        other.head-&gt;prior = other.head;</span><br><span class="line">        other.head-&gt;next = other.head;</span><br><span class="line">        other.length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// C++11 移动赋值运算符</span></span><br><span class="line">    DuLinkList&amp; <span class="keyword">operator</span>=(DuLinkList&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="comment">// 释放当前链表资源</span></span><br><span class="line">            <span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">delete</span> head;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 接管other的资源</span></span><br><span class="line">            head = other.head;</span><br><span class="line">            length = other.length;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将原对象置为空状态</span></span><br><span class="line">            other.head = <span class="keyword">new</span> <span class="built_in">DulNode</span>();</span><br><span class="line">            other.head-&gt;prior = other.head;</span><br><span class="line">            other.head-&gt;next = other.head;</span><br><span class="line">            other.length = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数：销毁所有结点</span></span><br><span class="line">    ~<span class="built_in">DuLinkList</span>() &#123;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">delete</span> head;</span><br><span class="line">        head = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取指向第i个元素的指针（内部使用，支持高效操作）</span></span><br><span class="line">    <span class="function">DulNode* <span class="title">getElemNode</span><span class="params">(<span class="type">int</span> i)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 优化：根据i的位置选择从前往后或从后往前遍历</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt;= length / <span class="number">2</span>) &#123;  <span class="comment">// 前半部分，从前向后遍历</span></span><br><span class="line">            DulNode* p = head-&gt;next;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 后半部分，从后向前遍历</span></span><br><span class="line">            DulNode* p = head-&gt;prior;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = length; j &gt; i; j--) &#123;</span><br><span class="line">                p = p-&gt;prior;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 核心接口 ==========</span></span><br><span class="line">    <span class="comment">// 获取表长</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getLength</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按位查找（i从1开始），返回对应元素值</span></span><br><span class="line">    <span class="function">ElemType <span class="title">getElem</span><span class="params">(<span class="type">int</span> i)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;DuLinkList::getElem: 索引越界，合法范围[1, &quot;</span> + <span class="built_in">to_string</span>(length) + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        DulNode* p = <span class="built_in">getElemNode</span>(i);</span><br><span class="line">        <span class="keyword">return</span> p-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取链表第i个元素的引用（便于修改操作）</span></span><br><span class="line">    <span class="function">ElemType&amp; <span class="title">at</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;DuLinkList::at: 索引越界，合法范围[1, &quot;</span> + <span class="built_in">to_string</span>(length) + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        DulNode* p = <span class="built_in">getElemNode</span>(i);</span><br><span class="line">        <span class="keyword">return</span> p-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取第一个元素</span></span><br><span class="line">    <span class="function">ElemType <span class="title">front</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">underflow_error</span>(<span class="string">&quot;DuLinkList::front: 链表为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取最后一个元素（利用循环特性，O(1)时间）</span></span><br><span class="line">    <span class="function">ElemType <span class="title">back</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">underflow_error</span>(<span class="string">&quot;DuLinkList::back: 链表为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;prior-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 按值查找，返回第一个匹配元素的位置，未找到返回0</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">locateElem</span><span class="params">(<span class="type">const</span> ElemType&amp; e)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        DulNode* p = head-&gt;next;</span><br><span class="line">        <span class="type">int</span> pos = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != head) &#123;          <span class="comment">// 遍历到循环头结束</span></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;data == e) &#123;</span><br><span class="line">                <span class="keyword">return</span> pos;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 按值查找的通用版本（支持自定义比较函数）</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Compare&gt;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">locateElem</span><span class="params">(<span class="type">const</span> ElemType&amp; e, Compare comp)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        DulNode* p = head-&gt;next;</span><br><span class="line">        <span class="type">int</span> pos = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != head) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">comp</span>(p-&gt;data, e)) &#123;</span><br><span class="line">                <span class="keyword">return</span> pos;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素到第i位（i从1开始）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insertElem</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> ElemType&amp; e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; length + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;DuLinkList::insertElem: 插入位置越界，合法范围[1, &quot;</span> + <span class="built_in">to_string</span>(length + <span class="number">1</span>) + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找到第i-1个结点（前驱结点）</span></span><br><span class="line">        DulNode* p = (i == <span class="number">1</span>) ? head : <span class="built_in">getElemNode</span>(i - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建新结点，调整前驱后继指针</span></span><br><span class="line">        DulNode* newNode = <span class="keyword">new</span> <span class="built_in">DulNode</span>(e, p, p-&gt;next);</span><br><span class="line">        p-&gt;next-&gt;prior = newNode;    <span class="comment">// 原后继的前驱指向新结点</span></span><br><span class="line">        p-&gt;next = newNode;           <span class="comment">// 前驱的后继指向新结点</span></span><br><span class="line">        length++;                    <span class="comment">// 表长+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尾插法添加元素（O(1)时间）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">appendElem</span><span class="params">(<span class="type">const</span> ElemType&amp; e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 利用循环特性，直接在尾结点后插入</span></span><br><span class="line">        DulNode* tail = head-&gt;prior;</span><br><span class="line">        DulNode* newNode = <span class="keyword">new</span> <span class="built_in">DulNode</span>(e, tail, head);</span><br><span class="line">        tail-&gt;next = newNode;</span><br><span class="line">        head-&gt;prior = newNode;</span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 头插法添加元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">prependElem</span><span class="params">(<span class="type">const</span> ElemType&amp; e)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">insertElem</span>(<span class="number">1</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除第i位元素，返回被删除的元素值</span></span><br><span class="line">    <span class="function">ElemType <span class="title">deleteElem</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;DuLinkList::deleteElem: 删除位置越界，合法范围[1, &quot;</span> + <span class="built_in">to_string</span>(length) + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找到第i个结点</span></span><br><span class="line">        DulNode* p = <span class="built_in">getElemNode</span>(i);</span><br><span class="line">        ElemType deletedVal = p-&gt;data;  <span class="comment">// 保存被删除值</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调整前驱后继指针</span></span><br><span class="line">        p-&gt;prior-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next-&gt;prior = p-&gt;prior;</span><br><span class="line">        <span class="keyword">delete</span> p;                       <span class="comment">// 释放内存</span></span><br><span class="line">        length--;                       <span class="comment">// 表长-1</span></span><br><span class="line">        <span class="keyword">return</span> deletedVal;              <span class="comment">// 返回被删除值</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清空链表（保留头结点）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="built_in">deleteElem</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 反转链表</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;  <span class="comment">// 空表或只有一个元素，无需反转</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 交换每个结点的prior和next指针</span></span><br><span class="line">        DulNode* p = head;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 交换prior和next指针</span></span><br><span class="line">            DulNode* temp = p-&gt;next;</span><br><span class="line">            p-&gt;next = p-&gt;prior;</span><br><span class="line">            p-&gt;prior = temp;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 移动到下一个原前驱（反转后的后继）</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (p != head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断链表是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印链表（调试用）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;DuLinkList is empty&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        DulNode* p = head-&gt;next;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;DuLinkList: &quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != head) &#123;</span><br><span class="line">            cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &lt;-&gt; &quot;</span>;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;head (length: &quot;</span> &lt;&lt; length &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 逆向打印链表（从尾到头）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printListReverse</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;DuLinkList is empty&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        DulNode* p = head-&gt;prior;  <span class="comment">// 从尾结点开始</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;DuLinkList (reversed): &quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != head) &#123;</span><br><span class="line">            cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &lt;-&gt; &quot;</span>;</span><br><span class="line">            p = p-&gt;prior;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;head (length: &quot;</span> &lt;&lt; length &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从数组创建双向循环链表</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createFromArray</span><span class="params">(<span class="type">const</span> ElemType arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;DuLinkList::createFromArray: 数组长度不能为负数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">clear</span>();  <span class="comment">// 清空原有内容</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">appendElem</span>(arr[i]);  <span class="comment">// 使用O(1)的尾插法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4-栈的实现（顺序存储和链式存储）">4, 栈的实现（顺序存储和链式存储）</h3>
<p>栈（Stack）是一种遵循**后进先出（LIFO, Last In First Out）**原则的线性数据结构，它只允许在一端（称为栈顶）进行插入和删除操作。</p>
<p><strong>栈的基本特点：</strong></p>
<ul>
<li><strong>操作受限：</strong> 只允许在栈顶进行插入（入栈/压栈）和删除（出栈/弹栈）操作</li>
<li><strong>LIFO特性：</strong> 最后进入栈的元素最先被取出</li>
<li><strong>线性结构：</strong> 元素之间存在一对一的线性关系</li>
<li><strong>抽象数据类型：</strong> 定义了一组操作接口，与具体实现无关</li>
</ul>
<p><strong>栈的主要操作：</strong></p>
<ul>
<li><strong>初始化（InitStack）：</strong> 创建一个空栈</li>
<li><strong>入栈（Push）：</strong> 在栈顶插入新元素</li>
<li><strong>出栈（Pop）：</strong> 移除并返回栈顶元素</li>
<li><strong>取栈顶元素（GetTop/Peek）：</strong> 返回栈顶元素但不移除</li>
<li><strong>判空（IsEmpty）：</strong> 判断栈是否为空</li>
<li><strong>判满（IsFull）：</strong> 判断顺序栈是否已满</li>
<li><strong>获取长度（GetLength）：</strong> 获取栈中元素个数</li>
</ul>
<p><strong>栈的应用场景：</strong></p>
<ul>
<li>函数调用的管理</li>
<li>表达式求值</li>
<li>括号匹配验证</li>
<li>算法的回溯实现</li>
<li>内存管理</li>
<li>浏览器的前进/后退功能</li>
</ul>
<p><strong>顺序栈（SeqStack）：</strong></p>
<p>顺序栈是使用数组实现的栈，具有以下特点：</p>
<ul>
<li><strong>优点：</strong> 实现简单，存储密度高，入栈出栈操作时间复杂度为O(1)</li>
<li><strong>缺点：</strong> 静态空间有限，可能发生栈溢出；动态扩容时需要额外时间开销</li>
<li><strong>适用场景：</strong> 预先知道栈最大容量，且操作频繁的场景</li>
</ul>
<p><strong>顺序栈的基本结构：</strong></p>
<ul>
<li>数组：用于存储栈元素</li>
<li>栈顶指针：指示当前栈顶位置，初始值为-1表示空栈</li>
<li>最大容量：栈的最大存储元素数量</li>
</ul>
<p><strong>顺序栈的时间复杂度：</strong></p>
<ul>
<li>入栈（push）：O(1)</li>
<li>出栈（pop）：O(1)</li>
<li>取栈顶元素（getTop）：O(1)</li>
<li>判空/判满（isEmpty/isFull）：O(1)</li>
<li>获取长度（getLength）：O(1)</li>
</ul>
<p><strong>链栈（LinkStack）：</strong></p>
<p>链栈是使用单链表实现的栈，具有以下特点：</p>
<ul>
<li><strong>优点：</strong> 动态分配空间，不存在栈满问题；不需要预先确定大小</li>
<li><strong>缺点：</strong> 每个元素需要额外空间存储指针，存储密度较低；操作时需要动态内存管理</li>
<li><strong>适用场景：</strong> 无法预估栈大小，需要灵活扩展的场景</li>
</ul>
<p><strong>链栈的基本结构：</strong></p>
<ul>
<li>单链表节点：包含数据域和指针域</li>
<li>栈顶指针：指向链表头节点，作为栈的唯一访问点</li>
<li>链表长度：维护栈中元素数量</li>
</ul>
<p><strong>链栈的时间复杂度：</strong></p>
<ul>
<li>入栈（push）：O(1)</li>
<li>出栈（pop）：O(1)</li>
<li>取栈顶元素（getTop）：O(1)</li>
<li>判空（isEmpty）：O(1)</li>
<li>获取长度（getLength）：O(1)</li>
</ul>
<p><strong>顺序栈与链栈对比：</strong></p>
<ul>
<li><strong>空间效率：</strong> 顺序栈存储密度高，链栈每个元素需要额外指针空间</li>
<li><strong>时间效率：</strong> 两者基本操作均为O(1)时间复杂度，但链栈需要动态内存分配和释放</li>
<li><strong>实现复杂度：</strong> 顺序栈实现简单，链栈稍复杂</li>
<li><strong>空间限制：</strong> 顺序栈有容量限制，链栈无此限制</li>
<li><strong>内存管理：</strong> 顺序栈内存连续，链栈内存分散</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeqStack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MAX_STACK_SIZE = <span class="number">100</span>;  <span class="comment">// 栈的最大容量</span></span><br><span class="line">    ElemType stack_array[MAX_STACK_SIZE];  <span class="comment">// 存储栈元素的数组</span></span><br><span class="line">    <span class="type">int</span> top;                               <span class="comment">// 栈顶指针（top=-1 表示空栈）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数（初始化空栈）</span></span><br><span class="line">    <span class="built_in">SeqStack</span>() : <span class="built_in">top</span>(<span class="number">-1</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">SeqStack</span>(<span class="type">const</span> SeqStack&amp; other) : <span class="built_in">top</span>(other.top) &#123;</span><br><span class="line">        <span class="comment">// 复制数组内容</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= top; i++) &#123;</span><br><span class="line">            stack_array[i] = other.stack_array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    SeqStack&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SeqStack&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="comment">// 清空当前栈并复制内容</span></span><br><span class="line">            top = other.top;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= top; i++) &#123;</span><br><span class="line">                stack_array[i] = other.stack_array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// C++11 移动构造函数</span></span><br><span class="line">    <span class="built_in">SeqStack</span>(SeqStack&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">top</span>(other.top) &#123;</span><br><span class="line">        <span class="comment">// 直接复制数组内容（对于栈这种静态数组实现，移动和复制区别不大）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= top; i++) &#123;</span><br><span class="line">            stack_array[i] = std::<span class="built_in">move</span>(other.stack_array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重置原栈</span></span><br><span class="line">        other.top = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// C++11 移动赋值运算符</span></span><br><span class="line">    SeqStack&amp; <span class="keyword">operator</span>=(SeqStack&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            top = other.top;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= top; i++) &#123;</span><br><span class="line">                stack_array[i] = std::<span class="built_in">move</span>(other.stack_array[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            other.top = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心接口</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == <span class="number">-1</span>;</span><br><span class="line">    &#125;                  <span class="comment">// 判断栈是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isFull</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == MAX_STACK_SIZE - <span class="number">1</span>;</span><br><span class="line">    &#125;                  <span class="comment">// 判断栈是否满</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(ElemType e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isFull</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">overflow_error</span>(<span class="string">&quot;SeqStack::push: 栈已满，无法压栈&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        stack_array[++top] = e;</span><br><span class="line">    &#125;                 <span class="comment">// 入栈（压栈）</span></span><br><span class="line">    <span class="function">ElemType <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">underflow_error</span>(<span class="string">&quot;SeqStack::pop: 栈为空，无法弹栈&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack_array[top--];</span><br><span class="line">    &#125;                 <span class="comment">// 出栈（弹栈）</span></span><br><span class="line">    <span class="function">ElemType <span class="title">getTop</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">underflow_error</span>(<span class="string">&quot;SeqStack::getTop: 栈为空，无法获取栈顶元素&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack_array[top];</span><br><span class="line">    &#125;                 <span class="comment">// 获取栈顶元素（不弹出）</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getLength</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top + <span class="number">1</span>;</span><br><span class="line">    &#125;                 <span class="comment">// 获取栈中元素个数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清空栈</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        top = <span class="number">-1</span>;  <span class="comment">// 简单地将栈顶指针重置为-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印栈内容（调试用）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printStack</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;SeqStack is empty&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;SeqStack: [&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= top; i++) &#123;</span><br><span class="line">            cout &lt;&lt; stack_array[i];</span><br><span class="line">            <span class="keyword">if</span> (i &lt; top) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;] (top: &quot;</span> &lt;&lt; stack_array[top] &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkStack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 链栈结点（内部嵌套类）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">StackNode</span> &#123;</span><br><span class="line">        ElemType data;</span><br><span class="line">        StackNode* next;</span><br><span class="line">        <span class="comment">// 结点构造函数</span></span><br><span class="line">        <span class="built_in">StackNode</span>(ElemType val = <span class="number">0</span>, StackNode* nxt = <span class="literal">nullptr</span>)</span><br><span class="line">                : <span class="built_in">data</span>(val), <span class="built_in">next</span>(nxt) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    StackNode* top;  <span class="comment">// 栈顶指针（兼作头指针，无额外头结点）</span></span><br><span class="line">    <span class="type">int</span> length;      <span class="comment">// 栈长（直接维护，避免遍历）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数（初始化空栈）</span></span><br><span class="line">    <span class="built_in">LinkStack</span>() : <span class="built_in">top</span>(<span class="literal">nullptr</span>), <span class="built_in">length</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拷贝构造函数（深拷贝）</span></span><br><span class="line">    <span class="built_in">LinkStack</span>(<span class="type">const</span> LinkStack&amp; other) : <span class="built_in">top</span>(<span class="literal">nullptr</span>), <span class="built_in">length</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!other.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 创建新链表，采用尾插法（避免栈顺序颠倒）</span></span><br><span class="line">            StackNode* pOther = other.top;</span><br><span class="line">            StackNode* tempStack = <span class="literal">nullptr</span>;  <span class="comment">// 临时栈，用于反转节点顺序</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 先将原栈内容复制到临时栈（会反转顺序）</span></span><br><span class="line">            <span class="keyword">while</span> (pOther != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                tempStack = <span class="keyword">new</span> <span class="built_in">StackNode</span>(pOther-&gt;data, tempStack);</span><br><span class="line">                pOther = pOther-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 再从临时栈复制回目标栈（恢复原顺序）</span></span><br><span class="line">            StackNode* pTemp = tempStack;</span><br><span class="line">            StackNode** pDest = &amp;top;  <span class="comment">// 使用二级指针简化头插法实现</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (pTemp != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                *pDest = <span class="keyword">new</span> <span class="built_in">StackNode</span>(pTemp-&gt;data);</span><br><span class="line">                pDest = &amp;((*pDest)-&gt;next);</span><br><span class="line">                pTemp = pTemp-&gt;next;</span><br><span class="line">                length++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 清理临时栈</span></span><br><span class="line">            <span class="keyword">while</span> (tempStack != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                StackNode* temp = tempStack;</span><br><span class="line">                tempStack = tempStack-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    LinkStack&amp; <span class="keyword">operator</span>=(<span class="type">const</span> LinkStack&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="comment">// 清空当前栈</span></span><br><span class="line">            <span class="keyword">while</span> (top != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                StackNode* temp = top;</span><br><span class="line">                top = top-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">            length = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 复制其他栈的内容</span></span><br><span class="line">            <span class="keyword">if</span> (!other.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">                StackNode* pOther = other.top;</span><br><span class="line">                StackNode* tempStack = <span class="literal">nullptr</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 先复制到临时栈</span></span><br><span class="line">                <span class="keyword">while</span> (pOther != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    tempStack = <span class="keyword">new</span> <span class="built_in">StackNode</span>(pOther-&gt;data, tempStack);</span><br><span class="line">                    pOther = pOther-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 再复制回目标栈</span></span><br><span class="line">                StackNode* pTemp = tempStack;</span><br><span class="line">                StackNode** pDest = &amp;top;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span> (pTemp != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    *pDest = <span class="keyword">new</span> <span class="built_in">StackNode</span>(pTemp-&gt;data);</span><br><span class="line">                    pDest = &amp;((*pDest)-&gt;next);</span><br><span class="line">                    pTemp = pTemp-&gt;next;</span><br><span class="line">                    length++;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 清理临时栈</span></span><br><span class="line">                <span class="keyword">while</span> (tempStack != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    StackNode* temp = tempStack;</span><br><span class="line">                    tempStack = tempStack-&gt;next;</span><br><span class="line">                    <span class="keyword">delete</span> temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// C++11 移动构造函数</span></span><br><span class="line">    <span class="built_in">LinkStack</span>(LinkStack&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">top</span>(other.top), <span class="built_in">length</span>(other.length) &#123;</span><br><span class="line">        <span class="comment">// 转移资源所有权</span></span><br><span class="line">        other.top = <span class="literal">nullptr</span>;</span><br><span class="line">        other.length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// C++11 移动赋值运算符</span></span><br><span class="line">    LinkStack&amp; <span class="keyword">operator</span>=(LinkStack&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="comment">// 释放当前资源</span></span><br><span class="line">            <span class="keyword">while</span> (top != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                StackNode* temp = top;</span><br><span class="line">                top = top-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 转移资源所有权</span></span><br><span class="line">            top = other.top;</span><br><span class="line">            length = other.length;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 重置原对象</span></span><br><span class="line">            other.top = <span class="literal">nullptr</span>;</span><br><span class="line">            other.length = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数（释放所有结点）</span></span><br><span class="line">    ~<span class="built_in">LinkStack</span>() &#123;</span><br><span class="line">        <span class="keyword">while</span> (top != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            StackNode* temp = top;</span><br><span class="line">            top = top-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心接口</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;                  <span class="comment">// 判断栈是否为空</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(ElemType e)</span> </span>&#123;</span><br><span class="line">        top = <span class="keyword">new</span> <span class="built_in">StackNode</span>(e, top);</span><br><span class="line">        length++;</span><br><span class="line">    &#125;                  <span class="comment">// 入栈</span></span><br><span class="line">    <span class="function">ElemType <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">underflow_error</span>(<span class="string">&quot;LinkStack::pop: 栈为空，无法弹栈&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ElemType poppedVal = top-&gt;data;</span><br><span class="line">        StackNode* temp = top;</span><br><span class="line">        top = top-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        length--;</span><br><span class="line">        <span class="keyword">return</span> poppedVal;</span><br><span class="line">    &#125;                 <span class="comment">// 出栈</span></span><br><span class="line">    <span class="function">ElemType <span class="title">getTop</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">underflow_error</span>(<span class="string">&quot;LinkStack::getTop: 栈为空，无法获取栈顶元素&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> top-&gt;data;</span><br><span class="line">    &#125;                 <span class="comment">// 获取栈顶元素（不弹出）</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getLength</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;                 <span class="comment">// 获取栈长</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清空栈</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (top != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            StackNode* temp = top;</span><br><span class="line">            top = top-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印栈内容（调试用）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printStack</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;LinkStack is empty&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;LinkStack: [&quot;</span>;</span><br><span class="line">        StackNode* p = top;</span><br><span class="line">        <span class="comment">// 使用临时数组存储，以便按正确顺序显示</span></span><br><span class="line">        vector&lt;ElemType&gt; elements;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            elements.<span class="built_in">push_back</span>(p-&gt;data);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 逆序输出，以匹配栈的逻辑顺序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = elements.<span class="built_in">rbegin</span>(); it != elements.<span class="built_in">rend</span>(); ++it) &#123;</span><br><span class="line">            cout &lt;&lt; *it;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">next</span>(it) != elements.<span class="built_in">rend</span>()) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;] (top: &quot;</span> &lt;&lt; top-&gt;data &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="5-队列的实现（顺序存储和链式存储）">5, 队列的实现（顺序存储和链式存储）</h3>
<h4 id="链式队列（LinkQueue）">链式队列（LinkQueue）</h4>
<p>链式队列是队列的链式存储实现，通过单链表结构存储队列元素，避免了顺序队列的容量限制问题。</p>
<p><strong>工作原理：</strong></p>
<ul>
<li>使用带头结点的单链表实现</li>
<li>队首指针（front）指向头结点</li>
<li>队尾指针（rear）指向队尾元素</li>
<li>入队操作：在队尾（rear）后添加新结点</li>
<li>出队操作：删除队首（front-&gt;next）结点</li>
<li>队列为空的判断条件：front == rear</li>
</ul>
<p><strong>时间复杂度分析：</strong></p>
<ul>
<li>入队（enQueue）：O(1)</li>
<li>出队（deQueue）：O(1)</li>
<li>获取队首元素（getHead）：O(1)</li>
<li>判断队列空（isEmpty）：O(1)</li>
<li>获取队列长度（getLength）：O(1)</li>
</ul>
<p><strong>优缺点：</strong></p>
<ul>
<li><strong>优点</strong>：动态分配空间，不需要预先确定容量，不会出现假溢出问题</li>
<li><strong>缺点</strong>：每个元素需要额外的空间存储指针，空间利用率相对较低</li>
</ul>
<p><strong>应用场景：</strong></p>
<ul>
<li>元素数量不确定的队列应用</li>
<li>频繁进行入队出队操作的场景</li>
<li>需要避免空间浪费的场合</li>
</ul>
<p><strong>使用示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircularQueue</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MAX_QUEUE_SIZE = <span class="number">100</span>;  <span class="comment">// 队列的最大容量</span></span><br><span class="line">    ElemType queue_array[MAX_QUEUE_SIZE];  <span class="comment">// 存储队列元素的数组</span></span><br><span class="line">    <span class="type">int</span> front;                             <span class="comment">// 队首指针（指向队首元素前一个位置）</span></span><br><span class="line">    <span class="type">int</span> rear;                              <span class="comment">// 队尾指针（指向队尾元素）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数（初始化空队列）</span></span><br><span class="line">    <span class="built_in">CircularQueue</span>() : <span class="built_in">front</span>(<span class="number">0</span>), <span class="built_in">rear</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心接口</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> front == rear;</span><br><span class="line">    &#125;                  <span class="comment">// 判断队列是否为空（front == rear）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isFull</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (rear + <span class="number">1</span>) % MAX_QUEUE_SIZE == front;</span><br><span class="line">    &#125;                  <span class="comment">// 判断队列是否满（(rear+1)%MAX_QUEUE_SIZE == front）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enQueue</span><span class="params">(ElemType e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isFull</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">overflow_error</span>(<span class="string">&quot;CircularQueue::enQueue: 队列已满，无法入队&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        rear = (rear + <span class="number">1</span>) % MAX_QUEUE_SIZE;</span><br><span class="line">        queue_array[rear] = e;</span><br><span class="line">    &#125;               <span class="comment">// 入队（队尾插入）</span></span><br><span class="line">    <span class="function">ElemType <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">underflow_error</span>(<span class="string">&quot;CircularQueue::deQueue: 队列为空，无法出队&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ElemType dequeuedVal = queue_array[(front + <span class="number">1</span>)%MAX_QUEUE_SIZE];</span><br><span class="line">        front = (front + <span class="number">1</span>) % MAX_QUEUE_SIZE;</span><br><span class="line">        <span class="keyword">return</span> dequeuedVal;</span><br><span class="line">    &#125;              <span class="comment">// 出队（队首删除）</span></span><br><span class="line">    <span class="function">ElemType <span class="title">getHead</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">underflow_error</span>(<span class="string">&quot;CircularQueue::getHead: 队列为空，无法获取队首元素&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 修正：直接返回，无需临时变量e</span></span><br><span class="line">        <span class="keyword">return</span> queue_array[(front + <span class="number">1</span>) % MAX_QUEUE_SIZE];</span><br><span class="line">    &#125;       <span class="comment">// 获取队首元素（不删除）</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getLength</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (rear - front + MAX_QUEUE_SIZE) % MAX_QUEUE_SIZE;</span><br><span class="line">    &#125;                 <span class="comment">// 获取队列长度</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkQueue</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 链队列结点（内部嵌套类）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">QNode</span> &#123;</span><br><span class="line">        ElemType data;</span><br><span class="line">        QNode* next;</span><br><span class="line">        <span class="comment">// 结点构造函数</span></span><br><span class="line">        <span class="built_in">QNode</span>(ElemType val = <span class="number">0</span>, QNode* nxt = <span class="literal">nullptr</span>)</span><br><span class="line">                : <span class="built_in">data</span>(val), <span class="built_in">next</span>(nxt) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    QNode* front;  <span class="comment">// 队首指针（指向头结点）</span></span><br><span class="line">    QNode* rear;   <span class="comment">// 队尾指针（指向队尾元素）</span></span><br><span class="line">    <span class="type">int</span> length;    <span class="comment">// 队列长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数（初始化空队列，创建头结点）</span></span><br><span class="line">    <span class="built_in">LinkQueue</span>() &#123;</span><br><span class="line">        front = rear = <span class="keyword">new</span> <span class="built_in">QNode</span>();</span><br><span class="line">        front-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数（释放所有结点）</span></span><br><span class="line">    ~<span class="built_in">LinkQueue</span>() &#123;</span><br><span class="line">        <span class="keyword">while</span> (front != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            QNode* temp = front;</span><br><span class="line">            front = front-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心接口</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> front == rear;</span><br><span class="line">    &#125;                 <span class="comment">// 判断队列是否为空</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enQueue</span><span class="params">(ElemType e)</span> </span>&#123;</span><br><span class="line">        rear-&gt;next = <span class="keyword">new</span> <span class="built_in">QNode</span>(e);</span><br><span class="line">        rear = rear-&gt;next;</span><br><span class="line">        length++;</span><br><span class="line">    &#125;               <span class="comment">// 入队</span></span><br><span class="line">    <span class="function">ElemType <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">underflow_error</span>(<span class="string">&quot;LinkQueue::deQueue: 队列为空，无法出队&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ElemType dequeuedVal = front-&gt;next-&gt;data;</span><br><span class="line">        QNode* temp = front-&gt;next;</span><br><span class="line">        front-&gt;next = temp-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (rear == temp) &#123;</span><br><span class="line">            rear = front;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        length--;</span><br><span class="line">        <span class="keyword">return</span> dequeuedVal;</span><br><span class="line">    &#125;             <span class="comment">// 出队</span></span><br><span class="line">    <span class="function">ElemType <span class="title">getHead</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">underflow_error</span>(<span class="string">&quot;LinkQueue::getHead: 队列为空，无法获取队首元素&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> front-&gt;next-&gt;data;</span><br><span class="line">    &#125;        <span class="comment">// 获取队首元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getLength</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;                 <span class="comment">// 获取队列长度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="6-字符串类（String）">6, 字符串类（String）</h3>
<h4 id="1-定长字符串（FixedString）核心理论">1. 定长字符串（FixedString）核心理论</h4>
<h5 id="（1）数据结构本质">（1）数据结构本质</h5>
<p>采用<strong>静态字符数组</strong>作为底层存储载体，属于<strong>顺序存储结构</strong>的典型实现，串的字符元素在内存中连续存放，物理地址与逻辑顺序完全一致。</p>
<h5 id="（2）核心特性">（2）核心特性</h5>
<ul>
<li>存储容量<strong>编译期固定</strong>，由预设的最大串长常量限制，运行过程中无法扩容；</li>
<li>实际串长与底层数组空间相互独立，通过成员变量单独记录有效字符长度，避免遍历数组判断长度的性能损耗；</li>
<li>内存分配在<strong>栈区</strong>完成，生命周期由作用域控制，无需手动管理内存，访问效率高但空间灵活性差。</li>
</ul>
<h5 id="（3）核心操作理论支撑">（3）核心操作理论支撑</h5>
<ol>
<li>赋值操作：需严格校验源字符串长度，避免超出数组最大容量导致<strong>内存越界</strong>，本质是字符数组的逐字符拷贝；</li>
<li>串连接操作：核心约束为「原串长度 + 待拼接串长度 ≤ 最大串长」，本质是在原串有效字符末尾追加新字符，同步更新实际长度；</li>
<li>子串提取：核心是<strong>区间合法性校验</strong>（起始位置非负、长度非负、区间不超原串边界），本质是从指定起始地址开始的定长字符拷贝，需手动补充字符串结束符保证语法合规；</li>
<li>BF 模式匹配：属于<strong>暴力匹配算法</strong>，核心思想是主串从起始位置开始，与模式串逐字符比对，匹配失败则主串回溯、模式串复位，最坏时间复杂度 O(n \times m)（n 为主串长度，m 为模式串长度），优点是逻辑简单、实现成本低，缺点是存在大量无效回溯，效率较低。</li>
</ol>
<h4 id="2-堆字符串（HeapString）核心理论">2. 堆字符串（HeapString）核心理论</h4>
<h5 id="（1）数据结构本质-2">（1）数据结构本质</h5>
<p>采用<strong>动态字符指针</strong>作为底层存储载体，仍属于<strong>顺序存储结构</strong>，字符元素连续存放，区别在于存储载体的内存分配方式不同。</p>
<h5 id="（2）核心特性-2">（2）核心特性</h5>
<ul>
<li>存储容量<strong>运行期动态调整</strong>，可根据串的实际长度按需分配内存，完全适配数据规模，无空间浪费；</li>
<li>内存分配在<strong>堆区</strong>完成，生命周期由程序员通过构造/析构函数控制，需手动完成内存申请与释放，空间灵活性极强，访问效率与定长串一致；</li>
<li>存在<strong>内存泄漏风险</strong>，必须通过析构函数释放堆区内存，同时遵循「赋值/拼接操作先释放旧内存、再分配新内存」的原则，避免内存碎片。</li>
</ul>
<h5 id="（3）核心操作理论支撑-2">（3）核心操作理论支撑</h5>
<ol>
<li>赋值操作：核心是<strong>动态内存重分配</strong>，先释放当前指针指向的旧堆内存，再根据源字符串长度申请新内存，最后完成字符拷贝，保证内存空间与有效字符完全匹配；</li>
<li>串连接操作：本质是「扩容 + 拼接」两步走，申请「原串长度 + 待拼接串长度 + 1」的新内存（预留结束符空间），先拷贝原串、再追加拼接串，释放旧内存后完成指针重定向，同步更新实际长度；</li>
<li>子串提取：与定长串逻辑一致，区别在于子串的底层内存为堆区动态分配，需单独管理子串对象的内存生命周期；</li>
<li>KMP 模式匹配：核心是<strong>消除主串回溯</strong>，通过预处理模式串生成 <code>next</code> 数组，匹配失败时仅复位模式串、主串持续向后遍历，时间复杂度优化至 O(n + m)（最优/最坏复杂度一致），效率远高于 BF 算法；</li>
<li>next 数组核心原理：<code>next[i]</code> 表示模式串第 i 个位置之前的子串中，<strong>最长相等前后缀</strong>的长度，其作用是匹配失败时，指导模式串快速回退至最优比对位置，避免无效的字符重复比对。</li>
</ol>
<h5 id="（4）定长串与堆串核心对比">（4）定长串与堆串核心对比</h5>
<ul>
<li>空间维度：定长串空间固定、易浪费/溢出，堆串按需分配、空间利用率100%；</li>
<li>内存维度：定长串栈区存储、无需手动管理，堆串堆区存储、需严格把控内存释放；</li>
<li>适用场景：定长串适用于字符长度已知且固定的场景，堆串适用于字符长度不确定、需动态扩容的场景。</li>
</ul>
<h4 id="3-字符串通用核心理论（两类串共性）">3. 字符串通用核心理论（两类串共性）</h4>
<ol>
<li>串的<strong>逻辑定义</strong>：由零个或多个字符组成的有限序列，空串的有效长度为0，需通过结束符标识边界；</li>
<li>串与字符数组的区别：字符数组是存储字符的容器，串是基于字符数组的<strong>数据抽象</strong>，包含「存储载体 + 有效长度 + 操作接口」三层内涵；</li>
<li>串操作的核心约束：所有操作均需保证<strong>下标合法</strong>、<strong>长度合法</strong>，避免越界访问与无效数据操作。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_STRLEN = <span class="number">100</span>;  <span class="comment">// 定义最大串长（可根据需要调整）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FixedString</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> str[MAX_STRLEN];  <span class="comment">// 存储串的字符数组</span></span><br><span class="line">    <span class="type">int</span> length;                <span class="comment">// 串的实际长度（不含结束符）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数（初始化空串）</span></span><br><span class="line">    <span class="built_in">FixedString</span>() : <span class="built_in">length</span>(<span class="number">0</span>) &#123; str[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心接口</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length == <span class="number">0</span>;</span><br><span class="line">    &#125;                                  <span class="comment">// 判断串是否为空</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getLength</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;                                 <span class="comment">// 获取串长</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strAssign</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* chars)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(chars) &gt;= MAX_STRLEN) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;FixedString::strAssign: 输入字符串长度超过最大限制&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">strcpy</span>(str, chars);</span><br><span class="line">        length = <span class="built_in">strlen</span>(chars);</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;                        <span class="comment">// 赋值（chars为字符串常量）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">strConcat</span><span class="params">(<span class="type">const</span> FixedString&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (length + s.<span class="built_in">getLength</span>() &gt;= MAX_STRLEN) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">overflow_error</span>(<span class="string">&quot;FixedString::strConcat: 连接后字符串长度超过最大限制&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">strcat</span>(str, s.str);</span><br><span class="line">        length += s.<span class="built_in">getLength</span>();</span><br><span class="line">    &#125;                   <span class="comment">// 串连接（将s连接到当前串末尾）</span></span><br><span class="line">    <span class="function">FixedString <span class="title">subString</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> len)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; <span class="number">0</span> || pos &gt;= length || len &lt; <span class="number">0</span> || pos + len &gt; length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;FixedString::subString: 子串位置或长度无效&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        FixedString sub;</span><br><span class="line">        <span class="built_in">strncpy</span>(sub.str, str + pos, len);</span><br><span class="line">        sub.length = len;</span><br><span class="line">        sub.str[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> sub;</span><br><span class="line">    &#125; <span class="comment">// 求子串（从pos位置取len个字符）</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">index</span><span class="params">(<span class="type">const</span> FixedString&amp; pattern)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pattern.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;FixedString::index: 模式串为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= length - pattern.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strncmp</span>(str + i, pattern.str, pattern.length) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;           <span class="comment">// 模式匹配（朴素BF算法）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        length = <span class="number">0</span>;</span><br><span class="line">        str[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;                                          <span class="comment">// 清空串</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeapString</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* ch;  <span class="comment">// 动态分配的字符数组指针</span></span><br><span class="line">    <span class="type">int</span> length;    <span class="comment">// 串的实际长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数（初始化空串）</span></span><br><span class="line">    <span class="built_in">HeapString</span>() : <span class="built_in">ch</span>(<span class="literal">nullptr</span>), <span class="built_in">length</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数（释放动态内存）</span></span><br><span class="line">    ~<span class="built_in">HeapString</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] ch;</span><br><span class="line">            ch = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心接口</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length == <span class="number">0</span>;</span><br><span class="line">    &#125;                                  <span class="comment">// 判断串是否为空</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getLength</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">getCh</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ch; &#125;  <span class="comment">// 获取字符数组指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取串长</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">strAssign</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* chars)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ch != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] ch;</span><br><span class="line">        &#125;</span><br><span class="line">        length = <span class="built_in">strlen</span>(chars);</span><br><span class="line">        ch = <span class="keyword">new</span> <span class="type">char</span>[length + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(ch, chars);</span><br><span class="line">    &#125;                  <span class="comment">// 赋值（动态分配内存）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">strConcat</span><span class="params">(<span class="type">const</span> HeapString&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ch = <span class="keyword">new</span> <span class="type">char</span>[length + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(ch, s.<span class="built_in">getCh</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">char</span>* temp = <span class="keyword">new</span> <span class="type">char</span>[length + s.length + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(temp, ch);</span><br><span class="line">            <span class="built_in">strcat</span>(temp, s.<span class="built_in">getCh</span>());</span><br><span class="line">            <span class="keyword">delete</span>[] ch;</span><br><span class="line">            ch = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        length += s.length;</span><br><span class="line">    &#125;                   <span class="comment">// 串连接</span></span><br><span class="line">    <span class="function">HeapString <span class="title">subString</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> len)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; <span class="number">0</span> || pos &gt;= length || len &lt; <span class="number">0</span> || pos + len &gt; length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;HeapString::subString: 子串位置或长度无效&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        HeapString sub;</span><br><span class="line">        sub.ch = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>]; <span class="comment">// 分配len+1空间（含结束符）</span></span><br><span class="line">        <span class="built_in">strncpy</span>(sub.ch, ch + pos, len);</span><br><span class="line">        sub.ch[len] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 手动添加结束符</span></span><br><span class="line">        sub.length = len;</span><br><span class="line">        <span class="keyword">return</span> sub;</span><br><span class="line">    &#125; <span class="comment">// 求子串</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">indexKMP</span><span class="params">(<span class="type">const</span> HeapString&amp; pattern)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(pattern.getLength(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">char</span> *p = pattern.<span class="built_in">getCh</span>();</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;pattern.<span class="built_in">getLength</span>();++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j&gt;<span class="number">0</span> &amp;&amp; p[i]!=p[j]) &#123;</span><br><span class="line">                j=next[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p[i]==p[j]) &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i]=j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;length;++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j&gt;<span class="number">0</span> &amp;&amp; ch[i]!=p[j]) &#123;</span><br><span class="line">                j=next[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ch[i]==p[j]) &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j==pattern.<span class="built_in">getLength</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> i-j<span class="number">+1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;         <span class="comment">// 模式匹配（KMP算法）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeNext</span><span class="params">(<span class="type">const</span> HeapString&amp; pattern, <span class="type">int</span>* next)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">char</span>* p = pattern.<span class="built_in">getCh</span>();</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 第一个位置next值固定为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; pattern.<span class="built_in">getLength</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; p[i] != p[j]) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p[i] == p[j]) &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">// 生成KMP算法的next数组</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="7-二维数组类（TwoDArray）">7, 二维数组类（TwoDArray）</h3>
<h4 id="1-二维数组的存储本质（核心理论）">1. 二维数组的存储本质（核心理论）</h4>
<p>二维数组的<strong>物理存储形态唯一</strong>：计算机底层不存在真正的「二维内存空间」，所有二维数组最终都需映射为<strong>一维连续内存</strong>存储，本类的核心就是实现「二维逻辑结构 → 一维物理结构」的映射转换，属于<strong>顺序存储结构</strong>在多维数据中的扩展应用。</p>
<h4 id="2-两种核心存储映射规则（数组寻址理论）">2. 两种核心存储映射规则（数组寻址理论）</h4>
<h5 id="（1）行优先存储（Row-Major-Order）">（1）行优先存储（Row-Major Order）</h5>
<h6 id="核心规则">核心规则</h6>
<p>按<strong>行序为主、列序为辅</strong>的顺序存放元素，即先完整存放第 0 行的所有列元素，再存放第 1 行的所有列元素，以此类推，是最常用的存储方式（C/C++、Java 等语言默认采用）。</p>
<h6 id="寻址公式（核心）">寻址公式（核心）</h6>
<p>对于 rows 行 cols 列的二维数组，逻辑下标 (i,j) 映射到一维数组的物理下标为<br>
物理下标 = i * cols + j</p>
<h6 id="理论特点">理论特点</h6>
<ul>
<li>同一行的元素在一维数组中连续存放，行内元素访问的局部性好，缓存命中率高；</li>
<li>行索引 i 决定元素所在的「行块起始位置」，列索引 j 决定行块内的偏移量。</li>
</ul>
<h5 id="（2）列优先存储（Column-Major-Order）">（2）列优先存储（Column-Major Order）</h5>
<h6 id="核心规则-2">核心规则</h6>
<p>按<strong>列序为主、行序为辅</strong>的顺序存放元素，即先完整存放第 0 列的所有行元素，再存放第 1 列的所有行元素，以此类推（Fortran 语言默认采用）。</p>
<h6 id="寻址公式（核心）-2">寻址公式（核心）</h6>
<p>对于 rows 行 cols 列的二维数组，逻辑下标 (i,j) 映射到一维数组的物理下标为<br>
物理下标 = j * rows + i</p>
<h6 id="理论特点-2">理论特点</h6>
<ul>
<li>同一列的元素在一维数组中连续存放，适合以列为单位的批量数据操作；</li>
<li>列索引 j 决定元素所在的「列块起始位置」，行索引 i 决定列块内的偏移量。</li>
</ul>
<h4 id="3-模板化二维数组核心特性">3. 模板化二维数组核心特性</h4>
<h5 id="（1）数据类型无关性">（1）数据类型无关性</h5>
<p>基于<strong>模板编程思想</strong>实现，底层存储与数据元素类型解耦，可适配任意基础类型（int、float、char）与自定义类型，满足通用化数据存储需求，遵循「一次定义、多类型复用」原则。</p>
<h5 id="（2）内存管理理论">（2）内存管理理论</h5>
<ul>
<li>底层通过<strong>一维动态数组</strong>实现，堆区内存分配大小为 rows \times cols \times \text{单个元素字节数}，内存连续且可按需调整行列规模；</li>
<li>析构函数统一释放堆区内存，避免内存泄漏，内存生命周期由对象实例控制，支持运行期动态指定行列数。</li>
</ul>
<h4 id="4-核心操作理论约束">4. 核心操作理论约束</h4>
<ol>
<li>元素访问（取值/赋值）：核心前提是<strong>下标合法性校验</strong>，行索引 i 需满足 0 ≤ i &lt; rows，列索引 j 需满足 0 ≤ j &lt; cols，否则触发越界错误，本质是通过寻址公式完成「二维逻辑下标 → 一维物理下标」的转换，再执行内存读写；</li>
<li>存储顺序不可变性：行优先/列优先的存储规则在对象构造时确定，运行过程中不可修改，保证数组存储结构的一致性；</li>
<li>空间效率特性：无冗余存储，底层一维数组的空间大小与二维数组的元素总数完全匹配，空间利用率为 100%。</li>
</ol>
<h4 id="5-二维数组顺序存储的通用优缺点">5. 二维数组顺序存储的通用优缺点</h4>
<h5 id="优点">优点</h5>
<ol>
<li>元素物理连续，支持<strong>随机访问</strong>，通过寻址公式可在 O(1) 时间内定位任意位置元素；</li>
<li>内存管理简单，仅需维护一个一维动态数组的指针，无额外空间开销；</li>
<li>缓存友好性强，连续的内存访问可充分利用 CPU 缓存，提升数据读写效率。</li>
</ol>
<h5 id="缺点">缺点</h5>
<ol>
<li>行列规模确定后，动态扩容成本较高（需重新分配更大内存并完成元素拷贝）；</li>
<li>仅适用于<strong>规整的二维数据</strong>，对稀疏矩阵等非规整多维数据，存在大量空间浪费。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TwoDArray</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ElemType* data;  <span class="comment">// 动态分配的一维数组（模拟二维数组）</span></span><br><span class="line">    <span class="type">int</span> rows;        <span class="comment">// 数组行数</span></span><br><span class="line">    <span class="type">int</span> cols;        <span class="comment">// 数组列数</span></span><br><span class="line">    <span class="type">bool</span> rowMajor;   <span class="comment">// 存储顺序：true=行优先，false=列优先</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数（初始化rows行cols列的二维数组）</span></span><br><span class="line">    <span class="built_in">TwoDArray</span>(<span class="type">int</span> r, <span class="type">int</span> c, <span class="type">bool</span> rowMajor = <span class="literal">true</span>) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> ElemType[r * c];</span><br><span class="line">        rows = r;</span><br><span class="line">        cols = c;</span><br><span class="line">        <span class="keyword">this</span>-&gt;rowMajor = rowMajor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数（释放动态内存）</span></span><br><span class="line">    ~<span class="built_in">TwoDArray</span>() &#123; <span class="keyword">delete</span>[] data; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心接口</span></span><br><span class="line">    <span class="function">ElemType <span class="title">getElem</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= rows || j &lt; <span class="number">0</span> || j &gt;= cols) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;TwoDArray::getElem: 索引超出范围&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ElemType e;</span><br><span class="line">        <span class="keyword">if</span> (rowMajor) &#123;</span><br><span class="line">            e = data[i * cols + j];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            e = data[j * rows + i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;  <span class="comment">// 获取(i,j)位置的元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setElem</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, ElemType e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= rows || j &lt; <span class="number">0</span> || j &gt;= cols) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;TwoDArray::setElem: 索引超出范围&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rowMajor) &#123;</span><br><span class="line">            data[i * cols + j] = e;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            data[j * rows + i] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;         <span class="comment">// 设置(i,j)位置的元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getRows</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rows; &#125;                            <span class="comment">// 获取行数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getCols</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> cols; &#125;                            <span class="comment">// 获取列数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="8-稀疏矩阵类（SparseMatrix）">8, 稀疏矩阵类（SparseMatrix）</h3>
<h5 id="（1）存储结构">（1）存储结构</h5>
<ul>
<li><strong>三元组数组</strong>：存储非零元素的行、列、值三元组，按行优先顺序排序，支持快速随机访问。</li>
<li><strong>行/列指针数组</strong>：记录每一行/列的第一个非零元素在三元组数组中的索引，支持快速定位行/列的非零元素范围。</li>
</ul>
<h5 id="（2）核心操作">（2）核心操作</h5>
<ul>
<li><strong>插入/更新非零元素</strong>：根据三元组数组中的排序规则，插入或更新指定位置的元素，保持三元组数组的有序性。</li>
<li><strong>矩阵转置</strong>：通过行/列指针数组和三元组数组，实现稀疏矩阵的转置操作，时间复杂度为 O(tu)。</li>
<li><strong>矩阵乘法</strong>：通过行/列指针数组和三元组数组，实现稀疏矩阵与另一个稀疏矩阵的乘法操作，时间复杂度为 O(tu * v)。</li>
</ul>
<h5 id="（3）适用场景">（3）适用场景</h5>
<ul>
<li><strong>稀疏矩阵</strong>：适用于存储和操作稀疏矩阵，如科学计算、图像处理等领域。</li>
<li><strong>矩阵运算</strong>：适用于矩阵乘法、矩阵转置等矩阵运算操作。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TRIPLE 1000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SparseMatrix</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 三元组结构体（存储非零元素：行、列、值）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Triple</span> &#123;</span><br><span class="line">        <span class="type">int</span> i;          <span class="comment">// 行号（从1开始）</span></span><br><span class="line">        <span class="type">int</span> j;          <span class="comment">// 列号（从1开始）</span></span><br><span class="line">        ElemType e;     <span class="comment">// 非零元素值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载比较运算符，方便排序（按行优先，行相同按列）</span></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Triple&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (i &lt; other.i) || (i == other.i &amp;&amp; j &lt; other.j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Triple data[MAX_TRIPLE];  <span class="comment">// 存储非零元素的三元组数组</span></span><br><span class="line">    <span class="type">int</span> mu;                   <span class="comment">// 矩阵行数</span></span><br><span class="line">    <span class="type">int</span> nu;                   <span class="comment">// 矩阵列数</span></span><br><span class="line">    <span class="type">int</span> tu;                   <span class="comment">// 非零元素个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有：对三元组数组按行优先排序（提取为函数，避免重复代码）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sortTriples</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tu &lt;= <span class="number">0</span>) <span class="keyword">return</span>;  <span class="comment">// 空矩阵无需排序</span></span><br><span class="line">        <span class="comment">// 数组排序：data[0] 到 data[tu-1]</span></span><br><span class="line">        std::<span class="built_in">sort</span>(data, data + tu, [](<span class="type">const</span> Triple&amp; a, <span class="type">const</span> Triple&amp; b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a &lt; b;  <span class="comment">// 复用重载的&lt;运算符</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数（初始化空稀疏矩阵）</span></span><br><span class="line">    <span class="built_in">SparseMatrix</span>() : <span class="built_in">mu</span>(<span class="number">0</span>), <span class="built_in">nu</span>(<span class="number">0</span>), <span class="built_in">tu</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化矩阵规模（m行n列）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initMatrix</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m &lt;= <span class="number">0</span> || n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;矩阵行列数必须为正！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mu = m;</span><br><span class="line">        nu = n;</span><br><span class="line">        tu = <span class="number">0</span>;  <span class="comment">// 重置非零元素个数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入/更新非零元素（i,j位置，行/列从1开始）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insertElem</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, ElemType e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 边界检查</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; mu || j &lt; <span class="number">1</span> || j &gt; nu) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;行/列越界！i=&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, j=&quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot; (max: &quot;</span> &lt;&lt; mu &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; nu &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 查找元素位置</span></span><br><span class="line">        <span class="type">int</span> k = <span class="built_in">find</span>(i, j);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 存在则更新，不存在则插入（需检查是否超出最大容量）</span></span><br><span class="line">        <span class="keyword">if</span> (k != <span class="number">-1</span>) &#123;</span><br><span class="line">            data[k].e = e;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (tu &gt;= MAX_TRIPLE) &#123;</span><br><span class="line">                std::cerr &lt;&lt; <span class="string">&quot;非零元素个数超出最大容量！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            data[tu].i = i;</span><br><span class="line">            data[tu].j = j;</span><br><span class="line">            data[tu].e = e;</span><br><span class="line">            tu++;  <span class="comment">// 非零数+1</span></span><br><span class="line">            <span class="built_in">sortTriples</span>();  <span class="comment">// 插入后保持有序（保证二分查找有效）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通转置（时间复杂度O(tu*log(tu))，主要耗时在排序）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">transpose</span><span class="params">(SparseMatrix&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化结果矩阵的规模</span></span><br><span class="line">        res.<span class="built_in">initMatrix</span>(nu, mu);  <span class="comment">// 原列数→行数，原行数→列数</span></span><br><span class="line">        res.tu = tu;             <span class="comment">// 非零元素个数不变</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 复制并交换行列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tu; ++i) &#123;</span><br><span class="line">            res.data[i].i = data[i].j;</span><br><span class="line">            res.data[i].j = data[i].i;</span><br><span class="line">            res.data[i].e = data[i].e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转置后重新排序（保证行优先）</span></span><br><span class="line">        res.<span class="built_in">sortTriples</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快速转置（时间复杂度O(nu + tu)，无排序，效率更高）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fastTranspose</span><span class="params">(SparseMatrix&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tu == <span class="number">0</span> || mu == <span class="number">0</span> || nu == <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">initMatrix</span>(nu, mu);</span><br><span class="line">            res.tu = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化结果矩阵</span></span><br><span class="line">        res.<span class="built_in">initMatrix</span>(nu, mu);</span><br><span class="line">        res.tu = tu;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 统计原矩阵每一列的非零元素个数</span></span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">num</span><span class="params">(nu + <span class="number">1</span>, <span class="number">0</span>)</span></span>;  <span class="comment">// num[col] = 原矩阵col列的非零数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tu; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> col = data[i].j;</span><br><span class="line">            num[col]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 计算原矩阵每一列第一个非零元素在结果矩阵中的起始位置</span></span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">cpot</span><span class="params">(nu + <span class="number">1</span>, <span class="number">0</span>)</span></span>;  <span class="comment">// cpot[col] = 原col列第一个元素在res中的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= nu; ++j) &#123;</span><br><span class="line">            cpot[j] = cpot[j - <span class="number">1</span>] + num[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 填充结果矩阵（无需排序，直接按位置填充）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tu; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> col = data[i].j;          <span class="comment">// 原矩阵的列 → 结果矩阵的行</span></span><br><span class="line">            <span class="type">int</span> pos = cpot[col];          <span class="comment">// 该元素在res中的位置</span></span><br><span class="line">            res.data[pos].i = data[i].j;  <span class="comment">// 行列交换</span></span><br><span class="line">            res.data[pos].j = data[i].i;</span><br><span class="line">            res.data[pos].e = data[i].e;</span><br><span class="line">            cpot[col]++;                  <span class="comment">// 下一个同列元素的位置+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取(i,j)位置的元素值（行/列从1开始）</span></span><br><span class="line">    <span class="function">ElemType <span class="title">getElem</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 边界检查</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; mu || j &lt; <span class="number">1</span> || j &gt; nu) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;行/列越界！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">ElemType</span>();  <span class="comment">// 返回类型默认构造值</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找并返回</span></span><br><span class="line">        <span class="type">int</span> k = <span class="built_in">find</span>(i, j);</span><br><span class="line">        <span class="keyword">return</span> (k == <span class="number">-1</span>) ? <span class="built_in">ElemType</span>() : data[k].e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印矩阵（直观展示，按行列展开）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printMatrix</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;稀疏矩阵(&quot;</span> &lt;&lt; mu &lt;&lt; <span class="string">&quot;行×&quot;</span> &lt;&lt; nu &lt;&lt; <span class="string">&quot;列，非零元素数：&quot;</span> &lt;&lt; tu &lt;&lt; <span class="string">&quot;):&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= mu; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= nu; ++j) &#123;</span><br><span class="line">                ElemType val = <span class="built_in">getElem</span>(i, j);</span><br><span class="line">                std::cout &lt;&lt; val &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            std::cout &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印三元组数组（调试用）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printTriples</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;三元组列表（行, 列, 值）：&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tu; ++i) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; data[i].i &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; data[i].j &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; data[i].e &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 二分查找(i,j)位置的元素在三元组数组中的索引（返回-1表示未找到）</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> low = <span class="number">0</span>, high = tu - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (data[mid].i == i &amp;&amp; data[mid].j == j) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;  <span class="comment">// 找到</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data[mid].i &lt; i || (data[mid].i == i &amp;&amp; data[mid].j &lt; j)) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;  <span class="comment">// 目标在右半区</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>; <span class="comment">// 目标在左半区</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 未找到</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="9-广义表（Generalized-List）">9, 广义表（Generalized List）</h3>
<h4 id="1-广义表定义">(1), 广义表定义</h4>
<p>广义表是一种递归定义的数据结构，用于表示层次结构的数据。它由一个表头和一个表尾组成，表头可以是任意数据类型，表尾必须是另一个广义表。广义表可以表示复杂的层次结构，如树、图等。</p>
<h4 id="2-广义表表示">(2), 广义表表示</h4>
<p>广义表通常用括号表示，表头和表尾之间用逗号分隔。例如，(a, (b, c), d) 表示一个广义表，其中 a 是表头，(b, c) 是表尾，d 是另一个表头。</p>
<h4 id="3-广义表操作">(3), 广义表操作</h4>
<ul>
<li>创建：根据括号表示法构建广义表。</li>
<li>插入：在指定位置插入元素或子列表。</li>
<li>删除：从指定位置删除元素或子列表。</li>
<li>查找：按层次结构查找特定元素或子列表。</li>
<li>遍历：递归地访问所有元素和子列表。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GeneralizedList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">GLNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> tag; <span class="comment">// 0 atom, 1 list</span></span><br><span class="line">        <span class="keyword">union</span> &#123;</span><br><span class="line">            <span class="type">char</span> atom;</span><br><span class="line">            vector&lt;GLNode*&gt;* sub;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">GLNode</span>(<span class="type">char</span> c) : <span class="built_in">tag</span>(<span class="number">0</span>), <span class="built_in">atom</span>(c) &#123;&#125;</span><br><span class="line">        <span class="built_in">GLNode</span>() : <span class="built_in">tag</span>(<span class="number">1</span>), <span class="built_in">sub</span>(<span class="keyword">new</span> <span class="built_in">vector</span>&lt;GLNode*&gt;()) &#123;&#125;</span><br><span class="line">        ~<span class="built_in">GLNode</span>() &#123; <span class="keyword">if</span>(tag==<span class="number">1</span>) <span class="keyword">delete</span> sub; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    GLNode* head = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">GeneralizedList</span>()&#123; <span class="built_in">clear</span>(head); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">create</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">clear</span>(head);</span><br><span class="line">        head = <span class="built_in">parse</span>(s, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123; <span class="built_in">print</span>(head);cout&lt;&lt;endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> head &amp;&amp; head-&gt;tag==<span class="number">1</span> ? head-&gt;sub-&gt;<span class="built_in">size</span>() : <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">depth</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="built_in">depth</span>(head); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(GLNode* p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;tag==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> x:*p-&gt;sub) <span class="built_in">clear</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">GLNode* <span class="title">parse</span><span class="params">(string&amp; s, <span class="type">int</span>&amp; i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">            i++; <span class="comment">// skip &#x27;(&#x27;</span></span><br><span class="line">            GLNode* p=<span class="keyword">new</span> <span class="built_in">GLNode</span>();</span><br><span class="line">            <span class="keyword">while</span>(s[i]!=<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                p-&gt;sub-&gt;<span class="built_in">push_back</span>(<span class="built_in">parse</span>(s,i));</span><br><span class="line">                <span class="keyword">if</span>(s[i]==<span class="string">&#x27;,&#x27;</span>) i++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++; <span class="comment">// skip &#x27;)&#x27;</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">GLNode</span>(s[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(GLNode* p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;tag==<span class="number">0</span>) cout&lt;&lt;p-&gt;atom;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;(&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p-&gt;sub-&gt;<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="built_in">print</span>((*p-&gt;sub)[i]);</span><br><span class="line">                <span class="keyword">if</span>(i<span class="number">+1</span>&lt;p-&gt;sub-&gt;<span class="built_in">size</span>()) cout&lt;&lt;<span class="string">&quot;,&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;)&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">depth</span><span class="params">(GLNode* p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;tag==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> mx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:*p-&gt;sub) mx=<span class="built_in">max</span>(mx,<span class="built_in">depth</span>(x));</span><br><span class="line">        <span class="keyword">return</span> mx<span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="10-树（Tree）">10, 树（Tree）</h3>
<h4 id="1-二叉树-Binary-Tree">(1), 二叉树 (Binary Tree)</h4>
<h5 id="二叉树定义">二叉树定义</h5>
<p>二叉树是每个结点最多有两个子树的树结构。它可以是空树，也可以有根节点和两个不相交的左、右子树。</p>
<h5 id="二叉树操作">二叉树操作</h5>
<ul>
<li>创建：根据给定的数据构建二叉树。</li>
<li>插入：在指定位置插入新元素。</li>
<li>删除：从指定位置删除元素。</li>
<li>遍历：前序、中序、后序或层次遍历。</li>
<li>查找：按值查找特定元素的位置。</li>
<li>高度与深度：计算树的高度和任意节点的深度。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BTNode</span> &#123;</span><br><span class="line">        ElemType data;          <span class="comment">// 数据域</span></span><br><span class="line">        BTNode* lchild;         <span class="comment">// 左孩子指针</span></span><br><span class="line">        BTNode* rchild;         <span class="comment">// 右孩子指针</span></span><br><span class="line">        <span class="comment">// 结点构造函数</span></span><br><span class="line">        <span class="built_in">BTNode</span>(ElemType val = <span class="number">0</span>) : <span class="built_in">data</span>(val), <span class="built_in">lchild</span>(<span class="literal">nullptr</span>), <span class="built_in">rchild</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    BTNode* root;  <span class="comment">// 根结点指针</span></span><br><span class="line">    <span class="comment">// 构造函数（初始化空树）</span></span><br><span class="line">    <span class="built_in">BinaryTree</span>() : <span class="built_in">root</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数（递归释放所有结点）</span></span><br><span class="line">    ~<span class="built_in">BinaryTree</span>() &#123; <span class="built_in">destroy</span>(root); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心接口声明</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">(BTNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">destroy</span>(node-&gt;lchild);</span><br><span class="line">        <span class="built_in">destroy</span>(node-&gt;rchild);</span><br><span class="line">        <span class="keyword">delete</span> node;</span><br><span class="line">    &#125;                <span class="comment">// 递归销毁树（内部辅助）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root == <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;                      <span class="comment">// 判断树是否为空</span></span><br><span class="line">    <span class="function">BTNode* <span class="title">getRoot</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;                  <span class="comment">// 获取根结点指针</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createByPreorder</span><span class="params">(vector&lt;ElemType&gt;&amp; preorder, vector&lt;ElemType&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;ElemType, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; inorder.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            mp[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        function&lt;BTNode* (<span class="type">int</span>&amp;, vector&lt;ElemType&gt;&amp;, <span class="type">int</span>, <span class="type">int</span>)&gt; create = [&amp;](<span class="type">int</span>&amp; i, vector&lt;ElemType&gt;&amp; inorder, <span class="type">int</span> l, <span class="type">int</span> r) -&gt; BTNode* &#123;</span><br><span class="line">            <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="type">int</span> mid = mp[preorder[i]];</span><br><span class="line">            <span class="keyword">auto</span>* node = <span class="keyword">new</span> <span class="built_in">BTNode</span>(preorder[i]);</span><br><span class="line">            ++i;</span><br><span class="line">            node-&gt;lchild = <span class="built_in">create</span>(i, inorder, l, mid - <span class="number">1</span>);</span><br><span class="line">            node-&gt;rchild = <span class="built_in">create</span>(i, inorder, mid + <span class="number">1</span>, r);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        root = <span class="built_in">create</span>(i, inorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="comment">// 按先序中序序列创建（含空标记）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createByBackorder</span><span class="params">(vector&lt;ElemType&gt;&amp; backorder, vector&lt;ElemType&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;ElemType, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; inorder.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            mp[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        function&lt;BTNode* (<span class="type">int</span>&amp;, vector&lt;ElemType&gt;&amp;, <span class="type">int</span>, <span class="type">int</span>)&gt; create = [&amp;](<span class="type">int</span>&amp; i, vector&lt;ElemType&gt;&amp; inorder, <span class="type">int</span> l, <span class="type">int</span> r) -&gt; BTNode* &#123;</span><br><span class="line">            <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="type">int</span> mid = mp[backorder[i]];</span><br><span class="line">            BTNode* node = <span class="keyword">new</span> <span class="built_in">BTNode</span>(backorder[i]);</span><br><span class="line">            --i;</span><br><span class="line">            node-&gt;rchild = <span class="built_in">create</span>(i, inorder, mid + <span class="number">1</span>, r);</span><br><span class="line">            node-&gt;lchild = <span class="built_in">create</span>(i, inorder, l, mid - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span> i = backorder.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        root = <span class="built_in">create</span>(i, inorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="comment">// 按后序序中序序列创建（不含空标记）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createByFullBinaryTree</span><span class="params">(<span class="type">const</span> ElemType* arr, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">        function&lt;BTNode* (<span class="type">int</span>)&gt; create = [&amp;](<span class="type">int</span> i) -&gt; BTNode* &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= len) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            BTNode* node = <span class="keyword">new</span> <span class="built_in">BTNode</span>(arr[i]);</span><br><span class="line">            node-&gt;lchild = <span class="built_in">create</span>(<span class="number">2</span> * i + <span class="number">1</span>);</span><br><span class="line">            node-&gt;rchild = <span class="built_in">create</span>(<span class="number">2</span> * i + <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        root = <span class="built_in">create</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="comment">// 按满二叉树编号创建</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历算法（递归版）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preorderTraverse</span><span class="params">(<span class="type">void</span> (*visit)(ElemType))</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        function&lt;<span class="type">void</span> (BTNode*)&gt; preorder = [&amp;](BTNode* node) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="built_in">visit</span>(node-&gt;data);</span><br><span class="line">            <span class="built_in">preorder</span>(node-&gt;lchild);</span><br><span class="line">            <span class="built_in">preorder</span>(node-&gt;rchild);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">preorder</span>(root);</span><br><span class="line">    &#125; <span class="comment">// 先序遍历（V-L-R）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorderTraverse</span><span class="params">(<span class="type">void</span> (*visit)(ElemType))</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        function&lt;<span class="type">void</span> (BTNode*)&gt; inorder = [&amp;](BTNode* node) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="built_in">inorder</span>(node-&gt;lchild);</span><br><span class="line">            <span class="built_in">visit</span>(node-&gt;data);</span><br><span class="line">            <span class="built_in">inorder</span>(node-&gt;rchild);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">inorder</span>(root);</span><br><span class="line">    &#125; <span class="comment">// 中序遍历（L-V-R）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">postorderTraverse</span><span class="params">(<span class="type">void</span> (*visit)(ElemType))</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        function&lt;<span class="type">void</span> (BTNode*)&gt; postorder = [&amp;](BTNode* node) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="built_in">postorder</span>(node-&gt;lchild);</span><br><span class="line">            <span class="built_in">postorder</span>(node-&gt;rchild);</span><br><span class="line">            <span class="built_in">visit</span>(node-&gt;data);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">postorder</span>(root);</span><br><span class="line">    &#125; <span class="comment">// 后序遍历（L-R-V）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">levelorderTraverse</span><span class="params">(<span class="type">void</span> (*visit)(ElemType))</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        queue&lt;BTNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            BTNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">visit</span>(node-&gt;data);</span><br><span class="line">            q.<span class="built_in">push</span>(node-&gt;lchild);</span><br><span class="line">            q.<span class="built_in">push</span>(node-&gt;rchild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 层次遍历（自上而下、自左至右）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历算法（非递归版）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preorderTraverseNonRec</span><span class="params">(<span class="type">void</span> (*visit)(ElemType))</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        stack&lt;BTNode*&gt; s;</span><br><span class="line">        s.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            BTNode* node = s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">visit</span>(node-&gt;data);</span><br><span class="line">            s.<span class="built_in">push</span>(node-&gt;rchild);</span><br><span class="line">            s.<span class="built_in">push</span>(node-&gt;lchild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorderTraverseNonRec</span><span class="params">(<span class="type">void</span> (*visit)(ElemType))</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        stack&lt;BTNode*&gt; s;</span><br><span class="line">        BTNode* node = root;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span> || !s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(node);</span><br><span class="line">                node = node-&gt;lchild;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="built_in">visit</span>(node-&gt;data);</span><br><span class="line">                node = node-&gt;rchild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">postorderTraverseNonRec</span><span class="params">(<span class="type">void</span> (*visit)(ElemType))</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        stack&lt;BTNode*&gt; s;</span><br><span class="line">        BTNode* node = root;</span><br><span class="line">        BTNode* lastVisited = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span> || !s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(node);</span><br><span class="line">                node = node-&gt;lchild;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = s.<span class="built_in">top</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;rchild == <span class="literal">nullptr</span> || node-&gt;rchild == lastVisited) &#123;</span><br><span class="line">                    <span class="built_in">visit</span>(node-&gt;data);</span><br><span class="line">                    lastVisited = node;</span><br><span class="line">                    s.<span class="built_in">pop</span>();</span><br><span class="line">                    node = <span class="literal">nullptr</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    node = node-&gt;rchild;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 常用操作</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getHeight</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        function&lt;<span class="type">int</span> (BTNode*)&gt; getHeight = [&amp;](BTNode* node) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">getHeight</span>(node-&gt;lchild), <span class="built_in">getHeight</span>(node-&gt;rchild)) + <span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getHeight</span>(root);</span><br><span class="line">    &#125; <span class="comment">// 获取树的高度（深度）</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getLeafCount</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        function&lt;<span class="type">int</span> (BTNode*)&gt; getLeafCount = [&amp;](BTNode* node) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;lchild == <span class="literal">nullptr</span> &amp;&amp; node-&gt;rchild == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getLeafCount</span>(node-&gt;lchild) + <span class="built_in">getLeafCount</span>(node-&gt;rchild);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getLeafCount</span>(root);</span><br><span class="line">    &#125; <span class="comment">// 统计叶子结点个数</span></span><br><span class="line">    <span class="function">BTNode* <span class="title">findNode</span><span class="params">(ElemType val)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        function&lt;BTNode* (BTNode*)&gt; findNode = [&amp;](BTNode* node) -&gt; BTNode* &#123;</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;data == val) <span class="keyword">return</span> node;</span><br><span class="line">            BTNode* left = <span class="built_in">findNode</span>(node-&gt;lchild);</span><br><span class="line">            <span class="keyword">if</span> (left != <span class="literal">nullptr</span>) <span class="keyword">return</span> left;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findNode</span>(node-&gt;rchild);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findNode</span>(root);</span><br><span class="line">    &#125; <span class="comment">// 查找值为val的结点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setRoot</span><span class="params">(BTNode *pNode)</span> </span>&#123;</span><br><span class="line">        root = pNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-二叉树与树与森林-Tree-and-Forest">(2), 二叉树与树与森林 (Tree and Forest)</h4>
<h5 id="树（Tree）">树（Tree）</h5>
<p>树是一种非线性的数据结构，由n（n&gt;=0）个结点组成，其中有一个特殊的结点称为根结点，其余结点可分为m（m&gt;=0）个互不相交的子树。树是递归定义的，即树的结点也可以是树。</p>
<h5 id="森林（Forest）">森林（Forest）</h5>
<p>森林是m（m&gt;=0）棵互不相交的树的集合。</p>
<h5 id="树与二叉树的转换">树与二叉树的转换</h5>
<p>树与二叉树的转换是树与二叉树之间的一种重要关系。树与二叉树之间的转换关系如下：</p>
<ul>
<li>树转换为二叉树：将树的根结点作为二叉树的根结点，然后将树的每个结点的第一个孩子作为二叉树的左孩子，将每个结点的其他孩子作为二叉树的右孩子，依次递归进行，直到所有结点都被转换为二叉树的结点。这样得到的二叉树称为树的二叉树表示。</li>
<li>二叉树转换为树：将二叉树的根结点作为树的根结点，然后将二叉树的每个结点的左孩子作为树的第一个孩子，将每个结点的右孩子作为树的其他孩子，依次递归进行，直到所有结点都被转换为树的结点。这样得到的树称为二叉树的树表示。</li>
<li>树的森林转换为二叉树：将树的森林中的每棵树转换为二叉树，然后将这些二叉树的根结点连接起来，作为森林的根结点。这样得到的二叉树称为树的森林的二叉树表示。</li>
<li>二叉树转换为树的森林：将二叉树的根结点作为森林的根结点，然后将二叉树的每个结点的左孩子作为森林的第一棵树的根结点，将每个结点的右孩子作为森林的其他树的根结点，依次递归进行，直到所有结点都被转换为树的结点。这样得到的树的森林称为二叉树的树的森林表示。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeForest</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> BinaryTree&lt;ElemType&gt;::BTNode BTNode;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">CSNode</span> &#123;</span><br><span class="line">        ElemType data;          <span class="comment">// 数据域</span></span><br><span class="line">        vector&lt;CSNode*&gt; children;     <span class="comment">// 孩子指针</span></span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">CSNode</span><span class="params">(ElemType val = <span class="number">0</span>)</span> : data(val) &#123;</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">BTNode* <span class="title">treeToBinaryTree</span><span class="params">(CSNode* treeRoot)</span> </span>&#123;</span><br><span class="line">        function&lt;BTNode* (CSNode*)&gt; treeToBinaryTree = [&amp;](CSNode* tree) -&gt; BTNode *&#123;</span><br><span class="line">            <span class="keyword">if</span> (tree == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">auto</span> * binary = <span class="keyword">new</span> <span class="built_in">BTNode</span>(tree-&gt;data);</span><br><span class="line">            <span class="keyword">if</span> (tree-&gt;children.<span class="built_in">empty</span>()) <span class="keyword">return</span> binary;</span><br><span class="line">            binary-&gt;lchild = <span class="built_in">treeToBinaryTree</span>(tree-&gt;children[<span class="number">0</span>]);</span><br><span class="line">            BTNode* cur = binary-&gt;lchild;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;tree-&gt;children.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                cur-&gt;rchild = <span class="built_in">treeToBinaryTree</span>(tree-&gt;children[i]);</span><br><span class="line">                cur = cur-&gt;rchild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> binary;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">treeToBinaryTree</span>(treeRoot);</span><br><span class="line">    &#125; <span class="comment">// 树转换为二叉树</span></span><br><span class="line">    <span class="function">CSNode* <span class="title">binaryTreeToTree</span><span class="params">(BTNode* binaryRoot)</span> </span>&#123;</span><br><span class="line">        function&lt;CSNode* (BTNode*)&gt; binaryTreeToTree = [&amp;](BTNode* binary) -&gt; CSNode*  &#123;</span><br><span class="line">            <span class="keyword">if</span> (binary == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            CSNode* tree = <span class="keyword">new</span> <span class="built_in">CSNode</span>(binary-&gt;data);</span><br><span class="line">            <span class="keyword">if</span> (binary-&gt;lchild == <span class="literal">nullptr</span>) <span class="keyword">return</span> tree;</span><br><span class="line">            tree-&gt;children.<span class="built_in">push_back</span>(<span class="built_in">binaryTreeToTree</span>(binary-&gt;lchild));</span><br><span class="line">            BTNode* cur = binary-&gt;lchild;</span><br><span class="line">            <span class="keyword">while</span> (cur-&gt;rchild != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                tree-&gt;children.<span class="built_in">push_back</span>(<span class="built_in">binaryTreeToTree</span>(cur-&gt;rchild));</span><br><span class="line">                cur = cur-&gt;rchild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> tree;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">binaryTreeToTree</span>(binaryRoot);</span><br><span class="line">    &#125; <span class="comment">// 二叉树还原为树</span></span><br><span class="line">    <span class="function">BTNode* <span class="title">forestToBinaryTree</span><span class="params">(vector&lt;CSNode*&gt;&amp; forest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (forest.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        BTNode* binaryRoot = <span class="built_in">treeToBinaryTree</span>(forest[<span class="number">0</span>]);</span><br><span class="line">        BTNode* cur = binaryRoot;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;forest.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            cur-&gt;rchild = <span class="built_in">treeToBinaryTree</span>(forest[i]);</span><br><span class="line">            cur= cur-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> binaryRoot;</span><br><span class="line">    &#125; <span class="comment">// 森林转换为二叉树</span></span><br><span class="line">    <span class="function">vector&lt;CSNode*&gt; <span class="title">binaryTreeToForest</span><span class="params">(BTNode* binaryRoot)</span> </span>&#123;</span><br><span class="line">        vector&lt;CSNode*&gt; forestRoots;</span><br><span class="line">        <span class="keyword">if</span> (binaryRoot == <span class="literal">nullptr</span>) <span class="keyword">return</span> forestRoots;</span><br><span class="line">        BTNode * cur = binaryRoot;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            BTNode * tmp = cur-&gt;rchild;</span><br><span class="line">            cur-&gt;rchild = <span class="literal">nullptr</span>;</span><br><span class="line">            forestRoots.<span class="built_in">push_back</span>(<span class="built_in">binaryTreeToTree</span>(cur));</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> forestRoots;</span><br><span class="line">    &#125; <span class="comment">// 二叉树还原为森林</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 树的遍历（孩子兄弟表示法）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">treePreorderTraverse</span><span class="params">(CSNode* root, <span class="type">void</span> (*visit)(ElemType))</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">visit</span>(root-&gt;data);</span><br><span class="line">        <span class="keyword">for</span> (CSNode* child : root-&gt;children) &#123;</span><br><span class="line">            <span class="built_in">treePreorderTraverse</span>(child, visit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 树的先序遍历</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">treePostorderTraverse</span><span class="params">(CSNode* root, <span class="type">void</span> (*visit)(ElemType))</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (CSNode* child : root-&gt;children) &#123;</span><br><span class="line">            <span class="built_in">treePostorderTraverse</span>(child, visit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">visit</span>(root-&gt;data);</span><br><span class="line">    &#125; <span class="comment">// 树的后序遍历</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">forestPreorderTraverse</span><span class="params">(vector&lt;CSNode*&gt;&amp; forest, <span class="type">void</span> (*visit)(ElemType))</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;tree : forest)</span><br><span class="line">            <span class="built_in">treePreorderTraverse</span>(tree, visit);</span><br><span class="line">    &#125; <span class="comment">// 森林先序遍历</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="3-二叉搜索树-Binary-Search-Tree">(3), 二叉搜索树 (Binary Search Tree)</h4>
<h5 id="定义">定义</h5>
<p>二叉搜索树（Binary Search Tree，简称BST）是一种特殊的二叉树，它满足以下性质：</p>
<ul>
<li>每个结点的值大于其左子树中所有结点的值；</li>
<li>每个结点的值小于其右子树中所有结点的值；</li>
</ul>
<h5 id="操作">操作</h5>
<ul>
<li>查找：从根结点开始，如果根结点的值等于查找的值，则查找成功；如果查找的值小于根结点的值，则在左子树中继续查找；如果查找的值大于根结点的值，则在右子树中继续查找。如果查找的值不在树中，则查找失败。</li>
<li>插入：在二叉搜索树中插入一个结点，需要找到该结点的父结点，然后根据其值与父结点值的比较结果确定是作为左子结点还是右子结点。</li>
<li>删除：在二叉搜索树中删除一个结点，需要找到该结点的父结点，然后根据其值与父结点值的比较结果确定是作为左子结点还是右子结点。如果被删除的结点是叶子结点，则直接删除；如果被删除的结点只有一个子结点，则用该子结点替换被删除的结点；如果被删除的结点有两个子结点，则用其右子树中的最小结点替换被删除的结点。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ElemType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySearchTree</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BSTNode</span> &#123;</span><br><span class="line">        KeyType key;            <span class="comment">// 关键字（查找依据）</span></span><br><span class="line">        ElemType data;          <span class="comment">// 数据域</span></span><br><span class="line">        BSTNode* lchild;        <span class="comment">// 左子树（关键字小于当前）</span></span><br><span class="line">        BSTNode* rchild;        <span class="comment">// 右子树（关键字大于当前）</span></span><br><span class="line">        <span class="built_in">BSTNode</span>(KeyType k, ElemType val) : <span class="built_in">key</span>(k), <span class="built_in">data</span>(val), <span class="built_in">lchild</span>(<span class="literal">nullptr</span>), <span class="built_in">rchild</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    BSTNode* root;              <span class="comment">// 根结点指针</span></span><br><span class="line"></span><br><span class="line">    <span class="function">BSTNode* <span class="title">search</span><span class="params">(BSTNode* node,KeyType key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span> || node-&gt;key == key) <span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; node-&gt;key) <span class="keyword">return</span> <span class="built_in">search</span>(node-&gt;lchild, key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">search</span>(node-&gt;rchild, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(BSTNode*&amp; node, KeyType k, ElemType e)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; node-&gt;key) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;lchild == <span class="literal">nullptr</span>) node-&gt;lchild = <span class="keyword">new</span> <span class="built_in">BSTNode</span>(k, e);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">insert</span>(node-&gt;lchild, k, e);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &gt; node-&gt;key) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;rchild == <span class="literal">nullptr</span>) node-&gt;rchild = <span class="keyword">new</span> <span class="built_in">BSTNode</span>(k, e);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">insert</span>(node-&gt;rchild, k, e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node-&gt;data = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(BSTNode*&amp; node, KeyType key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; node-&gt;key) <span class="built_in">remove</span>(node-&gt;lchild, key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node-&gt;key) <span class="built_in">remove</span>(node-&gt;rchild, key);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;lchild == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                BSTNode *temp = node;</span><br><span class="line">                node = node-&gt;rchild;</span><br><span class="line">                <span class="keyword">delete</span> temp;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;rchild == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                BSTNode *temp = node;</span><br><span class="line">                node = node-&gt;lchild;</span><br><span class="line">                <span class="keyword">delete</span> temp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                BSTNode *temp = node-&gt;rchild;</span><br><span class="line">                <span class="keyword">while</span> (temp-&gt;lchild != <span class="literal">nullptr</span>) temp = temp-&gt;lchild;</span><br><span class="line">                node-&gt;key = temp-&gt;key;</span><br><span class="line">                node-&gt;data = temp-&gt;data;</span><br><span class="line">                <span class="built_in">remove</span>(node-&gt;rchild, temp-&gt;key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorderTraverse</span><span class="params">(BSTNode* node, <span class="type">void</span> (*visit)(KeyType, ElemType))</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inorderTraverse</span>(node-&gt;lchild, visit);</span><br><span class="line">        <span class="built_in">visit</span>(node-&gt;key, node-&gt;data);</span><br><span class="line">        <span class="built_in">inorderTraverse</span>(node-&gt;rchild, visit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">BinarySearchTree</span>() : <span class="built_in">root</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">BinarySearchTree</span>() &#123; <span class="built_in">destroy</span>(root); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心接口声明</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">(BSTNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">destroy</span>(node-&gt;lchild);</span><br><span class="line">        <span class="built_in">destroy</span>(node-&gt;rchild);</span><br><span class="line">        <span class="keyword">delete</span> node;</span><br><span class="line">    &#125;                <span class="comment">// 递归销毁树</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root == <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;                      <span class="comment">// 判断树是否为空</span></span><br><span class="line">    <span class="function">BSTNode* <span class="title">search</span><span class="params">(KeyType key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(root, key);</span><br><span class="line">    &#125;        <span class="comment">// 查找关键字为key的结点（递归）</span></span><br><span class="line">    <span class="function">BSTNode* <span class="title">searchNonRec</span><span class="params">(KeyType key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        BSTNode* node = root;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span> &amp;&amp; node-&gt;key != key) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key &lt; node-&gt;key) node = node-&gt;lchild;</span><br><span class="line">            <span class="keyword">else</span> node = node-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;  <span class="comment">// 查找关键字为key的结点（非递归）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(KeyType key, ElemType data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            root = <span class="keyword">new</span> <span class="built_in">BSTNode</span>(key, data);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">insert</span>(root, key, data);</span><br><span class="line">    &#125;    <span class="comment">// 插入结点（保持BST性质）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(KeyType key)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">remove</span>(root, key);</span><br><span class="line">    &#125;                  <span class="comment">// 删除结点（保持BST性质）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorderTraverse</span><span class="params">(<span class="type">void</span> (*visit)(KeyType, ElemType))</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">inorderTraverse</span>(root, visit);</span><br><span class="line">    &#125; <span class="comment">// 中序遍历（得到有序序列）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="4-平衡二叉树-AVl树">(4), 平衡二叉树 (AVl树)</h4>
<h5 id="定义-2">定义</h5>
<p>AVL树是一种自平衡的二叉搜索树，它满足以下性质：</p>
<ul>
<li>每个结点的左子树和右子树的高度差不超过1；</li>
<li>每个结点的左子树和右子树都是AVL树；</li>
</ul>
<h5 id="操作-2">操作</h5>
<p>在二叉搜索树的基础上，增加以下操作：</p>
<ul>
<li>平衡化：在插入或删除结点后，检查每个结点的平衡因子，如果平衡因子超过1，则进行相应的旋转操作，以保持AVL树的性质。</li>
<li>旋转操作：包括左旋、右旋、左右旋和右左旋四种操作，用于调整树的结构，以保持AVL树的性质。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType, <span class="keyword">typename</span> ElemType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AVLTree</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">AVLNode</span> &#123;</span><br><span class="line">        KeyType key;            <span class="comment">// 关键字</span></span><br><span class="line">        ElemType data;          <span class="comment">// 数据域</span></span><br><span class="line">        AVLNode* lchild;        <span class="comment">// 左子树</span></span><br><span class="line">        AVLNode* rchild;        <span class="comment">// 右子树</span></span><br><span class="line">        <span class="type">int</span> height;</span><br><span class="line">        <span class="built_in">AVLNode</span>(KeyType k, ElemType val) : <span class="built_in">key</span>(k), <span class="built_in">data</span>(val), <span class="built_in">lchild</span>(<span class="literal">nullptr</span>), <span class="built_in">rchild</span>(<span class="literal">nullptr</span>), <span class="built_in">height</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    AVLNode* root;              <span class="comment">// 根结点指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 平衡化旋转（内部辅助）</span></span><br><span class="line">    <span class="function">AVLNode* <span class="title">leftRotate</span><span class="params">(AVLNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node== <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> right = node-&gt;rchild;</span><br><span class="line">        node-&gt;rchild = right-&gt;lchild;</span><br><span class="line">        right-&gt;lchild = node;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关键补充：先更新原节点高度，再更新新根高度</span></span><br><span class="line">        <span class="built_in">updateHeight</span>(node); <span class="comment">// node 是原根，结构先变化</span></span><br><span class="line">        <span class="built_in">updateHeight</span>(right); <span class="comment">// right 是新根，依赖原根的高度</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">AVLNode* <span class="title">rightRotate</span><span class="params">(AVLNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node== <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">auto</span> left=node-&gt;lchild;</span><br><span class="line">        node-&gt;lchild=left-&gt;rchild;</span><br><span class="line">        left-&gt;rchild=node;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">updateHeight</span>(node);</span><br><span class="line">        <span class="built_in">updateHeight</span>(left);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">AVLNode* <span class="title">leftRightRotate</span><span class="params">(AVLNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node== <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        node-&gt;lchild=<span class="built_in">leftRotate</span>(node-&gt;lchild);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rightRotate</span>(node);</span><br><span class="line">    &#125;    <span class="comment">// LR型旋转（先左后右）</span></span><br><span class="line">    <span class="function">AVLNode* <span class="title">rightLeftRotate</span><span class="params">(AVLNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node== <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        node-&gt;rchild= <span class="built_in">rightRotate</span>(node-&gt;rchild);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">leftRotate</span>(node);</span><br><span class="line">    &#125;    <span class="comment">// RL型旋转（先右后左）</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getHeight</span><span class="params">(AVLNode* node)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node-&gt;height;</span><br><span class="line">    &#125;         <span class="comment">// 获取结点子树高度</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateHeight</span><span class="params">(AVLNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node== <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        node-&gt;height=std::<span class="built_in">max</span>(<span class="built_in">getHeight</span>(node-&gt;lchild), <span class="built_in">getHeight</span>(node-&gt;rchild))<span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getBalance</span><span class="params">(AVLNode* node)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node== <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getHeight</span>(node-&gt;lchild)- <span class="built_in">getHeight</span>(node-&gt;rchild);</span><br><span class="line">    &#125;        <span class="comment">// 计算结点平衡因子</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">balance</span><span class="params">(AVLNode*&amp; node)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> b= <span class="built_in">getBalance</span>(node);</span><br><span class="line">        <span class="keyword">if</span> (b&gt;<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">getBalance</span>(node-&gt;lchild)&lt;<span class="number">0</span>) &#123;</span><br><span class="line">                node = <span class="built_in">leftRightRotate</span>(node);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = <span class="built_in">rightRotate</span>(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b&lt;<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">getBalance</span>(node-&gt;rchild)&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                node = <span class="built_in">rightLeftRotate</span>(node);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = <span class="built_in">leftRotate</span>(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        updateHeight(node);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insertNode</span><span class="params">(AVLNode*&amp; node, KeyType key, ElemType data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node== <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            node = <span class="keyword">new</span> <span class="built_in">AVLNode</span>(key, data);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; node-&gt;key) &#123;</span><br><span class="line">            <span class="built_in">insertNode</span>(node-&gt;lchild, key, data);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node-&gt;key) &#123;</span><br><span class="line">            <span class="built_in">insertNode</span>(node-&gt;rchild, key, data);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node-&gt;data = data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">updateHeight</span>(node);</span><br><span class="line">        <span class="built_in">balance</span>(node);</span><br><span class="line">    &#125; <span class="comment">// 递归插入（维护平衡）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeNode</span><span class="params">(AVLNode*&amp; node, KeyType key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node== <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; node-&gt;key) &#123;</span><br><span class="line">            <span class="built_in">removeNode</span>(node-&gt;lchild, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node-&gt;key) &#123;</span><br><span class="line">            <span class="built_in">removeNode</span>(node-&gt;rchild, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;lchild== <span class="literal">nullptr</span>&amp;&amp;node-&gt;rchild== <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> node;</span><br><span class="line">                node = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;lchild== <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">auto</span> temp = node;</span><br><span class="line">                node = node-&gt;rchild;</span><br><span class="line">                <span class="keyword">delete</span> temp;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;rchild== <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">auto</span> temp = node;</span><br><span class="line">                node = node-&gt;lchild;</span><br><span class="line">                <span class="keyword">delete</span> temp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">auto</span> temp = node-&gt;rchild;</span><br><span class="line">                <span class="keyword">while</span> (temp-&gt;lchild!= <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    temp = temp-&gt;lchild;</span><br><span class="line">                &#125;</span><br><span class="line">                node-&gt;key = temp-&gt;key;</span><br><span class="line">                node-&gt;data = temp-&gt;data;</span><br><span class="line">                <span class="built_in">removeNode</span>(node-&gt;rchild, temp-&gt;key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">updateHeight</span>(node);</span><br><span class="line">        <span class="built_in">balance</span>(node);</span><br><span class="line">    &#125; <span class="comment">// 递归删除（维护平衡）</span></span><br><span class="line"></span><br><span class="line">    <span class="function">AVLNode* <span class="title">search</span><span class="params">(AVLNode* node, KeyType key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node== <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; node-&gt;key) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">search</span>(node-&gt;lchild, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node-&gt;key) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">search</span>(node-&gt;rchild, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorderTraverse</span><span class="params">(AVLNode* node ,<span class="type">void</span> (*visit)(KeyType, ElemType))</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node== <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inorderTraverse</span>(node-&gt;lchild, visit);</span><br><span class="line">        <span class="built_in">visit</span>(node-&gt;key, node-&gt;data);</span><br><span class="line">        <span class="built_in">inorderTraverse</span>(node-&gt;rchild, visit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">AVLTree</span>() : <span class="built_in">root</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">AVLTree</span>() &#123; <span class="built_in">destroy</span>(root); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心接口声明</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">(AVLNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node== <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">destroy</span>(node-&gt;lchild);</span><br><span class="line">        <span class="built_in">destroy</span>(node-&gt;rchild);</span><br><span class="line">        <span class="keyword">delete</span> node;</span><br><span class="line">    &#125;               <span class="comment">// 递归销毁树</span></span><br><span class="line">    [[nodiscard]] <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root== <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;                     <span class="comment">// 判断树是否为空</span></span><br><span class="line">    <span class="function">AVLNode* <span class="title">search</span><span class="params">(KeyType key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(root, key);</span><br><span class="line">    &#125;         <span class="comment">// 查找关键字</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(KeyType key, ElemType data)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">insertNode</span>(root, key,data);</span><br><span class="line">    &#125;     <span class="comment">// 插入结点（自动平衡）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(KeyType key)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">removeNode</span>(root, key);</span><br><span class="line">    &#125;                    <span class="comment">// 删除结点（自动平衡）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorderTraverse</span><span class="params">(<span class="type">void</span> (*visit)(KeyType, ElemType))</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">inorderTraverse</span>(root, visit);</span><br><span class="line">    &#125; <span class="comment">// 中序遍历（有序序列）</span></span><br><span class="line">    [[nodiscard]] <span class="function"><span class="type">bool</span> <span class="title">isAVLTree</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(<span class="built_in">getBalance</span>(root))&lt;=<span class="number">1</span>;</span><br><span class="line">    &#125;                    <span class="comment">// 验证是否为合法AVL树</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="5-哈夫曼树-Huffman-Tree">(5), 哈夫曼树 (Huffman Tree)</h4>
<h5 id="哈夫曼树定义">哈夫曼树定义</h5>
<p>哈夫曼树（Huffman Tree）是一种特殊的二叉树，它是一种带权路径长度（WPL）最短的二叉树。哈夫曼树是一种最优二叉树，它的带权路径长度（WPL）是所有带权路径长度中最小的。</p>
<h5 id="哈夫曼树的构造">哈夫曼树的构造</h5>
<p>哈夫曼树的构造过程如下：</p>
<ol>
<li>创建N个权值均为W的叶子结点。</li>
<li>将这些结点构造成一个森林。</li>
</ol>
<h5 id="哈夫曼树的性质">哈夫曼树的性质</h5>
<ol>
<li>哈夫曼树的每个结点都有两个子结点。</li>
<li>哈夫曼树的每个结点的权值都大于等于其子结点的权值。</li>
<li>哈夫曼树的带权路径长度（WPL）是所有带权路径长度中最小的。</li>
</ol>
<h5 id="哈夫曼树的应用">哈夫曼树的应用</h5>
<ol>
<li>哈夫曼编码：哈夫曼树可以用于构造哈夫曼编码，哈夫曼编码是一种无损压缩编码，它可以有效地减少数据的存储空间。</li>
<li>哈夫曼树可以用于数据压缩和解压缩。</li>
<li>哈夫曼树可以用于数据传输和通信。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HuffmanTree</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">HuffmanNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> weight;        <span class="comment">// 权值（字符频度等）</span></span><br><span class="line">        <span class="type">bool</span> isLeaf;         <span class="comment">// 是否为叶子结点</span></span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HuffmanTree</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">HuffmanNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> weight;        <span class="comment">// 权值（字符频度等）</span></span><br><span class="line">        <span class="type">bool</span> isLeaf;         <span class="comment">// 是否为叶子结点</span></span><br><span class="line">        <span class="type">char</span> ch;              <span class="comment">// 字符（仅叶子结点有效）</span></span><br><span class="line">        HuffmanNode* lchild;             <span class="comment">// 左孩子</span></span><br><span class="line">        HuffmanNode* rchild;             <span class="comment">// 右孩子</span></span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        <span class="built_in">HuffmanNode</span>(<span class="type">int</span> w = <span class="number">0</span>) : <span class="built_in">weight</span>(w),<span class="built_in">isLeaf</span>(<span class="literal">false</span>), <span class="built_in">ch</span>(<span class="string">&#x27;\0&#x27;</span>) ,<span class="built_in">lchild</span>(<span class="literal">nullptr</span>), <span class="built_in">rchild</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    HuffmanNode* ht;           <span class="comment">// 哈夫曼树结点数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数（按权值数组创建哈夫曼树）</span></span><br><span class="line">    <span class="built_in">HuffmanTree</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">HuffmanTree</span>() &#123; <span class="built_in">destroyHuffman</span>(ht); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心接口声明</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getWPL</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> wpl=<span class="number">0</span>;</span><br><span class="line">        function&lt;<span class="type">void</span>(HuffmanNode*)&gt; dfs = [&amp;](HuffmanNode* node) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node== <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">            wpl += node-&gt;weight;</span><br><span class="line">            <span class="built_in">dfs</span>(node-&gt;lchild);</span><br><span class="line">            <span class="built_in">dfs</span>(node-&gt;rchild);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(ht);</span><br><span class="line">        <span class="keyword">return</span> wpl;</span><br><span class="line">    &#125;                   <span class="comment">// 计算带权路径长度（WPL）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">generateHuffmanCode</span><span class="params">(string&amp; code)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">256</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : code) &#123;</span><br><span class="line">            cnt[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                cout &lt;&lt; (<span class="type">char</span>) i &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; cnt[i] &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        priority_queue&lt;HuffmanNode*, vector&lt;HuffmanNode*&gt;, function&lt;<span class="type">bool</span>(HuffmanNode*, HuffmanNode*)&gt;&gt; <span class="built_in">pq</span>(</span><br><span class="line">                [](HuffmanNode* a, HuffmanNode* b) &#123; <span class="keyword">return</span> a-&gt;weight &lt; b-&gt;weight; &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                HuffmanNode* node = <span class="keyword">new</span> <span class="built_in">HuffmanNode</span>(cnt[i]);</span><br><span class="line">                node-&gt;ch = (<span class="type">char</span>) i;</span><br><span class="line">                node-&gt;isLeaf = <span class="literal">true</span>;</span><br><span class="line">                pq.<span class="built_in">push</span>(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (pq.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            HuffmanNode* left = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            HuffmanNode* right = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            HuffmanNode* parent = <span class="keyword">new</span> <span class="built_in">HuffmanNode</span>(left-&gt;weight + right-&gt;weight);</span><br><span class="line">            parent-&gt;lchild = left;</span><br><span class="line">            parent-&gt;rchild = right;</span><br><span class="line">            pq.<span class="built_in">push</span>(parent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ht = pq.<span class="built_in">top</span>();</span><br><span class="line">    &#125;   <span class="comment">// 生成哈夫曼编码（每个字符对应编码串）</span></span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">getHuffmanCode</span><span class="params">(<span class="type">char</span> ch)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        string code;</span><br><span class="line">        function&lt;<span class="type">void</span>(HuffmanNode*, string)&gt; dfs = [&amp;](HuffmanNode* node, <span class="type">const</span> string&amp; path) &#123;</span><br><span class="line"><span class="comment">//            cout&lt;&lt;node&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;isLeaf ) &#123;</span><br><span class="line"><span class="comment">//                cout&lt;&lt;node-&gt;ch&lt;&lt;&#x27; &#x27;&lt;&lt;path&lt;&lt;endl;</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;ch == ch) &#123;</span><br><span class="line">                    code = path;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">dfs</span>(node-&gt;lchild, path + <span class="string">&quot;0&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (!code.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(node-&gt;rchild, path + <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(ht, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;   <span class="comment">// 获取指定字符的哈夫曼编码</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destroyHuffman</span><span class="params">(HuffmanNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node== <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">destroyHuffman</span>(node-&gt;lchild);</span><br><span class="line">        <span class="built_in">destroyHuffman</span>(node-&gt;rchild);</span><br><span class="line">        <span class="keyword">delete</span> node;</span><br><span class="line">    &#125; <span class="comment">// 销毁哈夫曼编码数组</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="6-B-B-树-B-Tree-B-Tree">(6), B-, B+树 (B-Tree, B+Tree)</h4>
<h5 id="B-树定义">B-树定义</h5>
<p>B-树是一种自平衡的多路搜索树，它满足以下性质：</p>
<ul>
<li>每个结点最多有m个孩子（m阶B-树）；</li>
<li>根结点至少有2个孩子（m阶B-树）；</li>
<li>每个非根结点至少有ceil(m/2)-1个关键字（m阶B-树）；</li>
<li>每个非根结点最多有m-1个关键字（m阶B-树）；</li>
<li>所有叶子结点都在同一层；</li>
</ul>
<h5 id="B-树定义-2">B+树定义</h5>
<p>B+树是一种自平衡的多路搜索树，它满足以下性质：</p>
<ul>
<li>每个结点最多有m个孩子（m阶B+树）；</li>
<li>根结点至少有2个孩子（m阶B+树）；</li>
<li>每个非根结点至少有ceil(m/2)-1个关键字（m阶B+树）；</li>
<li>每个非根结点最多有m-1个关键字（m阶B+树）；</li>
<li>所有叶子结点都在同一层；</li>
</ul>
<h5 id="B-树和B-树的比较">B-树和B+树的比较</h5>
<p>B-树和B+树都是自平衡的多路搜索树，它们都满足以下性质：</p>
<ul>
<li>每个结点最多有m个孩子（m阶B-树）；</li>
<li>根结点至少有2个孩子（m阶B-树）；</li>
<li>每个非根结点至少有ceil(m/2)-1个关键字（m阶B-树）；</li>
<li>每个非根结点最多有m-1个关键字（m阶B-树）；</li>
<li>所有叶子结点都在同一层；</li>
</ul>
<p>不同点</p>
<ul>
<li>B-树每个结点最多有m-1个关键字，而B+树每个结点最多有m-2个关键字（因为B+树的叶子结点不存储关键字）；</li>
<li>B-树每个结点的子树指针数=关键字数+1，而B+树每个结点的子树指针数=关键字数（因为B+树的叶子结点不存储关键字）；</li>
<li>B-树的非叶子结点只用于索引，而B+树的非叶子结点只用于索引，而叶子结点存储实际数据；</li>
</ul>
<h5 id="B-树和B-树的用途">B-树和B+树的用途</h5>
<p>B-树和B+树都是自平衡的多路搜索树，它们都广泛应用于数据库和文件系统中。B-树和B+树的主要用途包括：</p>
<ul>
<li>数据库索引：B-树和B+树都可以用于数据库索引，它们可以有效地提高数据库的查询性能。</li>
<li>文件系统：B-树和B+树都可以用于文件系统，它们可以有效地提高文件系统的读写性能。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// B-树类（m阶）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BTree</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BTreeNode</span> &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; keys;          <span class="comment">// 关键字数组（有序）</span></span><br><span class="line">        vector&lt;BTreeNode*&gt; children;   <span class="comment">// 子树指针数组（个数=keyNum+1）</span></span><br><span class="line">        <span class="type">int</span> keyNum;                    <span class="comment">// 关键字个数</span></span><br><span class="line">        <span class="type">bool</span> isLeaf;            <span class="comment">// 是否为叶子结点</span></span><br><span class="line">        <span class="comment">// 构造函数（m阶：关键字最大个数=m-1，子树最大个数=m）</span></span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">BTreeNode</span><span class="params">(<span class="type">int</span> m, <span class="type">bool</span> leaf = <span class="literal">false</span>)</span> : keys(m), children(m<span class="number">+1</span>),keyNum(<span class="number">0</span>) ,isLeaf(leaf) &#123;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) children[i] = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125; <span class="comment">// 多分配一个防止越界</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    BTreeNode* root;            <span class="comment">// 根结点指针</span></span><br><span class="line">    <span class="type">int</span> order;                  <span class="comment">// B-树的阶（m）</span></span><br><span class="line">    <span class="type">int</span> minKeyNum;              <span class="comment">// 非根结点的最小关键字个数（m/2）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部辅助操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">splitChild</span><span class="params">(BTreeNode* parent, <span class="type">int</span> idx)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        BTreeNode* child = parent-&gt;children[idx];</span><br><span class="line">        <span class="type">int</span> mid = (order + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> key= child-&gt;keys[mid<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = parent-&gt;keyNum; i &gt; idx; i--) &#123;</span><br><span class="line">            parent-&gt;keys[i] = parent-&gt;keys[i<span class="number">-1</span>];</span><br><span class="line">            parent-&gt;children[i<span class="number">+1</span>] = parent-&gt;children[i];</span><br><span class="line">        &#125;</span><br><span class="line">        parent-&gt;keys[idx] = key;</span><br><span class="line">        BTreeNode* newChild1 = <span class="keyword">new</span> <span class="built_in">BTreeNode</span>(order, child-&gt;isLeaf);</span><br><span class="line">        BTreeNode* newChild2 = <span class="keyword">new</span> <span class="built_in">BTreeNode</span>(order, child-&gt;isLeaf);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mid - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            newChild1-&gt;keys[i] = child-&gt;keys[i];</span><br><span class="line">            <span class="keyword">if</span> (!child-&gt;isLeaf) newChild1-&gt;children[i] = child-&gt;children[i];</span><br><span class="line">            newChild1-&gt;keyNum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!child-&gt;isLeaf) newChild1-&gt;children[mid - <span class="number">1</span>] = child-&gt;children[mid - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = mid; i &lt; order; i++) &#123;</span><br><span class="line">            newChild2-&gt;keys[i-mid] = child-&gt;keys[i];</span><br><span class="line">            <span class="keyword">if</span> (!child-&gt;isLeaf) newChild2-&gt;children[i-mid] = child-&gt;children[i];</span><br><span class="line">            newChild2-&gt;keyNum++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!child-&gt;isLeaf) newChild2-&gt;children[order-mid] = child-&gt;children[order];</span><br><span class="line"></span><br><span class="line">        parent-&gt;children[idx] = newChild1;</span><br><span class="line">        parent-&gt;children[idx<span class="number">+1</span>] = newChild2;</span><br><span class="line">        parent-&gt;keyNum++;</span><br><span class="line">        <span class="keyword">delete</span> child;</span><br><span class="line">    &#125; <span class="comment">// 分裂子结点,在子节点的关键字数目为m时</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(BTreeNode* node, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i=node-&gt;keyNum<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;isLeaf) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; key &lt; node-&gt;keys[i]) &#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i!=<span class="number">-1</span>&amp;&amp;key==node-&gt;keys[i]) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = node-&gt;keyNum; j &gt; i<span class="number">+1</span>; j--) &#123;</span><br><span class="line">                node-&gt;keys[j] = node-&gt;keys[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            node-&gt;keys[i<span class="number">+1</span>] = key;</span><br><span class="line">            node-&gt;keyNum++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; key &lt; node-&gt;keys[i]) &#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i!=<span class="number">-1</span>&amp;&amp;key==node-&gt;keys[i]) <span class="keyword">return</span>;</span><br><span class="line">            <span class="built_in">insert</span>(node-&gt;children[i<span class="number">+1</span>], key);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[i<span class="number">+1</span>]-&gt;keyNum == order) &#123;</span><br><span class="line">                <span class="built_in">splitChild</span>(node, i<span class="number">+1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 向结点插入关键字</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">removeKey</span><span class="params">(BTreeNode* node, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = node-&gt;keyNum - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;isLeaf) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; key &lt; node-&gt;keys[i]) &#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">-1</span> || key != node-&gt;keys[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            node-&gt;keyNum--;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i;j&lt;node-&gt;keyNum;j++)&#123;</span><br><span class="line">                node-&gt;keys[j]=node-&gt;keys[j<span class="number">+1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; key &lt; node-&gt;keys[i]) &#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="type">bool</span> res = <span class="built_in">removeKey</span>(node-&gt;children[<span class="number">0</span>], key);</span><br><span class="line">                <span class="keyword">if</span> (!res) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;children[<span class="number">0</span>]-&gt;keyNum &lt; minKeyNum) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (node-&gt;children[<span class="number">1</span>]-&gt;keyNum &gt; minKeyNum) &#123;</span><br><span class="line">                        <span class="built_in">borrowFromRight</span>(node, <span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">mergeChild</span>(node, <span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (key == node-&gt;keys[i]) &#123;</span><br><span class="line">                <span class="type">int</span> pre = <span class="built_in">getPredecessor</span>(node, i);</span><br><span class="line">                node-&gt;keys[i] = pre;</span><br><span class="line">                <span class="type">bool</span> res = <span class="built_in">removeKey</span>(node-&gt;children[i], pre);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!res) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;children[i]-&gt;keyNum &lt; minKeyNum) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; node-&gt;children[i<span class="number">-1</span>]-&gt;keyNum &gt; minKeyNum) &#123;</span><br><span class="line">                        <span class="built_in">borrowFromLeft</span>(node, i);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;children[i<span class="number">+1</span>]-&gt;keyNum &gt; minKeyNum) &#123;</span><br><span class="line">                        <span class="built_in">borrowFromRight</span>(node, i);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">mergeChild</span>(node, i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">bool</span> res = <span class="built_in">removeKey</span>(node-&gt;children[i<span class="number">+1</span>], key);</span><br><span class="line">                <span class="keyword">if</span> (!res) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;children[i<span class="number">+1</span>]-&gt;keyNum &lt; minKeyNum) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (node-&gt;children[i]-&gt;keyNum &gt; minKeyNum) &#123;</span><br><span class="line">                        <span class="built_in">borrowFromLeft</span>(node, i<span class="number">+1</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; node-&gt;keyNum<span class="number">-1</span> &amp;&amp; node-&gt;children[i<span class="number">+2</span>]-&gt;keyNum &gt; minKeyNum) &#123;</span><br><span class="line">                        <span class="built_in">borrowFromRight</span>(node, i<span class="number">+1</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">mergeChild</span>(node, i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从结点中删除关键字</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getPredecessor</span><span class="params">(BTreeNode* node, <span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">        BTreeNode* cur = node-&gt;children[idx];</span><br><span class="line">        <span class="keyword">while</span> (!cur-&gt;isLeaf) cur = cur-&gt;children[cur-&gt;keyNum];</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;keys[cur-&gt;keyNum<span class="number">-1</span>];</span><br><span class="line">    &#125; <span class="comment">// 获取前驱关键字</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并子结点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mergeChild</span><span class="params">(BTreeNode* parent, <span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">        BTreeNode* child1 = parent-&gt;children[idx];</span><br><span class="line">        BTreeNode* child2 = parent-&gt;children[idx<span class="number">+1</span>];</span><br><span class="line">        BTreeNode* child = <span class="keyword">new</span> <span class="built_in">BTreeNode</span>(order, child1-&gt;isLeaf);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; child1-&gt;keyNum; i++) &#123;</span><br><span class="line">            child-&gt;keys[child-&gt;keyNum++] = child1-&gt;keys[i];</span><br><span class="line">            <span class="keyword">if</span> (!child1-&gt;isLeaf) child-&gt;children[child-&gt;keyNum<span class="number">-1</span>] = child1-&gt;children[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!child1-&gt;isLeaf) child-&gt;children[child-&gt;keyNum] = child1-&gt;children[child1-&gt;keyNum];</span><br><span class="line">        child-&gt;keys[child-&gt;keyNum++] = parent-&gt;keys[idx];</span><br><span class="line">        <span class="keyword">if</span> (!child1-&gt;isLeaf) child-&gt;children[child-&gt;keyNum] = child2-&gt;children[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; child2-&gt;keyNum; i++) &#123;</span><br><span class="line">            child-&gt;keys[child-&gt;keyNum++] = child2-&gt;keys[i];</span><br><span class="line">            <span class="keyword">if</span> (!child2-&gt;isLeaf) child-&gt;children[child-&gt;keyNum] = child2-&gt;children[i<span class="number">+1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        parent-&gt;keyNum--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=idx;i&lt;parent-&gt;keyNum;i++)&#123;</span><br><span class="line">            parent-&gt;keys[i]=parent-&gt;keys[i<span class="number">+1</span>];</span><br><span class="line">            parent-&gt;children[i<span class="number">+1</span>]=parent-&gt;children[i<span class="number">+2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        parent-&gt;children[idx]=child;</span><br><span class="line">        <span class="keyword">delete</span> child1;</span><br><span class="line">        <span class="keyword">delete</span> child2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">borrowFromLeft</span><span class="params">(BTreeNode* parent, <span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        BTreeNode* leftBrother = parent-&gt;children[idx<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span> (leftBrother-&gt;keyNum &lt;= minKeyNum) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        BTreeNode* curChild = parent-&gt;children[idx];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = curChild-&gt;keyNum; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            curChild-&gt;keys[i] = curChild-&gt;keys[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span> (!curChild-&gt;isLeaf) curChild-&gt;children[i<span class="number">+1</span>] = curChild-&gt;children[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!curChild-&gt;isLeaf) curChild-&gt;children[<span class="number">1</span>] = curChild-&gt;children[<span class="number">0</span>];</span><br><span class="line">        curChild-&gt;keys[<span class="number">0</span>] = parent-&gt;keys[idx<span class="number">-1</span>];</span><br><span class="line">        parent-&gt;keys[idx<span class="number">-1</span>] = leftBrother-&gt;keys[leftBrother-&gt;keyNum<span class="number">-1</span>];</span><br><span class="line">        curChild-&gt;keyNum++;</span><br><span class="line">        <span class="keyword">if</span> (!curChild-&gt;isLeaf) curChild-&gt;children[<span class="number">0</span>] = leftBrother-&gt;children[leftBrother-&gt;keyNum];</span><br><span class="line">        leftBrother-&gt;keyNum--;</span><br><span class="line">    &#125; <span class="comment">// 向左兄弟借关键字</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSuccessor</span><span class="params">(BTreeNode* node, <span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">        BTreeNode* cur = node-&gt;children[idx<span class="number">+1</span>];</span><br><span class="line">        <span class="keyword">while</span> (!cur-&gt;isLeaf) cur = cur-&gt;children[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;keys[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="comment">// 获取后继关键字</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">borrowFromRight</span><span class="params">(BTreeNode* parent, <span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == parent-&gt;keyNum) <span class="keyword">return</span>;</span><br><span class="line">        BTreeNode* rightBrother = parent-&gt;children[idx<span class="number">+1</span>];</span><br><span class="line">        <span class="keyword">if</span> (rightBrother-&gt;keyNum &lt;= minKeyNum) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        BTreeNode* curChild = parent-&gt;children[idx];</span><br><span class="line">        curChild-&gt;keys[curChild-&gt;keyNum++] = parent-&gt;keys[idx];</span><br><span class="line">        parent-&gt;keys[idx] = rightBrother-&gt;keys[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (!curChild-&gt;isLeaf) &#123;</span><br><span class="line">            curChild-&gt;children[curChild-&gt;keyNum] = rightBrother-&gt;children[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rightBrother-&gt;keyNum--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;rightBrother-&gt;keyNum;i++)&#123;</span><br><span class="line">            rightBrother-&gt;keys[i] = rightBrother-&gt;keys[i<span class="number">+1</span>];</span><br><span class="line">            <span class="keyword">if</span> (!rightBrother-&gt;isLeaf) rightBrother-&gt;children[i] = rightBrother-&gt;children[i<span class="number">+1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!rightBrother-&gt;isLeaf) rightBrother-&gt;children[rightBrother-&gt;keyNum] = rightBrother-&gt;children[rightBrother-&gt;keyNum<span class="number">+1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向右兄弟借关键字</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isKeyExist</span><span class="params">(BTreeNode* node, <span class="type">int</span> key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="comment">// 查找关键字</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数（指定阶数m）</span></span><br><span class="line">    <span class="built_in">BTree</span>(<span class="type">int</span> m) : <span class="built_in">order</span>(m),<span class="built_in">minKeyNum</span>((m<span class="number">+1</span>)/<span class="number">2</span><span class="number">-1</span>) , <span class="built_in">root</span>(<span class="keyword">new</span> <span class="built_in">BTreeNode</span>(m, <span class="literal">true</span>)) &#123;&#125;</span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">BTree</span>() &#123; <span class="built_in">destroy</span>(root); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心接口声明</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">(BTreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= node-&gt;keyNum; ++i) &#123;</span><br><span class="line">            <span class="built_in">destroy</span>(node-&gt;children[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> node;</span><br><span class="line">        node= <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;              <span class="comment">// 递归销毁树</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(<span class="type">int</span> key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isKeyExist</span>(root, key);</span><br><span class="line">    &#125;             <span class="comment">// 查找关键字</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">insert</span>(root, key);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;keyNum == order) &#123;</span><br><span class="line">            BTreeNode* newRoot = <span class="keyword">new</span> <span class="built_in">BTreeNode</span>(order, <span class="literal">false</span>);</span><br><span class="line">            newRoot-&gt;children[<span class="number">0</span>] = root;</span><br><span class="line">            <span class="built_in">splitChild</span>(newRoot, <span class="number">0</span>);</span><br><span class="line">            root = newRoot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;                    <span class="comment">// 插入关键字</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> state = <span class="built_in">removeKey</span>(root, key);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;keyNum == <span class="number">0</span>&amp;&amp;!root-&gt;isLeaf) &#123;</span><br><span class="line">            BTreeNode* oldRoot = root;</span><br><span class="line">            root = root-&gt;children[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">delete</span> oldRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;                    <span class="comment">// 删除关键字</span></span><br><span class="line">    <span class="comment">// 对外接口：层次遍历打印树结构（完全重构，打印正确）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printTree</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span> || root-&gt;keyNum == <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;B-Tree is empty!&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;BTreeNode*&gt; curLayer;</span><br><span class="line">        curLayer.<span class="built_in">push_back</span>(root);</span><br><span class="line">        <span class="type">int</span> level = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!curLayer.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            vector&lt;BTreeNode*&gt; nextLayer;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Level &quot;</span> &lt;&lt; level &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> node : curLayer) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node == <span class="literal">nullptr</span> || node-&gt;keyNum == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 打印当前节点所有关键字</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; node-&gt;keyNum; ++i) &#123;</span><br><span class="line">                    cout &lt;&lt; node-&gt;keys[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;| &quot;</span>;</span><br><span class="line">                <span class="comment">// 收集下一层子节点</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= node-&gt;keyNum; ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (node-&gt;children[i] != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                        nextLayer.<span class="built_in">push_back</span>(node-&gt;children[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">            curLayer = nextLayer;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BPlusTree</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BPlusNode</span> &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; keys;</span><br><span class="line">        vector&lt;BPlusNode*&gt; children;</span><br><span class="line">        <span class="type">int</span> keyNum;</span><br><span class="line">        <span class="type">bool</span> isLeaf;</span><br><span class="line">        BPlusNode* nextLeaf;</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">BPlusNode</span><span class="params">(<span class="type">int</span> m,<span class="type">bool</span> leaf=<span class="literal">false</span>)</span>:keys(m<span class="number">+1</span>),children(m<span class="number">+1</span>),keyNum(<span class="number">0</span>),isLeaf(leaf),nextLeaf(nullptr)&#123;</span></span><br><span class="line">            <span class="built_in">fill</span>(children.<span class="built_in">begin</span>(),children.<span class="built_in">end</span>(),<span class="literal">nullptr</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> order, minKeyNum;</span><br><span class="line">    BPlusNode* root;</span><br><span class="line">    BPlusNode* headLeaf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ---------- split ---------- */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">splitChild</span><span class="params">(BPlusNode* parent,<span class="type">int</span> idx)</span></span>&#123;</span><br><span class="line">        BPlusNode* child = parent-&gt;children[idx];</span><br><span class="line">        <span class="type">int</span> mid = (order + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> key= child-&gt;keys[mid<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=parent-&gt;keyNum<span class="number">-1</span>;i&gt;=idx;i--) &#123;</span><br><span class="line">            parent-&gt;keys[i<span class="number">+1</span>]=parent-&gt;keys[i];</span><br><span class="line">            parent-&gt;children[i<span class="number">+1</span>]=parent-&gt;children[i];</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        cout&lt;&lt;key&lt;&lt;endl;</span></span><br><span class="line">        parent-&gt;keys[idx]=key;</span><br><span class="line">        parent-&gt;keyNum++;</span><br><span class="line"></span><br><span class="line">        BPlusNode* idxNode = <span class="keyword">new</span> <span class="built_in">BPlusNode</span>(order,child-&gt;isLeaf);</span><br><span class="line">        BPlusNode* idxAdd1Node = <span class="keyword">new</span> <span class="built_in">BPlusNode</span>(order,child-&gt;isLeaf);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=mid<span class="number">-1</span>;i++) &#123;</span><br><span class="line">            idxNode-&gt;keys[i]=child-&gt;keys[i];</span><br><span class="line">            <span class="keyword">if</span> (!child-&gt;isLeaf) idxNode-&gt;children[i]=child-&gt;children[i];</span><br><span class="line">        &#125;</span><br><span class="line">        idxNode-&gt;keyNum=mid;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=mid;i&lt;child-&gt;keyNum;i++) &#123;</span><br><span class="line">            idxAdd1Node-&gt;keys[i-mid]=child-&gt;keys[i];</span><br><span class="line">            <span class="keyword">if</span> (!child-&gt;isLeaf) idxAdd1Node-&gt;children[i-mid]=child-&gt;children[i];</span><br><span class="line">        &#125;</span><br><span class="line">        idxAdd1Node-&gt;keyNum=child-&gt;keyNum-mid;</span><br><span class="line">        <span class="keyword">if</span> (child-&gt;isLeaf) &#123;</span><br><span class="line">            <span class="keyword">if</span> (idx&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                parent-&gt;children[idx<span class="number">-1</span>]-&gt;nextLeaf=idxNode;</span><br><span class="line">            &#125;</span><br><span class="line">            idxNode-&gt;nextLeaf=idxAdd1Node;</span><br><span class="line">            idxAdd1Node-&gt;nextLeaf=child-&gt;nextLeaf;</span><br><span class="line">        &#125;</span><br><span class="line">        parent-&gt;children[idx]=idxNode;</span><br><span class="line">        parent-&gt;children[idx<span class="number">+1</span>]=idxAdd1Node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ---------- insert ---------- */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(BPlusNode* x,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="comment">//        cout&lt;&lt;k&lt;&lt;&#x27; &#x27;&lt;&lt;x-&gt;keyNum&lt;&lt;endl;</span></span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;x-&gt;keyNum&amp;&amp;x-&gt;keys[i]&lt;k) i++;</span><br><span class="line"><span class="comment">//        cout&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span> (x-&gt;isLeaf) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i==x-&gt;keyNum) &#123;</span><br><span class="line">                x-&gt;keys[i]=k;</span><br><span class="line">                x-&gt;keyNum++;</span><br><span class="line"><span class="comment">//                cout&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (k==x-&gt;keys[i]) <span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=x-&gt;keyNum<span class="number">-1</span>;j&gt;=i;j--) &#123;</span><br><span class="line">                    x-&gt;keys[j<span class="number">+1</span>]=x-&gt;keys[j];</span><br><span class="line">                &#125;</span><br><span class="line">                x-&gt;keys[i]=k;</span><br><span class="line">                x-&gt;keyNum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i==x-&gt;keyNum) &#123;</span><br><span class="line">                <span class="built_in">insert</span>(x-&gt;children[i<span class="number">-1</span>], k);</span><br><span class="line">                x-&gt;keys[i<span class="number">-1</span>]=k;</span><br><span class="line">                <span class="keyword">if</span> (x-&gt;children[i<span class="number">-1</span>]-&gt;keyNum==order<span class="number">+1</span>) <span class="built_in">splitChild</span>(x,i<span class="number">-1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (k==x-&gt;keys[i]) <span class="keyword">return</span>;</span><br><span class="line">                <span class="built_in">insert</span>(x-&gt;children[i],k);</span><br><span class="line">                <span class="keyword">if</span> (x-&gt;children[i]-&gt;keyNum==order<span class="number">+1</span>) <span class="built_in">splitChild</span>(x,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ---------- search ---------- */</span></span><br><span class="line">    <span class="function">BPlusNode* <span class="title">findLeafNode</span><span class="params">(BPlusNode* x,<span class="type">int</span> k)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;x-&gt;keyNum &amp;&amp; x-&gt;keys[i]&lt;k) i++;</span><br><span class="line">        <span class="keyword">if</span> (i==x-&gt;keyNum) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (x-&gt;isLeaf) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (x-&gt;keys[i]==k) <span class="keyword">return</span> x;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findLeafNode</span>(x-&gt;children[i],k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ---------- borrow &amp; merge ---------- */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">borrowFromLeft</span><span class="params">(BPlusNode* p,<span class="type">int</span> idx)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        BPlusNode* left = p-&gt;children[idx<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span> (left-&gt;keyNum==minKeyNum) <span class="keyword">return</span>;</span><br><span class="line">        BPlusNode* cur = p-&gt;children[idx];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=cur-&gt;keyNum<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">            cur-&gt;keys[i<span class="number">+1</span>]=cur-&gt;keys[i];</span><br><span class="line">            <span class="keyword">if</span> (!cur-&gt;isLeaf) cur-&gt;children[i<span class="number">+1</span>]=cur-&gt;children[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;keys[<span class="number">0</span>]=p-&gt;keys[idx<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span> (!cur-&gt;isLeaf) cur-&gt;children[<span class="number">0</span>]=left-&gt;children[left-&gt;keyNum<span class="number">-1</span>];</span><br><span class="line">        cur-&gt;keyNum++;</span><br><span class="line">        left-&gt;keyNum--;</span><br><span class="line">        p-&gt;keys[idx<span class="number">-1</span>]=left-&gt;keys[left-&gt;keyNum<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">borrowFromRight</span><span class="params">(BPlusNode* p,<span class="type">int</span> idx)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx==p-&gt;keyNum<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        BPlusNode* right = p-&gt;children[idx<span class="number">+1</span>];</span><br><span class="line">        <span class="keyword">if</span> (right-&gt;keyNum==minKeyNum) <span class="keyword">return</span>;</span><br><span class="line">        BPlusNode* cur = p-&gt;children[idx];</span><br><span class="line">        cur-&gt;keys[cur-&gt;keyNum]=right-&gt;keys[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (!cur-&gt;isLeaf) cur-&gt;children[cur-&gt;keyNum]=right-&gt;children[<span class="number">0</span>];</span><br><span class="line">        cur-&gt;keyNum++;</span><br><span class="line">        right-&gt;keyNum--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;right-&gt;keyNum;i++) &#123;</span><br><span class="line">            right-&gt;keys[i]=right-&gt;keys[i<span class="number">+1</span>];</span><br><span class="line">            <span class="keyword">if</span> (!right-&gt;isLeaf) right-&gt;children[i]=right-&gt;children[i<span class="number">+1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;keys[idx]=right-&gt;keys[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mergeChild</span><span class="params">(BPlusNode* p,<span class="type">int</span> idx)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx==p-&gt;keyNum<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        BPlusNode* left = p-&gt;children[idx];</span><br><span class="line">        BPlusNode* right = p-&gt;children[idx<span class="number">+1</span>];</span><br><span class="line">        BPlusNode* merge = <span class="keyword">new</span> <span class="built_in">BPlusNode</span>(order,left-&gt;isLeaf);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;left-&gt;keyNum;i++) &#123;</span><br><span class="line">            merge-&gt;keys[i] = left-&gt;keys[i];</span><br><span class="line">            <span class="keyword">if</span> (!left-&gt;isLeaf) merge-&gt;children[i]=left-&gt;children[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;right-&gt;keyNum;i++) &#123;</span><br><span class="line">            merge-&gt;keys[left-&gt;keyNum+i] = right-&gt;keys[i];</span><br><span class="line">            <span class="keyword">if</span> (!right-&gt;isLeaf) merge-&gt;children[left-&gt;keyNum+i]=right-&gt;children[i];</span><br><span class="line">        &#125;</span><br><span class="line">        merge-&gt;keyNum=left-&gt;keyNum+right-&gt;keyNum;</span><br><span class="line">        <span class="keyword">if</span> (left-&gt;isLeaf) &#123;</span><br><span class="line">            <span class="keyword">if</span> (idx&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                p-&gt;children[idx<span class="number">-1</span>]-&gt;nextLeaf=merge;</span><br><span class="line">            &#125;</span><br><span class="line">            merge-&gt;nextLeaf=right-&gt;nextLeaf;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;keyNum--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=idx;i&lt;p-&gt;keyNum;i++) &#123;</span><br><span class="line">            p-&gt;keys[i]=p-&gt;keys[i<span class="number">+1</span>];</span><br><span class="line">            p-&gt;children[i]=p-&gt;children[i<span class="number">+1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;children[idx]=merge;</span><br><span class="line">        <span class="keyword">delete</span> left;</span><br><span class="line">        <span class="keyword">delete</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">removeNode</span><span class="params">(BPlusNode* x,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;x-&gt;keyNum &amp;&amp; x-&gt;keys[i]&lt;k) i++;</span><br><span class="line">        <span class="keyword">if</span> (i==x-&gt;keyNum) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (x-&gt;isLeaf) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x-&gt;keys[i]==k) &#123;</span><br><span class="line">                x-&gt;keyNum--;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=i;j&lt;x-&gt;keyNum;j++) &#123;</span><br><span class="line">                    x-&gt;keys[j]=x-&gt;keys[j<span class="number">+1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">removeNode</span>(x-&gt;children[i],k)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            x-&gt;keys[i]=x-&gt;children[i]-&gt;keys[x-&gt;children[i]-&gt;keyNum<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span> (x-&gt;children[i]-&gt;keyNum&lt;minKeyNum) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i&gt;<span class="number">0</span>&amp;&amp;x-&gt;children[i<span class="number">-1</span>]-&gt;keyNum&gt;minKeyNum) <span class="built_in">borrowFromLeft</span>(x,i);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i&lt;x-&gt;keyNum<span class="number">-1</span>&amp;&amp;x-&gt;children[i<span class="number">+1</span>]-&gt;keyNum&gt;minKeyNum) <span class="built_in">borrowFromRight</span>(x,i);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i==x-&gt;keyNum<span class="number">-1</span>) <span class="built_in">mergeChild</span>(x,i<span class="number">-1</span>);</span><br><span class="line">                    <span class="keyword">else</span> <span class="built_in">mergeChild</span>(x,i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BPlusNode* <span class="title">findFirstLeafNode</span><span class="params">(BPlusNode* x,<span class="type">int</span> k)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;x-&gt;keyNum &amp;&amp; x-&gt;keys[i]&lt;k) i++;</span><br><span class="line">        <span class="keyword">if</span> (i==x-&gt;keyNum) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (x-&gt;isLeaf) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findFirstLeafNode</span>(x-&gt;children[i],k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">BPlusTree</span><span class="params">(<span class="type">int</span> m)</span>:order(m),minKeyNum(m/<span class="number">2</span>),root(new BPlusNode(m,true)),headLeaf(root)&#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="built_in">insert</span>(root,k);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;keyNum==order<span class="number">+1</span>)&#123;</span><br><span class="line">            BPlusNode* s=<span class="keyword">new</span> <span class="built_in">BPlusNode</span>(order,<span class="literal">false</span>);</span><br><span class="line">            s-&gt;keys[<span class="number">0</span>]=root-&gt;keys[order];</span><br><span class="line">            s-&gt;children[<span class="number">0</span>]=root;</span><br><span class="line">            s-&gt;keyNum++;</span><br><span class="line">            <span class="built_in">splitChild</span>(s,<span class="number">0</span>);</span><br><span class="line">            root=s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [[nodiscard]] <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(<span class="type">int</span> k)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        BPlusNode* l=<span class="built_in">findLeafNode</span>(root,k);</span><br><span class="line">        <span class="keyword">if</span>(l) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">removeNode</span>(root,k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printLeafLink</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        BPlusNode* p=root;</span><br><span class="line">        <span class="keyword">while</span>(!p-&gt;isLeaf) p=p-&gt;children[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p-&gt;keyNum;i++) cout&lt;&lt;p-&gt;keys[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            p=p-&gt;nextLeaf;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printTree</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span> || root-&gt;keyNum == <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;B-Tree is empty!&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;BPlusNode*&gt; curLayer;</span><br><span class="line">        curLayer.<span class="built_in">push_back</span>(root);</span><br><span class="line">        <span class="type">int</span> level = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!curLayer.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            vector&lt;BPlusNode*&gt; nextLayer;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Level &quot;</span> &lt;&lt; level &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> node : curLayer) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node == <span class="literal">nullptr</span> || node-&gt;keyNum == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 打印当前节点所有关键字</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; node-&gt;keyNum; ++i) &#123;</span><br><span class="line">                    cout &lt;&lt; node-&gt;keys[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;| &quot;</span>;</span><br><span class="line">                <span class="comment">// 收集下一层子节点</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; node-&gt;keyNum; ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (node-&gt;children[i] != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                        nextLayer.<span class="built_in">push_back</span>(node-&gt;children[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">            curLayer = nextLayer;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printLeafLink</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rangeSearch</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        BPlusNode* p = <span class="built_in">findFirstLeafNode</span>(root, l);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">nullptr</span> &amp;&amp; p-&gt;keys[<span class="number">0</span>] &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;p-&gt;keyNum;i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;keys[i] &gt;= l &amp;&amp; p-&gt;keys[i]&lt;=r) result.<span class="built_in">push_back</span>(p-&gt;keys[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;nextLeaf;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="11-图">11, 图</h3>
<h4 id="1-广搜与深搜（图的遍历）">(1), 广搜与深搜（图的遍历）</h4>
<h5 id="定义-3">定义</h5>
<ul>
<li>广搜（BFS）：从图的某个顶点出发，先访问该顶点，然后依次访问该顶点的所有未被访问过的邻接顶点，再按此规则访问这些邻接顶点的未被访问过的邻接顶点，直到所有顶点都被访问过。</li>
<li>深搜（DFS）：从图的某个顶点出发，先访问该顶点，然后依次访问该顶点的所有未被访问过的邻接顶点，再按此规则访问这些邻接顶点的未被访问过的邻接顶点，直到所有顶点都被访问过。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GraphTraversal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 深度优先搜索（DFS）- 邻接矩阵实现</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">DFS_AM</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph, <span class="type">int</span> startIdx, vector&lt;<span class="type">bool</span>&gt;&amp; visited, <span class="type">void</span> (*visit)(<span class="type">int</span>))</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[startIdx]) <span class="keyword">return</span>;</span><br><span class="line">        visited[startIdx] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">visit</span>(startIdx);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph[startIdx].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (graph[startIdx][i] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">DFS_AM</span>(graph, i, visited, visit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 深度优先搜索（DFS）- 邻接表实现</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">DFS_AL</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph, <span class="type">int</span> startIdx, vector&lt;<span class="type">bool</span>&gt;&amp; visited, <span class="type">void</span> (*visit)(<span class="type">int</span>))</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[startIdx]) <span class="keyword">return</span>;</span><br><span class="line">        visited[startIdx] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">visit</span>(startIdx);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> nxt: graph[startIdx]) &#123;</span><br><span class="line">            <span class="built_in">DFS_AL</span>(graph, nxt, visited, visit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 广度优先搜索（BFS）- 邻接矩阵实现</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">BFS_AM</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph, <span class="type">int</span> startIdx, vector&lt;<span class="type">bool</span>&gt;&amp; visited, <span class="type">void</span> (*visit)(<span class="type">int</span>))</span> </span>&#123;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(startIdx);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (visited[cur]) <span class="keyword">continue</span>;</span><br><span class="line">            visited[cur] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">visit</span>(cur);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph[cur].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (graph[cur][i] == <span class="number">1</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 广度优先搜索（BFS）- 邻接表实现</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">BFS_AL</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph, <span class="type">int</span> startIdx, vector&lt;<span class="type">bool</span>&gt;&amp; visited, <span class="type">void</span> (*visit)(<span class="type">int</span>))</span> </span>&#123;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(startIdx);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (visited[cur]) <span class="keyword">continue</span>;</span><br><span class="line">            visited[cur] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">visit</span>(cur);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> nxt: graph[cur]) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(nxt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全图遍历（处理非连通图）</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">traverseAll_AM</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph, <span class="type">void</span> (*visit)(<span class="type">int</span>))</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(graph.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                <span class="built_in">BFS_AM</span>(graph, i, visited, visit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">traverseAll_AL</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph, <span class="type">void</span> (*visit)(<span class="type">int</span>))</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(graph.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                <span class="built_in">BFS_AL</span>(graph, i, visited, visit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-最小生成树">(2), 最小生成树</h4>
<h5 id="Prim算法介绍">Prim算法介绍</h5>
<p>Prim算法是一种贪心算法，用于在加权无向图中找到最小生成树（MST）。给定一个加权无向图，该算法从一个顶点开始，逐步扩展生成树，每次选择一个与生成树相连且权重最小的顶点加入生成树，直到所有顶点都被包含在生成树中。使用与稠密图相关的邻接矩阵表示图，时间复杂度为O(V^2)，其中V为顶点数。</p>
<h5 id="Kruskal算法介绍">Kruskal算法介绍</h5>
<p>Kruskal算法也是一种贪心算法，用于在加权无向图中找到最小生成树（MST）。该算法按照边的权重从小到大排序，依次选择权重最小的边加入生成树，直到所有顶点都被包含在生成树中。使用并查集数据结构来判断加入边是否会形成环，时间复杂度为O(ElogV)，其中E为边数，V为顶点数。</p>
<h5 id="并查集">并查集</h5>
<p>并查集是一种数据结构，用于处理一些不相交集合的合并及查询问题。它支持两种操作：查找（Find）和合并（Union）。查找操作可以确定一个元素所属的集合，合并操作可以将两个集合合并为一个集合。并查集通常用于解决图论中的连通性问题，例如判断图中是否存在环。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并查集</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Union</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; father;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Union</span>(<span class="type">int</span> n) : <span class="built_in">father</span>(n), <span class="built_in">n</span>(n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            father[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (father[x] == x) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        father[x] = <span class="built_in">find</span>(father[x]);</span><br><span class="line">        <span class="keyword">return</span> father[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> fx = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="type">int</span> fy = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (fx != fy) &#123;</span><br><span class="line">            father[fx] = fy;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isConnected</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphConnectivity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Prim</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=graph.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inMST</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minAdj</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minWeight</span><span class="params">(n, INT_MAX)</span></span>;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">minWeights</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, INT_MAX));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; edge:graph[i]) &#123;</span><br><span class="line">                minWeights[i][edge.first] = edge.second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inMST[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            minWeight[i] = minWeights[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; resEdges;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> totalWeight = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> cnt=<span class="number">0</span>;cnt&lt;n<span class="number">-1</span>;cnt++)&#123;</span><br><span class="line">            <span class="type">int</span> minW = INT_MAX;</span><br><span class="line">            <span class="type">int</span> u=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!inMST[i] &amp;&amp; minWeight[i] &lt; minW)&#123;</span><br><span class="line">                    minW = minWeight[i];</span><br><span class="line">                    u = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            inMST[u] = <span class="literal">true</span>;</span><br><span class="line">            resEdges.<span class="built_in">push_back</span>(&#123;minAdj[u],u&#125;);</span><br><span class="line">            totalWeight += minW;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!inMST[i] &amp;&amp; minWeights[u][i] &lt; minWeight[i])&#123;</span><br><span class="line">                    minWeight[i] = minWeights[u][i];</span><br><span class="line">                    minAdj[i] = u;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; edge: resEdges) &#123;</span><br><span class="line">            cout&lt;&lt;edge[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; edge[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; totalWeight &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Kruskal算法计算最小生成树的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Kruskal</span><span class="params">(<span class="type">int</span> n,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>(), [](vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">2</span>] &lt; b[<span class="number">2</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="function">Union <span class="title">uf</span><span class="params">(n)</span></span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; resEdges;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> totalWeight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; edge: edges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (uf.<span class="built_in">isConnected</span>(edge[<span class="number">0</span>], edge[<span class="number">1</span>])) <span class="keyword">continue</span>;</span><br><span class="line">            uf.<span class="built_in">join</span>(edge[<span class="number">0</span>], edge[<span class="number">1</span>]);</span><br><span class="line">            resEdges.<span class="built_in">push_back</span>(edge);</span><br><span class="line">            totalWeight += edge[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; edge: resEdges) &#123;</span><br><span class="line">            cout&lt;&lt;edge[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; edge[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; totalWeight &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="3-拓扑排序与关键路径">(3), 拓扑排序与关键路径</h4>
<h5 id="定义-4">定义</h5>
<p>拓扑排序是对有向无环图（DAG）的顶点进行排序，使得对于图中的每一条有向边 (u, v)，顶点 u 在排序中都出现在顶点 v 之前。拓扑排序的结果可以唯一确定一个拓扑序列</p>
<h5 id="应用场景">应用场景</h5>
<p>关键字路径问题：在项目中，关键路径指的是从开始到结束的一系列活动（或任务），这些活动的完成顺序不能改变，否则整个项目将无法按时完成。<br>
找到第i个关键路径：在拓扑排序的基础上，可以找到从源点到汇点的最长路径。<br>
找到每个节点的 最早开始时间和最晚开始时间，从而确定关键路径。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DAGApplications</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 1. 拓扑排序（邻接表实现，返回拓扑序列）</span></span><br><span class="line">    <span class="function"><span class="type">static</span> vector&lt;<span class="type">int</span>&gt; <span class="title">topologicalSort</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inDegrees</span><span class="params">(graph.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;graph.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j:graph[i])&#123;</span><br><span class="line">                inDegrees[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; inDegrees.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inDegrees[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(cur);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> nxt: graph[cur]) &#123;</span><br><span class="line">                inDegrees[nxt]--;</span><br><span class="line">                <span class="keyword">if</span> (inDegrees[nxt] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(nxt);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 关键路径（AOE网，邻接表实现）</span></span><br><span class="line">    <span class="comment">// 参数：graph=AOE网，criticalEdges=存储关键边（v1,v2），edgeCount=关键边数量</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">criticalPath</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt;&amp; graph, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; criticalEdges, <span class="type">int</span>&amp; projectTime)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=graph.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inDegrees</span><span class="params">(graph.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;graph.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> [j, w] : graph[i])&#123;</span><br><span class="line">                inDegrees[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">VE</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="type">int</span> c=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; inDegrees.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inDegrees[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">                VE[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> cur=q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            c++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> [nxt, w]:graph[cur])&#123;</span><br><span class="line">                inDegrees[nxt]--;</span><br><span class="line">                <span class="keyword">if</span> (inDegrees[nxt] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(nxt);</span><br><span class="line">                &#125;</span><br><span class="line">                VE[nxt]=<span class="built_in">max</span>(VE[nxt],VE[cur]+w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c != n) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;The graph is not a DAG.&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">VL</span><span class="params">(n,INT_MAX)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">outDegrees</span><span class="params">(graph.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        vector&lt;vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; <span class="built_in">reverseGraph</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;graph.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> [j, w] : graph[i])&#123;</span><br><span class="line">                outDegrees[i]++;</span><br><span class="line">                reverseGraph[j].<span class="built_in">push_back</span>(&#123;i,w&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        projectTime=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; outDegrees.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (outDegrees[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">                VL[i]=VE[i];</span><br><span class="line">                projectTime=<span class="built_in">max</span>(projectTime,VL[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> cur=q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> [pre, w]:reverseGraph[cur])&#123;</span><br><span class="line">                outDegrees[pre]--;</span><br><span class="line">                <span class="keyword">if</span> (outDegrees[pre]== <span class="number">0</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(pre);</span><br><span class="line">                &#125;</span><br><span class="line">                VL[pre]=<span class="built_in">min</span>(VL[pre],VL[cur]-w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> [j, w]:graph[i])&#123;</span><br><span class="line">                <span class="keyword">if</span> (VE[i]+w==VL[j])&#123;</span><br><span class="line">                    criticalEdges.<span class="built_in">push_back</span>(&#123;i,j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="4-最短路径">(4), 最短路径</h4>
<h5 id="定义-5">定义</h5>
<p>最短路径问题是指在一个加权图中，找到从源点到汇点的最短路径。最短路径问题有多种算法，包括Dijkstra算法、Bellman-Ford算法和Floyd-Warshall算法。</p>
<h5 id="应用场景-2">应用场景</h5>
<ol>
<li>地图导航：在地图导航中，最短路径算法可以用于计算从起点到终点的最短路径。</li>
<li>网络路由：在网络中，最短路径算法可以用于计算从一个路由器到另一个路由器的最佳路径。</li>
<li>项目管理：在项目中，最短路径算法可以用于计算从项目开始到结束的最短时间。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ShortestPath</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 2. 单源最短路径 - Dijkstra算法（邻接表实现）</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt;&amp; graph, <span class="type">int</span> startIdx, vector&lt;<span class="type">int</span>&gt;&amp; dist)</span> </span>&#123;</span><br><span class="line">        dist.<span class="built_in">resize</span>(graph.<span class="built_in">size</span>(), INT_MAX);</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt; pq;</span><br><span class="line">        pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>,startIdx&#125;);</span><br><span class="line">        dist[startIdx]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [d, cur] = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (d &gt; dist[cur]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> [nxt, w]: graph[cur]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dist[cur] + w&lt;dist[nxt]) &#123;</span><br><span class="line">                    dist[nxt] = dist[cur] + w;</span><br><span class="line">                    pq.<span class="built_in">push</span>(&#123;dist[nxt], nxt&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ExamDijkstra</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt;&amp; graph, <span class="type">int</span> startIdx, vector&lt;<span class="type">int</span>&gt;&amp; dist)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=graph.<span class="built_in">size</span>();</span><br><span class="line">        dist.<span class="built_in">resize</span>(n, INT_MAX);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">minDist</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, INT_MAX));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; edge:graph[i]) &#123;</span><br><span class="line">                minDist[i][edge.first] = edge.second;</span><br><span class="line">            &#125;</span><br><span class="line">            minDist[i][i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            dist[i]=minDist[startIdx][i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cout&lt;&lt;dist[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> minIdx=<span class="number">-1</span>;</span><br><span class="line">            <span class="type">int</span> minVal=INT_MAX;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[j] &amp;&amp; dist[j]&lt;minVal)&#123;</span><br><span class="line">                    minIdx=j;</span><br><span class="line">                    minVal=dist[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (minIdx==<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">            visited[minIdx]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [j,w]:graph[minIdx])&#123;</span><br><span class="line">                <span class="keyword">if</span> (dist[minIdx]+w&lt;dist[j]) &#123;</span><br><span class="line">                    dist[j]=dist[minIdx]+w;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                cout&lt;&lt;dist[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 多源最短路径 - Floyd算法（邻接矩阵实现）</span></span><br><span class="line">    <span class="comment">// 参数：graph=带权图，dist=存储任意两点间最短路径长度，path=存储路径中间节点</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Floyd</span><span class="params">(<span class="type">int</span> n,<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; dist, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; path)</span> </span>&#123;</span><br><span class="line">        dist.<span class="built_in">resize</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,INT_MAX));</span><br><span class="line">        path.<span class="built_in">resize</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            dist[i][i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; edge:edges)&#123;</span><br><span class="line">            dist[edge[<span class="number">0</span>]][edge[<span class="number">1</span>]]=edge[<span class="number">2</span>];</span><br><span class="line">            path[edge[<span class="number">0</span>]][edge[<span class="number">1</span>]]=<span class="number">-2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dist[i][k]!=INT_MAX &amp;&amp; dist[k][j]!=INT_MAX &amp;&amp; dist[i][j] &gt; dist[i][k] + dist[k][j]) &#123;</span><br><span class="line">                        dist[i][j] = dist[i][k] + dist[k][j];</span><br><span class="line">                        path[i][j] = k;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助接口：打印最短路径（从源点start到终点end）</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">printPath</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; paths, vector&lt;<span class="type">int</span>&gt;&amp; path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start==end) &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(start);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=paths[start][end];</span><br><span class="line">        <span class="keyword">if</span> (mid==<span class="number">-1</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Not reachable&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mid==<span class="number">-2</span>)&#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(start);</span><br><span class="line">            path.<span class="built_in">push_back</span>(end);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printPath</span>(start,mid,paths,path);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="built_in">printPath</span>(mid,end,paths,path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="12-搜索">12, 搜索</h3>
<h4 id="1-线性探测哈希">(1), 线性探测哈希</h4>
<p>这里用一个有限map来表示</p>
<p>当发生哈希冲突时，线性探测会顺序检查下一个下标，直到找到空闲位置或遍历完所有下标。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哈希表：开放定址法（线性探测）实现，固定容量BASE</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Unordered_Map_Limit</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> BASE = <span class="number">1000</span>; <span class="comment">// 编译期常量，更高效</span></span><br><span class="line">    vector&lt;pair&lt;K, V&gt;&gt; data;         <span class="comment">// 存储键值对的核心数组</span></span><br><span class="line">    <span class="type">bool</span>* is_occupied;               <span class="comment">// 标记下标是否被占用（解决删除后查找失效）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希函数：映射key到[0, BASE-1]的整数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hash</span><span class="params">(<span class="type">const</span> K&amp; key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> hash_val = std::hash&lt;K&gt;&#123;&#125;(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(hash_val % BASE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找函数：返回key对应下标，未找到返回-1</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">const</span> K&amp; key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> idx = <span class="built_in">hash</span>(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; BASE; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> cur_idx = (idx + i) % BASE;</span><br><span class="line">            <span class="keyword">if</span> (!is_occupied[cur_idx]) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span> (data[cur_idx].first == key) <span class="keyword">return</span> cur_idx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 哈希表满，未找到</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数：初始化数组+占用标记</span></span><br><span class="line">    <span class="built_in">Unordered_Map_Limit</span>() : <span class="built_in">data</span>(BASE), <span class="built_in">is_occupied</span>(<span class="keyword">new</span> <span class="type">bool</span>[BASE]&#123;<span class="literal">false</span>&#125;) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数：释放动态内存，防止泄漏</span></span><br><span class="line">    ~<span class="built_in">Unordered_Map_Limit</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] is_occupied;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入/更新键值对：存在则更新，不存在则插入</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> K&amp; key, <span class="type">const</span> V&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> idx = <span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (idx != <span class="number">-1</span>) &#123;</span><br><span class="line">            data[idx].second = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> hash_idx = <span class="built_in">hash</span>(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; BASE; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> cur_idx = (hash_idx + i) % BASE;</span><br><span class="line">            <span class="keyword">if</span> (!is_occupied[cur_idx]) &#123;</span><br><span class="line">                data[cur_idx] = <span class="built_in">make_pair</span>(key, value);</span><br><span class="line">                is_occupied[cur_idx] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除指定key：成功true，失败false</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">erase</span><span class="params">(<span class="type">const</span> K&amp; key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> idx = <span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (idx == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        is_occupied[idx] = <span class="literal">false</span>; <span class="comment">// 逻辑删除，保留探测链</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找key：存在则赋值value并返回true，否则false</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">get</span><span class="params">(<span class="type">const</span> K&amp; key, V&amp; value)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> idx = <span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (idx == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        value = data[idx].second;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载[]运算符：支持map[key]读写，与std库行为一致</span></span><br><span class="line">    V&amp; <span class="keyword">operator</span>[](<span class="type">const</span> K&amp; key) &#123;</span><br><span class="line">        <span class="type">int</span> idx = <span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (idx != <span class="number">-1</span>) <span class="keyword">return</span> data[idx].second;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> hash_idx = <span class="built_in">hash</span>(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; BASE; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> cur_idx = (hash_idx + i) % BASE;</span><br><span class="line">            <span class="keyword">if</span> (!is_occupied[cur_idx]) &#123;</span><br><span class="line">                data[cur_idx] = <span class="built_in">make_pair</span>(key, <span class="built_in">V</span>());</span><br><span class="line">                is_occupied[cur_idx] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span> data[cur_idx].second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Unordered_Map_Limit is full!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断哈希表是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; BASE; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (is_occupied[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取有效键值对数量</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; BASE; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (is_occupied[i]) cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-无序字典（Unordered-Dictionary）">(2), 无序字典（Unordered Dictionary）</h4>
<p>使用哈希函数，当发生哈希冲突时，使用链地址法解决。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哈希表：链地址法实现，无容量上限，冲突处理更友好</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Unordered_Map</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> BASE = <span class="number">1000</span>;</span><br><span class="line">    vector&lt;vector&lt;pair&lt;K, V&gt;&gt;&gt; data; <span class="comment">// 桶数组：每个桶是一个键值对链表</span></span><br><span class="line">    <span class="type">const</span> pair&lt;K, V&gt; EMPTY_NODE;     <span class="comment">// 空节点标记</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希函数：映射key到桶下标</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hash</span><span class="params">(<span class="type">const</span> K&amp; key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> hash_val = std::hash&lt;K&gt;&#123;&#125;(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(hash_val % BASE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找key：返回对应桶的下标，未找到返回-1（核心修复）</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find_index</span><span class="params">(<span class="type">const</span> K&amp; key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> idx = <span class="built_in">hash</span>(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; bucket : data[idx]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucket.first == key) <span class="keyword">return</span> idx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找迭代器：返回桶内目标元素的迭代器（核心修复）</span></span><br><span class="line">    <span class="keyword">typename</span> vector&lt;pair&lt;K, V&gt;&gt;::<span class="function">iterator <span class="title">find_iter</span><span class="params">(<span class="type">const</span> K&amp; key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> idx = <span class="built_in">hash</span>(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = data[idx].<span class="built_in">begin</span>(); it != data[idx].<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            <span class="keyword">if</span> (it-&gt;first == key) <span class="keyword">return</span> it;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data[idx].<span class="built_in">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新key对应的value</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">const</span> K&amp; key, <span class="type">const</span> V&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = <span class="built_in">find_iter</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it != data[<span class="built_in">hash</span>(key)].<span class="built_in">end</span>()) &#123;</span><br><span class="line">            it-&gt;second = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数：初始化桶数组+空节点</span></span><br><span class="line">    <span class="built_in">Unordered_Map</span>() : <span class="built_in">data</span>(BASE), <span class="built_in">EMPTY_NODE</span>(<span class="built_in">K</span>(), <span class="built_in">V</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数：vector自动释放内存，无需手动操作</span></span><br><span class="line">    ~<span class="built_in">Unordered_Map</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入/更新键值对</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> K&amp; key, <span class="type">const</span> V&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find_index</span>(key) != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">update</span>(key, value);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> hash_idx = <span class="built_in">hash</span>(key);</span><br><span class="line">        data[hash_idx].<span class="built_in">emplace_back</span>(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除指定key</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">erase</span><span class="params">(<span class="type">const</span> K&amp; key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> idx = <span class="built_in">hash</span>(key);</span><br><span class="line">        <span class="keyword">auto</span> it = <span class="built_in">find_iter</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it == data[idx].<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        data[idx].<span class="built_in">erase</span>(it); <span class="comment">// 迭代器直接删除，安全无失效</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找key的value，未找到返回默认值</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="type">const</span> K&amp; key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> idx = <span class="built_in">hash</span>(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; bucket : data[idx]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucket.first == key) <span class="keyword">return</span> bucket.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> EMPTY_NODE.second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载[]运算符：支持map[key]读写（修复引用返回问题）</span></span><br><span class="line">    V&amp; <span class="keyword">operator</span>[](<span class="type">const</span> K&amp; key) &#123;</span><br><span class="line">        <span class="type">int</span> idx = <span class="built_in">hash</span>(key);</span><br><span class="line">        <span class="keyword">auto</span> it = <span class="built_in">find_iter</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it != data[idx].<span class="built_in">end</span>()) <span class="keyword">return</span> it-&gt;second;</span><br><span class="line"></span><br><span class="line">        data[idx].<span class="built_in">emplace_back</span>(key, <span class="built_in">V</span>());</span><br><span class="line">        <span class="keyword">return</span> data[idx].<span class="built_in">back</span>().second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断哈希表是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; BASE; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!data[i].<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取有效键值对数量</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; BASE; ++i) &#123;</span><br><span class="line">            cnt += data[i].<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希集合：链地址法实现，存储唯一key，无value</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Unordered_Set</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> BASE = <span class="number">1000</span>;</span><br><span class="line">    vector&lt;vector&lt;K&gt;&gt; data; <span class="comment">// 桶数组：每个桶是一个key链表</span></span><br><span class="line">    <span class="type">const</span> K EMPTY_NODE;     <span class="comment">// 空节点标记</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希函数：映射key到桶下标</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hash</span><span class="params">(<span class="type">const</span> K&amp; key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> hash_val = std::hash&lt;K&gt;&#123;&#125;(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(hash_val % BASE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找key：存在返回true，否则false</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">const</span> K&amp; key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> idx = <span class="built_in">hash</span>(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; val : data[idx]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val == key) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数：初始化桶数组+空节点</span></span><br><span class="line">    <span class="built_in">Unordered_Set</span>() : <span class="built_in">data</span>(BASE), <span class="built_in">EMPTY_NODE</span>(<span class="built_in">K</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数：自动释放内存</span></span><br><span class="line">    ~<span class="built_in">Unordered_Set</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入key：已存在则跳过，保证唯一性</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> K&amp; key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(key)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> hash_idx = <span class="built_in">hash</span>(key);</span><br><span class="line">        data[hash_idx].<span class="built_in">push_back</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除指定key：成功true，失败false（核心修复）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">erase</span><span class="params">(<span class="type">const</span> K&amp; key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> idx = <span class="built_in">hash</span>(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = data[idx].<span class="built_in">begin</span>(); it != data[idx].<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*it == key) &#123;</span><br><span class="line">                data[idx].<span class="built_in">erase</span>(it);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断key是否存在</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(<span class="type">const</span> K&amp; key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断集合是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; BASE; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!data[i].<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取集合中元素数量</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; BASE; ++i) &#123;</span><br><span class="line">            cnt += data[i].<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="13-排序">13, 排序</h3>
<h4 id="1-冒泡排序">(1), 冒泡排序</h4>
<p>冒泡排序是一种简单的排序算法，它重复地遍历要排序的列表，一次比较两个元素，如果它们的顺序错误就把它们交换过来。遍历列表的工作是重复地进行直到没有再需要交换，也就是说该列表已经排序完成。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">bool</span> log=<span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;arr.<span class="built_in">size</span>()<span class="number">-1</span>-i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j]&gt;arr[j<span class="number">+1</span>]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(arr[j],arr[j<span class="number">+1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (log) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j: arr) &#123;</span><br><span class="line">                cout&lt;&lt;j&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-选择排序">(2), 选择排序</h4>
<p>选择排序是一种简单的排序算法，它的工作原理是每次从待排序的元素中选择最小（或最大）的一个，存放到排序序列的起始位置，直到全部待排序的元素排完。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectionSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">bool</span> log=<span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> minIdx = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;arr.<span class="built_in">size</span>();j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIdx]) &#123;</span><br><span class="line">                minIdx = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[minIdx]);</span><br><span class="line">        <span class="keyword">if</span> (log) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j: arr) &#123;</span><br><span class="line">                cout &lt;&lt; j &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-插入排序">(3), 插入排序</h4>
<p>插入排序是一种简单的排序算法，它的工作原理是将待排序的元素一个一个地插入到已经排序的序列中，从而得到一个新的排序序列。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">bool</span> log = <span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">empty</span>() || arr.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; sorted;</span><br><span class="line">    sorted.<span class="built_in">reserve</span>(arr.<span class="built_in">size</span>()); <span class="comment">// ✅ 优化：预分配内存，提升效率</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = (<span class="type">int</span>)sorted.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> idx = (<span class="type">int</span>)sorted.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 二分查找插入位置（优化版插入排序，你的设计亮点保留）</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>; <span class="comment">// ✅ 修复：防整数溢出</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt;= sorted[mid]) &#123;</span><br><span class="line">                idx = mid;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sorted.<span class="built_in">insert</span>(sorted.<span class="built_in">begin</span>() + idx, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    arr = <span class="built_in">move</span>(sorted); <span class="comment">// ✅ 致命修复：将排序结果回写到原数组</span></span><br><span class="line">    <span class="keyword">if</span> (log) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : arr) cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-希尔排序">(4), 希尔排序</h4>
<p>希尔排序是一种基于插入排序的排序算法，它的工作原理是先将待排序的元素按照一定的间隔分组，对每组元素进行插入排序，然后逐渐缩小间隔，重复以上过程，直到间隔为1，最后进行一次插入排序。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">bool</span> log=<span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> gap = arr.<span class="built_in">size</span>()/<span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = gap; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> j = i;</span><br><span class="line">            <span class="type">int</span> temp = arr[i];</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= gap &amp;&amp; arr[j-gap] &gt; temp) &#123;</span><br><span class="line">                arr[j] = arr[j-gap];</span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (log) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: arr) &#123;</span><br><span class="line">            cout&lt;&lt;num&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-快速排序">(5), 快速排序</h4>
<p>快速排序是一种基于分治法的排序算法，它的工作原理是选择一个基准元素，将待排序的元素分为两部分，一部分小于基准元素，一部分大于基准元素，然后对这两部分分别进行快速排序，最后将两部分合并起来。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">bool</span> log=<span class="literal">false</span>, <span class="type">int</span> randomType = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    function&lt;<span class="type">void</span> (<span class="type">int</span>, <span class="type">int</span>)&gt; quickSort = [&amp;](<span class="type">int</span> left, <span class="type">int</span> right) &#123;</span><br><span class="line"><span class="comment">//            cnt++;</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> pivot = <span class="built_in">getPivot</span>(arr, left, right, randomType);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = left, j = right;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (arr[i] &lt; pivot)  i++;</span><br><span class="line">            <span class="keyword">while</span> (arr[j] &gt; pivot)  j--;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= j) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">quickSort</span>(left, j);</span><br><span class="line">        <span class="built_in">quickSort</span>(i, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (log) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num: arr) &#123;</span><br><span class="line">                cout&lt;&lt;num&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">quickSort</span>(<span class="number">0</span>, arr.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line"><span class="comment">//        cout&lt;&lt;cnt&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getPivot</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivotIdx = left;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: pivotIdx = left; <span class="keyword">break</span>;    <span class="comment">// 左端点为基准</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: pivotIdx = right; <span class="keyword">break</span>;   <span class="comment">// 右端点为基准</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: pivotIdx = left + (right - left) / <span class="number">2</span>; <span class="keyword">break</span>; <span class="comment">// 中点为基准（防溢出）</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">// ✅ 新增：随机基准（最优，推荐），解决有序数组退化问题</span></span><br><span class="line">            <span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line">            pivotIdx = left + <span class="built_in">rand</span>() % (right - left + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[pivotIdx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-归并排序">(6), 归并排序</h4>
<p>归并排序是一种基于分治法的排序算法，它的工作原理是将待排序的元素分为两部分，分别对这两部分进行归并排序，最后将两部分合并起来。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">bool</span> log=<span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">    function&lt;<span class="type">void</span> (<span class="type">int</span>, <span class="type">int</span>)&gt; mergeSort = [&amp;](<span class="type">int</span> left, <span class="type">int</span> right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">mergeSort</span>(left, mid);</span><br><span class="line">        <span class="built_in">mergeSort</span>(mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(right - left + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> i = left, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid || j &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i== mid<span class="number">+1</span>) &#123;</span><br><span class="line">                temp[k++] = arr[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == right<span class="number">+1</span>) &#123;</span><br><span class="line">                temp[k++] = arr[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">                temp[k++] = arr[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[k++] = arr[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> m=<span class="number">0</span>;m&lt;temp.<span class="built_in">size</span>();m++) &#123;</span><br><span class="line">            arr[left+m] = temp[m];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">mergeSort</span>(<span class="number">0</span>, arr.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (log) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num:arr) &#123;</span><br><span class="line">            cout&lt;&lt;num&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-堆排序">(7), 堆排序</h4>
<p>堆排序是一种基于堆数据结构的排序算法，它的工作原理是将待排序的元素构建成一个大顶堆（或小顶堆），然后将堆顶元素与堆底元素交换，将最大（或最小）元素放到正确的位置，然后对剩余的元素重新构建堆，重复以上过程，直到堆为空。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">bool</span> log = <span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">    function&lt;<span class="type">void</span> (<span class="type">int</span> ,<span class="type">int</span>, <span class="type">bool</span>)&gt; heapify = [&amp;](<span class="type">int</span> cur,<span class="type">int</span> n, <span class="type">bool</span> type) &#123;</span><br><span class="line">        <span class="keyword">if</span> (type) &#123;</span><br><span class="line">            <span class="keyword">while</span> (cur &amp;&amp; arr[cur] &lt; arr[(cur<span class="number">-1</span>)/<span class="number">2</span>]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(arr[cur], arr[(cur<span class="number">-1</span>)/<span class="number">2</span>]);</span><br><span class="line">                cur = (cur<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (cur*<span class="number">2</span><span class="number">+1</span>&lt;n) &#123;</span><br><span class="line">                <span class="type">int</span> left = cur*<span class="number">2</span><span class="number">+1</span>;</span><br><span class="line">                <span class="type">int</span> right = cur*<span class="number">2</span><span class="number">+2</span>;</span><br><span class="line">                <span class="type">int</span> maxIdx = left;</span><br><span class="line">                <span class="keyword">if</span> (right&lt;n &amp;&amp; arr[right]&lt;arr[maxIdx]) &#123;</span><br><span class="line">                    maxIdx = right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (arr[cur]&gt;arr[maxIdx]) &#123;</span><br><span class="line">                    <span class="built_in">swap</span>(arr[cur], arr[maxIdx]);</span><br><span class="line">                    cur = maxIdx;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        <span class="built_in">heapify</span>(i, i<span class="number">+1</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; sortedArr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        sortedArr.<span class="built_in">push_back</span>(arr[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[arr.<span class="built_in">size</span>()<span class="number">-1</span>-i]);</span><br><span class="line">        <span class="built_in">heapify</span>(<span class="number">0</span>, arr.<span class="built_in">size</span>()<span class="number">-1</span>-i, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (log) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j: sortedArr) &#123;</span><br><span class="line">                cout&lt;&lt;j&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr = sortedArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这个，产生有限队列</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用优先级队列（堆实现）</span></span><br><span class="line"><span class="comment">// ElemType: 元素类型</span></span><br><span class="line"><span class="comment">// STL: 底层存储容器（默认vector，需支持push_back/pop_back/[]/size/empty）</span></span><br><span class="line"><span class="comment">// Compare: 比较器（默认less&lt;ElemType&gt;，实现大顶堆；greater则为小顶堆）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ElemType,</span><br><span class="line">        <span class="keyword">typename</span> STL = std::vector&lt;ElemType&gt;,</span><br><span class="line">        <span class="keyword">typename</span> Compare = std::less&lt;ElemType&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> PriorityQueue &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    STL heap;          <span class="comment">// 底层存储容器（堆的物理结构）</span></span><br><span class="line">    Compare cmp;       <span class="comment">// 比较器（决定堆的类型：大顶/小顶）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向上调整（插入元素后，维护堆性质）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// idx为当前元素下标，从0开始</span></span><br><span class="line">        <span class="keyword">while</span> (idx &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> parent = (idx - <span class="number">1</span>) / <span class="number">2</span>;  <span class="comment">// 父节点下标</span></span><br><span class="line">            <span class="comment">// 若父节点不满足比较规则，则交换并继续向上</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">cmp</span>(heap[parent], heap[idx])) &#123;</span><br><span class="line">                std::<span class="built_in">swap</span>(heap[parent], heap[idx]);</span><br><span class="line">                idx = parent;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// 堆性质已满足，退出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向下调整（删除堆顶后，维护堆性质）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = heap.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> left = <span class="number">2</span> * idx + <span class="number">1</span>;   <span class="comment">// 左子节点</span></span><br><span class="line">            <span class="type">int</span> right = <span class="number">2</span> * idx + <span class="number">2</span>;  <span class="comment">// 右子节点</span></span><br><span class="line">            <span class="type">int</span> target = idx;         <span class="comment">// 记录需要交换的节点（初始为自身）</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 找到子节点中满足比较规则的最大/最小节点</span></span><br><span class="line">            <span class="keyword">if</span> (left &lt; size &amp;&amp; <span class="built_in">cmp</span>(heap[target], heap[left])) &#123;</span><br><span class="line">                target = left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right &lt; size &amp;&amp; <span class="built_in">cmp</span>(heap[target], heap[right])) &#123;</span><br><span class="line">                target = right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若目标节点不是自身，交换并继续向下</span></span><br><span class="line">            <span class="keyword">if</span> (target != idx) &#123;</span><br><span class="line">                std::<span class="built_in">swap</span>(heap[idx], heap[target]);</span><br><span class="line">                idx = target;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// 堆性质已满足，退出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">PriorityQueue</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用拷贝（如需拷贝可自行实现深拷贝）</span></span><br><span class="line">    <span class="built_in">PriorityQueue</span>(<span class="type">const</span> PriorityQueue&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    PriorityQueue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> PriorityQueue&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造/赋值（提高性能）</span></span><br><span class="line">    <span class="built_in">PriorityQueue</span>(PriorityQueue&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    PriorityQueue&amp; <span class="keyword">operator</span>=(PriorityQueue&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数（依赖容器自身的析构）</span></span><br><span class="line">    ~<span class="built_in">PriorityQueue</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 插入元素到优先级队列</span></span><br><span class="line"><span class="comment">     * @param val 待插入的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> ElemType&amp; val)</span> </span>&#123;</span><br><span class="line">        heap.<span class="built_in">push_back</span>(val);          <span class="comment">// 插入到容器尾部</span></span><br><span class="line">        <span class="built_in">up</span>(heap.<span class="built_in">size</span>() - <span class="number">1</span>);          <span class="comment">// 向上调整，维护堆性质</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动版本push（优化右值引用）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(ElemType&amp;&amp; val)</span> </span>&#123;</span><br><span class="line">        heap.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(val));</span><br><span class="line">        <span class="built_in">up</span>(heap.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 弹出堆顶元素（优先级最高的元素）</span></span><br><span class="line"><span class="comment">     * @throw out_of_range 队列为空时抛出</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;PriorityQueue::pop: queue is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 堆顶与最后一个元素交换，删除最后一个元素</span></span><br><span class="line">        std::<span class="built_in">swap</span>(heap[<span class="number">0</span>], heap.<span class="built_in">back</span>());</span><br><span class="line">        heap.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="comment">// 向下调整堆顶，维护堆性质</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="built_in">down</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取堆顶元素（不弹出）</span></span><br><span class="line"><span class="comment">     * @return 堆顶元素的引用</span></span><br><span class="line"><span class="comment">     * @throw out_of_range 队列为空时抛出</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ElemType&amp; <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;PriorityQueue::top: queue is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heap[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// const版本top</span></span><br><span class="line">    <span class="function"><span class="type">const</span> ElemType&amp; <span class="title">top</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;PriorityQueue::top: queue is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heap[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 判断队列是否为空</span></span><br><span class="line"><span class="comment">     * @return 空返回true，否则false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> heap.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取队列中元素个数</span></span><br><span class="line"><span class="comment">     * @return 元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> heap.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 清空队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        heap.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结束~</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.imgs.ovh/2025/12/20/ClnnUM.md.png" alt=""></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://sakjijdidji55.github.io">欣冻</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://sakjijdidji55.github.io/posts/bc9ae956.html">https://sakjijdidji55.github.io/posts/bc9ae956.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://sakjijdidji55.github.io" target="_blank">迷路的小朋友</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="https://i.imgs.ovh/2025/12/20/ClnnUM.md.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/posts/a6d4d6d1.html" title="JavaGame实现笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.imgs.ovh/2025/12/20/Cln2Wr.md.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">JavaGame实现笔记</div></div><div class="info-2"><div class="info-item-1">JavaGame：一个用Java实现的Pygame风格游戏开发模块 一、项目背景 Pygame是Python生态中非常流行的游戏开发库，它提供了简单易用的API，让开发者能够快速创建2D游戏。然而，对于Java开发者来说，虽然有JavaFX、LibGDX等游戏开发框架，但缺乏一个像Pygame那样轻量级、易于上手的选择。 为此，我开发了JavaGame模块，这是一个用Java实现的类似Pygame的游戏开发库，基于JavaFX构建，提供了简洁明了的API，让Java开发者也能享受到Pygame式的开发体验。 二、设计理念 JavaGame的设计理念主要有以下几点：  简单易用：提供类似Pygame的简洁API，降低游戏开发门槛 轻量级：核心模块只有几个Java文件，易于集成和扩展 高性能：采用双缓冲技术，避免屏幕闪烁，提供流畅的游戏体验 线程安全：事件队列采用线程安全设计，确保多线程环境下的稳定性 跨平台：基于JavaFX，支持Windows、macOS和Linux等主流操作系统  三、核心功能 1....</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/my-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">欣冻</div><div class="author-info-description">博客, 技术, 生活</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.</span> <span class="toc-text">数据结构与算法实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%A1%BA%E5%BA%8F%E8%A1%A8%EF%BC%88SeqList%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">1, 顺序表（SeqList）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%88Linked-List%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">2, 单链表（Linked List）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%B1%BB%EF%BC%88DuLinkList%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">3, 双向循环链表类（DuLinkList）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%92%8C%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">4, 栈的实现（顺序存储和链式存储）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%92%8C%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%EF%BC%89"><span class="toc-number">1.5.</span> <span class="toc-text">5, 队列的实现（顺序存储和链式存储）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97%EF%BC%88LinkQueue%EF%BC%89"><span class="toc-number">1.5.1.</span> <span class="toc-text">链式队列（LinkQueue）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%EF%BC%88String%EF%BC%89"><span class="toc-number">1.6.</span> <span class="toc-text">6, 字符串类（String）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%9A%E9%95%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88FixedString%EF%BC%89%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA"><span class="toc-number">1.6.1.</span> <span class="toc-text">1. 定长字符串（FixedString）核心理论</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">（1）数据结构本质</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">（2）核心特性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%A0%B8%E5%BF%83%E6%93%8D%E4%BD%9C%E7%90%86%E8%AE%BA%E6%94%AF%E6%92%91"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">（3）核心操作理论支撑</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88HeapString%EF%BC%89%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA"><span class="toc-number">1.6.2.</span> <span class="toc-text">2. 堆字符串（HeapString）核心理论</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%AC%E8%B4%A8-2"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">（1）数据结构本质</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7-2"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">（2）核心特性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%A0%B8%E5%BF%83%E6%93%8D%E4%BD%9C%E7%90%86%E8%AE%BA%E6%94%AF%E6%92%91-2"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">（3）核心操作理论支撑</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%AE%9A%E9%95%BF%E4%B8%B2%E4%B8%8E%E5%A0%86%E4%B8%B2%E6%A0%B8%E5%BF%83%E5%AF%B9%E6%AF%94"><span class="toc-number">1.6.2.4.</span> <span class="toc-text">（4）定长串与堆串核心对比</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%80%9A%E7%94%A8%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA%EF%BC%88%E4%B8%A4%E7%B1%BB%E4%B8%B2%E5%85%B1%E6%80%A7%EF%BC%89"><span class="toc-number">1.6.3.</span> <span class="toc-text">3. 字符串通用核心理论（两类串共性）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%B1%BB%EF%BC%88TwoDArray%EF%BC%89"><span class="toc-number">1.7.</span> <span class="toc-text">7, 二维数组类（TwoDArray）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%AD%98%E5%82%A8%E6%9C%AC%E8%B4%A8%EF%BC%88%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA%EF%BC%89"><span class="toc-number">1.7.1.</span> <span class="toc-text">1. 二维数组的存储本质（核心理论）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%A4%E7%A7%8D%E6%A0%B8%E5%BF%83%E5%AD%98%E5%82%A8%E6%98%A0%E5%B0%84%E8%A7%84%E5%88%99%EF%BC%88%E6%95%B0%E7%BB%84%E5%AF%BB%E5%9D%80%E7%90%86%E8%AE%BA%EF%BC%89"><span class="toc-number">1.7.2.</span> <span class="toc-text">2. 两种核心存储映射规则（数组寻址理论）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E8%A1%8C%E4%BC%98%E5%85%88%E5%AD%98%E5%82%A8%EF%BC%88Row-Major-Order%EF%BC%89"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">（1）行优先存储（Row-Major Order）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E8%A7%84%E5%88%99"><span class="toc-number">1.7.2.1.1.</span> <span class="toc-text">核心规则</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AF%BB%E5%9D%80%E5%85%AC%E5%BC%8F%EF%BC%88%E6%A0%B8%E5%BF%83%EF%BC%89"><span class="toc-number">1.7.2.1.2.</span> <span class="toc-text">寻址公式（核心）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%90%86%E8%AE%BA%E7%89%B9%E7%82%B9"><span class="toc-number">1.7.2.1.3.</span> <span class="toc-text">理论特点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%88%97%E4%BC%98%E5%85%88%E5%AD%98%E5%82%A8%EF%BC%88Column-Major-Order%EF%BC%89"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">（2）列优先存储（Column-Major Order）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E8%A7%84%E5%88%99-2"><span class="toc-number">1.7.2.2.1.</span> <span class="toc-text">核心规则</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AF%BB%E5%9D%80%E5%85%AC%E5%BC%8F%EF%BC%88%E6%A0%B8%E5%BF%83%EF%BC%89-2"><span class="toc-number">1.7.2.2.2.</span> <span class="toc-text">寻址公式（核心）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%90%86%E8%AE%BA%E7%89%B9%E7%82%B9-2"><span class="toc-number">1.7.2.2.3.</span> <span class="toc-text">理论特点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%A8%A1%E6%9D%BF%E5%8C%96%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="toc-number">1.7.3.</span> <span class="toc-text">3. 模板化二维数组核心特性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%97%A0%E5%85%B3%E6%80%A7"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">（1）数据类型无关性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%90%86%E8%AE%BA"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">（2）内存管理理论</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%A0%B8%E5%BF%83%E6%93%8D%E4%BD%9C%E7%90%86%E8%AE%BA%E7%BA%A6%E6%9D%9F"><span class="toc-number">1.7.4.</span> <span class="toc-text">4. 核心操作理论约束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%9A%84%E9%80%9A%E7%94%A8%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.7.5.</span> <span class="toc-text">5. 二维数组顺序存储的通用优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">1.7.5.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">1.7.5.2.</span> <span class="toc-text">缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%B1%BB%EF%BC%88SparseMatrix%EF%BC%89"><span class="toc-number">1.8.</span> <span class="toc-text">8, 稀疏矩阵类（SparseMatrix）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.8.0.1.</span> <span class="toc-text">（1）存储结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%A0%B8%E5%BF%83%E6%93%8D%E4%BD%9C"><span class="toc-number">1.8.0.2.</span> <span class="toc-text">（2）核心操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.8.0.3.</span> <span class="toc-text">（3）适用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%B9%BF%E4%B9%89%E8%A1%A8%EF%BC%88Generalized-List%EF%BC%89"><span class="toc-number">1.9.</span> <span class="toc-text">9, 广义表（Generalized List）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%B9%BF%E4%B9%89%E8%A1%A8%E5%AE%9A%E4%B9%89"><span class="toc-number">1.9.1.</span> <span class="toc-text">(1), 广义表定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B9%BF%E4%B9%89%E8%A1%A8%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.9.2.</span> <span class="toc-text">(2), 广义表表示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%B9%BF%E4%B9%89%E8%A1%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">1.9.3.</span> <span class="toc-text">(3), 广义表操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E6%A0%91%EF%BC%88Tree%EF%BC%89"><span class="toc-number">1.10.</span> <span class="toc-text">10, 树（Tree）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BA%8C%E5%8F%89%E6%A0%91-Binary-Tree"><span class="toc-number">1.10.1.</span> <span class="toc-text">(1), 二叉树 (Binary Tree)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AE%9A%E4%B9%89"><span class="toc-number">1.10.1.1.</span> <span class="toc-text">二叉树定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%93%8D%E4%BD%9C"><span class="toc-number">1.10.1.2.</span> <span class="toc-text">二叉树操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E6%A0%91%E4%B8%8E%E6%A3%AE%E6%9E%97-Tree-and-Forest"><span class="toc-number">1.10.2.</span> <span class="toc-text">(2), 二叉树与树与森林 (Tree and Forest)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%91%EF%BC%88Tree%EF%BC%89"><span class="toc-number">1.10.2.1.</span> <span class="toc-text">树（Tree）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97%EF%BC%88Forest%EF%BC%89"><span class="toc-number">1.10.2.2.</span> <span class="toc-text">森林（Forest）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.10.2.3.</span> <span class="toc-text">树与二叉树的转换</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-Binary-Search-Tree"><span class="toc-number">1.10.3.</span> <span class="toc-text">(3), 二叉搜索树 (Binary Search Tree)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.10.3.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C"><span class="toc-number">1.10.3.2.</span> <span class="toc-text">操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-AVl%E6%A0%91"><span class="toc-number">1.10.4.</span> <span class="toc-text">(4), 平衡二叉树 (AVl树)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-2"><span class="toc-number">1.10.4.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C-2"><span class="toc-number">1.10.4.2.</span> <span class="toc-text">操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91-Huffman-Tree"><span class="toc-number">1.10.5.</span> <span class="toc-text">(5), 哈夫曼树 (Huffman Tree)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%AE%9A%E4%B9%89"><span class="toc-number">1.10.5.1.</span> <span class="toc-text">哈夫曼树定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-number">1.10.5.2.</span> <span class="toc-text">哈夫曼树的构造</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">1.10.5.3.</span> <span class="toc-text">哈夫曼树的性质</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.10.5.4.</span> <span class="toc-text">哈夫曼树的应用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-B-B-%E6%A0%91-B-Tree-B-Tree"><span class="toc-number">1.10.6.</span> <span class="toc-text">(6), B-, B+树 (B-Tree, B+Tree)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E6%A0%91%E5%AE%9A%E4%B9%89"><span class="toc-number">1.10.6.1.</span> <span class="toc-text">B-树定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E6%A0%91%E5%AE%9A%E4%B9%89-2"><span class="toc-number">1.10.6.2.</span> <span class="toc-text">B+树定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E6%A0%91%E5%92%8CB-%E6%A0%91%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.10.6.3.</span> <span class="toc-text">B-树和B+树的比较</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E6%A0%91%E5%92%8CB-%E6%A0%91%E7%9A%84%E7%94%A8%E9%80%94"><span class="toc-number">1.10.6.4.</span> <span class="toc-text">B-树和B+树的用途</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%9B%BE"><span class="toc-number">1.11.</span> <span class="toc-text">11, 图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%B9%BF%E6%90%9C%E4%B8%8E%E6%B7%B1%E6%90%9C%EF%BC%88%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%89"><span class="toc-number">1.11.1.</span> <span class="toc-text">(1), 广搜与深搜（图的遍历）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-3"><span class="toc-number">1.11.1.1.</span> <span class="toc-text">定义</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">1.11.2.</span> <span class="toc-text">(2), 最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Prim%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.11.2.1.</span> <span class="toc-text">Prim算法介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Kruskal%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.11.2.2.</span> <span class="toc-text">Kruskal算法介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">1.11.2.3.</span> <span class="toc-text">并查集</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="toc-number">1.11.3.</span> <span class="toc-text">(3), 拓扑排序与关键路径</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-4"><span class="toc-number">1.11.3.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.11.3.2.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-number">1.11.4.</span> <span class="toc-text">(4), 最短路径</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-5"><span class="toc-number">1.11.4.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="toc-number">1.11.4.2.</span> <span class="toc-text">应用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E6%90%9C%E7%B4%A2"><span class="toc-number">1.12.</span> <span class="toc-text">12, 搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E5%93%88%E5%B8%8C"><span class="toc-number">1.12.1.</span> <span class="toc-text">(1), 线性探测哈希</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%97%A0%E5%BA%8F%E5%AD%97%E5%85%B8%EF%BC%88Unordered-Dictionary%EF%BC%89"><span class="toc-number">1.12.2.</span> <span class="toc-text">(2), 无序字典（Unordered Dictionary）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E6%8E%92%E5%BA%8F"><span class="toc-number">1.13.</span> <span class="toc-text">13, 排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">1.13.1.</span> <span class="toc-text">(1), 冒泡排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">1.13.2.</span> <span class="toc-text">(2), 选择排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">1.13.3.</span> <span class="toc-text">(3), 插入排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">1.13.4.</span> <span class="toc-text">(4), 希尔排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">1.13.5.</span> <span class="toc-text">(5), 快速排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">1.13.6.</span> <span class="toc-text">(6), 归并排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">1.13.7.</span> <span class="toc-text">(7), 堆排序</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/bc9ae956.html" title="数据结构与算法实现"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.imgs.ovh/2025/12/20/ClnnUM.md.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构与算法实现"/></a><div class="content"><a class="title" href="/posts/bc9ae956.html" title="数据结构与算法实现">数据结构与算法实现</a><time datetime="2025-12-28T10:00:00.000Z" title="发表于 2025-12-28 18:00:00">2025-12-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/a6d4d6d1.html" title="JavaGame实现笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.imgs.ovh/2025/12/20/Cln2Wr.md.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaGame实现笔记"/></a><div class="content"><a class="title" href="/posts/a6d4d6d1.html" title="JavaGame实现笔记">JavaGame实现笔记</a><time datetime="2025-12-25T04:24:02.000Z" title="发表于 2025-12-25 12:24:02">2025-12-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/e329799.html" title="C++后端服务器实现笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.imgs.ovh/2025/12/03/CsbqBg.md.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++后端服务器实现笔记"/></a><div class="content"><a class="title" href="/posts/e329799.html" title="C++后端服务器实现笔记">C++后端服务器实现笔记</a><time datetime="2025-12-01T08:00:00.000Z" title="发表于 2025-12-01 16:00:00">2025-12-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4260ab42.html" title="Transformer大语言模型架构原理学习笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.imgs.ovh/2025/11/17/CfYA2b.md.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Transformer大语言模型架构原理学习笔记"/></a><div class="content"><a class="title" href="/posts/4260ab42.html" title="Transformer大语言模型架构原理学习笔记">Transformer大语言模型架构原理学习笔记</a><time datetime="2025-11-17T12:51:00.000Z" title="发表于 2025-11-17 20:51:00">2025-11-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/6f4fa4e7.html" title="快速幂、逆元与组合数学"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.imgs.ovh/2025/12/19/CdIGkr.md.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="快速幂、逆元与组合数学"/></a><div class="content"><a class="title" href="/posts/6f4fa4e7.html" title="快速幂、逆元与组合数学">快速幂、逆元与组合数学</a><time datetime="2025-10-31T15:48:33.000Z" title="发表于 2025-10-31 23:48:33">2025-10-31</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://i.imgs.ovh/2025/07/03/qLFy9.png);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2026 By 欣冻</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.3</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://blog-twikoo.xindon.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: 'https://blog-twikoo.xindon.top/',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Twikoo' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><div class="aplayer no-destroy" data-id="13348674056" data-server="netease" data-type="playlist"   data-order="list" data-fixed="true" data-preload="auto" data-autoplay="false" data-mutex="true" ></div><script src="https://cdn.jsdelivr.net/npm/mermaid@10.2.4/dist/mermaid.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v 7.3.0" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v5.2.2" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://www.jsdelivr.com/" style="margin-inline:5px" data-title="本站使用JsDelivr为静态资源提供CDN加速" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="https://unpkg.zhimg.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.min.js"></script><script async src="/js/ali_font.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('article-sort-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__slideInRight');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script></body></html>